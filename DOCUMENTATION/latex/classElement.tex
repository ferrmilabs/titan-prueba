\hypertarget{classElement}{
\section{Element Class Reference}
\label{classElement}\index{Element@{Element}}
}
The Element class is a data structure designed to hold all the information need for an h (cell edge length) p (polynomial order) adaptive finite element. Titan doesn't use p adaptation because it is a finite difference/volume code, hence many of the members are legacy from afeapi (adaptive finite element application programmers interface) which serves as the core of titan. There is a seperate Discontinuous Galerkin Method (finite elements + finite volumes) version of titan and the polynomial information is not legacy there. However in this version of Titan elements function simply as finite volume cells.  


{\tt \#include $<$element2.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hyperlink{classElement_a0}{Element} ()
\begin{CompactList}\small\item\em default constructor, does nothing except set stoppedflags=2, this should never be used \item\end{CompactList}\item 
\hyperlink{classElement_a1}{Element} (unsigned nodekeys\mbox{[}$\,$\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}, unsigned neigh\mbox{[}$\,$\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}, int n\_\-pro\mbox{[}$\,$\mbox{]}, \hyperlink{structBC}{BC} $\ast$b, int mat, int $\ast$elm\_\-loc\_\-in, double pile\_\-height, int myid, unsigned $\ast$opposite\_\-brother)
\begin{CompactList}\small\item\em constructor that creates an original element when funky is read in \item\end{CompactList}\item 
\hyperlink{classElement_a2}{Element} (unsigned nodekeys\mbox{[}$\,$\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}, unsigned neigh\mbox{[}$\,$\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}, int n\_\-pro\mbox{[}$\,$\mbox{]}, \hyperlink{structBC}{BC} $\ast$b, int gen, int elm\_\-loc\_\-in\mbox{[}$\,$\mbox{]}, int $\ast$ord, int gen\_\-neigh\mbox{[}$\,$\mbox{]}, int mat, \hyperlink{classElement}{Element} $\ast$fth\-Temp, double $\ast$coord\_\-in, \hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int myid, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, int iwetnodefather, double Awetfather, double $\ast$drypoint\_\-in)
\begin{CompactList}\small\item\em constructor that creates a son element from its father during refinement \item\end{CompactList}\item 
\hyperlink{classElement_a3}{Element} (\hyperlink{classElement}{Element} $\ast$sons\mbox{[}$\,$\mbox{]}, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr)
\begin{CompactList}\small\item\em constructor that creates a father element from its four sons during unrefinement \item\end{CompactList}\item 
\hyperlink{classElement_a4}{Element} (FILE $\ast$fp, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, int myid)
\begin{CompactList}\small\item\em constructor that creates/restores a saved element during restart \item\end{CompactList}\item 
\hyperlink{classElement_a5}{$\sim$Element} ()
\begin{CompactList}\small\item\em destructor that does nothing except delete boundary condition pointer \item\end{CompactList}\item 
void \hyperlink{classElement_a6}{save\_\-elem} (FILE $\ast$fp, FILE $\ast$fptxt)
\begin{CompactList}\small\item\em this member function saves a single element to a file with a single fwrite call, this allows the element to be recreated/restored upon restart of a simulation \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a7}{pass\_\-key} ()
\begin{CompactList}\small\item\em returns address of element (same as bubble node, node 8 out of 0-$>$8) hashtable key \item\end{CompactList}\item 
int \hyperlink{classElement_a8}{get\_\-material} ()
\begin{CompactList}\small\item\em returns the integer material flag for this element, needed for use of a material map which allows bedfriction to vary with physical position \item\end{CompactList}\item 
void \hyperlink{classElement_a9}{get\_\-stiffness} (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, double $\ast$, double $\ast$, \hyperlink{classElement}{Element} $\ast$)
\begin{CompactList}\small\item\em legacy afeapi function prototype, this function does not exist in the finite difference/volume version of Titan \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a10}{get\-Node} ()
\begin{CompactList}\small\item\em returns the address of the first of 8 (nodes 0-7) node keys in an array, the node keys are used to access the nodes through the node hashtable \item\end{CompactList}\item 
int $\ast$ \hyperlink{classElement_a11}{getassoc} ()
\begin{CompactList}\small\item\em returns the array of 8 processors for the 8 neigbors of this element \item\end{CompactList}\item 
int \hyperlink{classElement_a12}{get\_\-no\_\-of\_\-dof} ()
\begin{CompactList}\small\item\em not used in finite difference/volume version of titan, legacy, returns number of degrees of freedom, used is global stiffness matrices \item\end{CompactList}\item 
void \hyperlink{classElement_a13}{put\_\-gen} (int)
\begin{CompactList}\small\item\em set the generation (number of times it's been refined -8$<$=gen$<$=+3) of this \char`\"{}element\char`\"{}/cell \item\end{CompactList}\item 
void \hyperlink{classElement_a14}{putson} (unsigned $\ast$)
\begin{CompactList}\small\item\em store the keys for the four son \char`\"{}elements\char`\"{} in the father element, used temporarily during refinement \item\end{CompactList}\item 
void \hyperlink{classElement_a15}{putbrothers} (unsigned $\ast$)
\begin{CompactList}\small\item\em when a father element is refined into 4 son elements, the 4 son elements are \char`\"{}brothers\char`\"{} (they can be recombined into the father), this function stores the keys of all four brothers in one of them, it should be called 4 times one for each brother \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a16}{get\_\-brothers} ()
\begin{CompactList}\small\item\em this function returns the keys of an element's 4 brothers (an element is considered to be it's own brother) this is used during unrefinement to combine 4 brothers into their father element \item\end{CompactList}\item 
void \hyperlink{classElement_a17}{putassoc} (int a, int i)
\begin{CompactList}\small\item\em this function stores the processor id \char`\"{}a\char`\"{} of neighbor \char`\"{}i\char`\"{} in the 8 element array of neighbor processors, this functionality is duplicated by put\_\-neigh\_\-proc which is the preferred function to use (don't use this one it's legacy) \item\end{CompactList}\item 
void \hyperlink{classElement_a18}{putneighbor} (unsigned $\ast$n, int i)
\begin{CompactList}\small\item\em this function stores the key \char`\"{}n\char`\"{} of neighbor \char`\"{}i\char`\"{} in the array of the 8 keys of the neighbor keys \item\end{CompactList}\item 
void \hyperlink{classElement_a19}{put\_\-neigh\_\-proc} (int i, int proc)
\begin{CompactList}\small\item\em this function stores the processor id \char`\"{}proc\char`\"{} of neighbor \char`\"{}i\char`\"{} in the 8 element array of neighbor processors, use this function instead of putassoc. \item\end{CompactList}\item 
void \hyperlink{classElement_a20}{put\_\-order} (int, int)
\begin{CompactList}\small\item\em afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) \item\end{CompactList}\item 
int $\ast$ \hyperlink{classElement_a21}{get\_\-order} ()
\begin{CompactList}\small\item\em afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a22}{getfather} ()
\begin{CompactList}\small\item\em find and return what the key of this element's father element would be, very simple since the bubble node has the same key as the element, so all this function does is find which of its corner nodes will be the father element's bubble node, which it knows since it knows which\_\-son it is. \item\end{CompactList}\item 
void \hyperlink{classElement_a23}{put\_\-father} (unsigned fatherin\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]})
\begin{CompactList}\small\item\em store the father's key in the \char`\"{}father\char`\"{} variable, the \char`\"{}father's\char`\"{} key is zero until an element has been unrefined (and has not yet been deleted) it is only used in unrefinement. The \hyperlink{classElement_a22}{getfather()} member function computes the father key from \char`\"{}which\_\-son\char`\"{} and it's nodes and is totally unrelated to the father variable. \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a24}{getson} ()
\begin{CompactList}\small\item\em return the element keys of this element's 4 sons, used during refinement \item\end{CompactList}\item 
void \hyperlink{classElement_a25}{putel\_\-sq} (double solsq, double ellsq)
\begin{CompactList}\small\item\em stores the ?square? of the \char`\"{}solution\char`\"{} and solution error, used durring refinement \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a26}{get\_\-el\_\-solution} ()
\begin{CompactList}\small\item\em return the element's solution vector \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a27}{get\_\-el\_\-error} ()
\begin{CompactList}\small\item\em returns the element's error vector \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a28}{get\_\-neighbors} ()
\begin{CompactList}\small\item\em returns the array of keys for this element's 8 neighbors \item\end{CompactList}\item 
int $\ast$ \hyperlink{classElement_a29}{get\_\-neigh\_\-proc} ()
\begin{CompactList}\small\item\em returns the array of processor ids for this element's 8 neighbors \item\end{CompactList}\item 
\hyperlink{structBC}{BC} $\ast$ \hyperlink{classElement_a30}{get\_\-bcptr} ()
\begin{CompactList}\small\item\em returns the pointer to this element's array of boundary conditions, not really all that important in titan since any flow that goes beyond the boundary of the GIS map leaves the computational domain. \item\end{CompactList}\item 
int \hyperlink{classElement_a31}{get\_\-gen} ()
\begin{CompactList}\small\item\em returns this elements generation, that is how many times it's been refined -8$<$=generation$<$=+3, negative means courser than original mesh \item\end{CompactList}\item 
int \hyperlink{classElement_a32}{which\_\-neighbor} (unsigned $\ast$Find\-Neigh)
\begin{CompactList}\small\item\em compare the Find\-Neigh key against the keys of this element's 8 neighbors to determine which if any neighbor Find\-Neigh is \item\end{CompactList}\item 
int \hyperlink{classElement_a33}{get\_\-refined\_\-flag} ()
\begin{CompactList}\small\item\em refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. refined can be permanently set to GHOST (defined in \hyperlink{constant_8h}{constant.h}) or zero or temporarily set to 1 (with in the refinement and unrefinement routines), Keith believes it's not being unset (set from 1 to 0) when it should be after the refinement is done. Keith believes the problem is located within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within it, recurse down. \item\end{CompactList}\item 
int \hyperlink{classElement_a34}{get\_\-adapted\_\-flag} ()
\begin{CompactList}\small\item\em magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()} and \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} with adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()} and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within \hyperlink{hadpt_8C_a12}{H\_\-adapt()}, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. \item\end{CompactList}\item 
void \hyperlink{classElement_a35}{change\_\-neighbor} (unsigned $\ast$newneighbs, int which\_\-side, int proc, int reg)
\begin{CompactList}\small\item\em call this function after this element's neighbor(s) have been refined, proc is processor id for neighbor\mbox{[}which\_\-side+4\mbox{]} \item\end{CompactList}\item 
void \hyperlink{classElement_a36}{put\_\-refined\_\-flag} (int i)
\begin{CompactList}\small\item\em set this element's refined flag to i, can set it to normal (hasn't just been refined and isn't a ghost cell), \char`\"{}temporarily\char`\"{} set to \char`\"{}refined\char`\"{} (has just been refined so don't refine again), or say that it's a GHOST cell, see \hyperlink{constant_8h}{constant.h}, (which means you don't update it, instead you get new values from the processor that owns it and you don't refine it.) refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. \item\end{CompactList}\item 
void \hyperlink{classElement_a37}{put\_\-adapted\_\-flag} (int new\_\-adapted\_\-status)
\begin{CompactList}\small\item\em refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. The magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. These values are defined in \hyperlink{constant_8h}{constant.h}. The NEWSON value has allowed Keith to provide one time only immunity from unrefinement to recently refined elements, after which the \char`\"{}adapted\char`\"{} flag is resent to NOTRECADAPTED. \item\end{CompactList}\item 
void \hyperlink{classElement_a38}{put\_\-send\_\-flag} (int, int)
\begin{CompactList}\small\item\em this function is only called in \hyperlink{constant_8h_a21}{htflush.C} to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that \item\end{CompactList}\item 
void \hyperlink{classElement_a39}{put\_\-recv\_\-flag} (int, int)
\begin{CompactList}\small\item\em this function is only called in \hyperlink{constant_8h_a21}{htflush.C} to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that \item\end{CompactList}\item 
int \hyperlink{classElement_a40}{get\_\-send\_\-flag} (int)
\begin{CompactList}\small\item\em this function isn't being called anywhere, which means it is afeapi legacy \item\end{CompactList}\item 
int \hyperlink{classElement_a41}{get\_\-recv\_\-flag} (int)
\begin{CompactList}\small\item\em this function isn't being called anywhere, which means it is afeapi legacy \item\end{CompactList}\item 
int $\ast$ \hyperlink{classElement_a42}{get\_\-neigh\_\-gen} ()
\begin{CompactList}\small\item\em this function returns an array holding the generation of all 8 of this element's neighbors \item\end{CompactList}\item 
void \hyperlink{classElement_a43}{put\_\-neigh\_\-gen} (int i, int gen)
\begin{CompactList}\small\item\em this function sets the ith neighbor's generation to \char`\"{}gen\char`\"{} \item\end{CompactList}\item 
void \hyperlink{classElement_a44}{put\_\-which\_\-son} (int)
\begin{CompactList}\small\item\em this function sets the which\_\-son flag when a father element is refined into its 4 sons, the which\_\-son flag tells the portion of the father element that this element is physically located in \item\end{CompactList}\item 
int \hyperlink{classElement_a45}{get\_\-which\_\-son} ()
\begin{CompactList}\small\item\em returns the which\_\-son flag, which tells the portion of the father element that this element is physically located in \item\end{CompactList}\item 
void \hyperlink{classElement_a46}{calc\_\-which\_\-son} ()
\begin{CompactList}\small\item\em this function calculates the which\_\-son flag for the original (or restored in case of a restart) element. It also calculates which son of the grandfather element the father is durring unrefinement. \item\end{CompactList}\item 
void \hyperlink{classElement_a47}{put\_\-new\_\-old} (int i)
\begin{CompactList}\small\item\em this function sets the new or old flag, it is initialized in \hyperlink{constant_8h_a21}{htflush.C} and reset during repartitioning (\hyperlink{constant_8h_a21}{repartition\_\-BSFC.C} and \hyperlink{constant_8h_a21}{BSFC\_\-update\_\-and\_\-send\_\-elements.C}) \item\end{CompactList}\item 
int \hyperlink{classElement_a48}{get\_\-new\_\-old} ()
\begin{CompactList}\small\item\em this function returns the vlaue of the new\_\-old flag which is used during mesh adaptation and repartitioning \item\end{CompactList}\item 
void \hyperlink{classElement_a49}{update\_\-ndof} ()
\begin{CompactList}\small\item\em this function is legacy afeapi code, the function is defined in \hyperlink{constant_8h_a21}{element2.C} but it is never called anywhere in the finite difference/volume version of titan because it's finite element (including Discontinuous Galerkin) specific code \item\end{CompactList}\item 
void \hyperlink{classElement_a50}{change\_\-neighbor\_\-process} (int which, int newp)
\begin{CompactList}\small\item\em this function is called during repartitioning when one of an element's neighbors is sent to another processor \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a51}{get\_\-el\_\-err} ()
\begin{CompactList}\small\item\em the function returns the vector of element \char`\"{}error\char`\"{}, element error is used to say when a function should be refined \item\end{CompactList}\item 
void \hyperlink{classElement_a52}{get\_\-nelb\_\-icon} (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, int $\ast$, int $\ast$)
\begin{CompactList}\small\item\em this function is afeapi legacy it is not called anywhere in the finite difference/volume version of titan \item\end{CompactList}\item 
void \hyperlink{classElement_a53}{void\_\-bcptr} ()
\begin{CompactList}\small\item\em this function sets the pointer to an element's boundary conditions to NULL \item\end{CompactList}\item 
double \hyperlink{classElement_a54}{get\_\-lb\_\-weight} ()
\begin{CompactList}\small\item\em this function returns the Load Balancing weight of an element which is used in repartitioning \item\end{CompactList}\item 
void \hyperlink{classElement_a55}{put\_\-lb\_\-weight} (double dd\_\-in)
\begin{CompactList}\small\item\em this function stores an element's load balancing weight, which is used during repartitioning \item\end{CompactList}\item 
unsigned $\ast$ \hyperlink{classElement_a56}{get\_\-lb\_\-key} ()
\begin{CompactList}\small\item\em this function returns the load balancing key, which is used during repartitioning \item\end{CompactList}\item 
void \hyperlink{classElement_a57}{put\_\-lb\_\-key} (unsigned $\ast$in\_\-key)
\begin{CompactList}\small\item\em this function sets the load balancing key, which is used during repartitioning \item\end{CompactList}\item 
void \hyperlink{classElement_a58}{copy\_\-key\_\-to\_\-lb\_\-key} ()
\begin{CompactList}\small\item\em this function copies the elmenent key to the load balancing key \item\end{CompactList}\item 
void \hyperlink{classElement_a59}{put\_\-myprocess} (int in\_\-proc)
\begin{CompactList}\small\item\em this function sets the process(or) id of an element, it says which processor owns the element. \item\end{CompactList}\item 
int \hyperlink{classElement_a60}{get\_\-myprocess} ()
\begin{CompactList}\small\item\em this function returns the process(or) id of an element, it says which processor owns the element \item\end{CompactList}\item 
int \hyperlink{classElement_a61}{get\_\-opposite\_\-brother\_\-flag} ()
\begin{CompactList}\small\item\em this function returns the opposite\_\-brother\_\-flag, I (Keith) am not entirely sure what this flag is for, but I know that it is used in repartioning, see BSFC\_\-combine\_\-elements, I think it says if an element has an opposite brother, that is, can it be combined with it's brothers to form their father \item\end{CompactList}\item 
void \hyperlink{classElement_a62}{find\_\-opposite\_\-brother} (\hyperlink{classHashTable}{Hash\-Table} $\ast$)
\begin{CompactList}\small\item\em this function computes searches for an element's brother, i.e. the brother (son of the same father) that is located diagonally from it, to get the brother information requires that atleast one of this element's neighboring brothers is on this process in order to get information onthe brother that is not a neighbor \item\end{CompactList}\item 
void \hyperlink{classElement_a63}{put\_\-height\_\-mom} (double pile\_\-height, double xmom, double ymom)
\begin{CompactList}\small\item\em this function initializes pileheight, momentums and shortspeed (also known as the L'Hosptial speed see calc\_\-shortspeed for an explanation),this function is called in \hyperlink{constant_8h_a21}{init\_\-piles.C} \item\end{CompactList}\item 
void \hyperlink{classElement_a64}{put\_\-height} (double pile\_\-height)
\begin{CompactList}\small\item\em this function assigns a specified value to the pileheight and zeros to the momentums and shortspeed \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a65}{get\_\-state\_\-vars} ()
\begin{CompactList}\small\item\em this function returns the vector of state variables \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a66}{get\_\-d\_\-state\_\-vars} ()
\begin{CompactList}\small\item\em this function returns the vector of x and y derivatives of state variables, all the x derivatives come first as a group followed by the y derivatives as a group \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a67}{get\_\-zeta} ()
\begin{CompactList}\small\item\em this function returns the x and y slopes of the terrain elevation \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a68}{get\_\-dx} ()
\begin{CompactList}\small\item\em this function returns the length of an element in the x and y directions \item\end{CompactList}\item 
void \hyperlink{classElement_a69}{find\_\-positive\_\-x\_\-side} (\hyperlink{classHashTable}{Hash\-Table} $\ast$)
\begin{CompactList}\small\item\em this function computes which side of the element is facing the positive x direction \item\end{CompactList}\item 
int \hyperlink{classElement_a70}{get\_\-positive\_\-x\_\-side} ()
\begin{CompactList}\small\item\em this function returns which side of the element is facing the positive x direction \item\end{CompactList}\item 
void \hyperlink{classElement_a71}{get\_\-slopes} (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, double)
\begin{CompactList}\small\item\em this function computes the x and y derivatives of the state variables \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a72}{get\_\-prev\_\-state\_\-vars} ()
\begin{CompactList}\small\item\em this function returns a vector containing the previous state variables, previous mean beginning of timestep before the finite difference predictor halfstep \item\end{CompactList}\item 
void \hyperlink{classElement_a73}{calculate\_\-dx} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table)
\begin{CompactList}\small\item\em this function calculates the lengths of the element in the (global) x and y directions \item\end{CompactList}\item 
void \hyperlink{classElement_a74}{insert\_\-coord} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table)
\begin{CompactList}\small\item\em this function assigns the element's coordinates to be its bubble node's coordinates \item\end{CompactList}\item 
void \hyperlink{classElement_a75}{zdirflux} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, int order\_\-flag, int dir, double hfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}, double hrfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}, \hyperlink{classElement}{Element} $\ast$Em\-Neigh, double dt)
\begin{CompactList}\small\item\em this function, based on the dir flag, chooses between calling xdirflux and ydirflux, which respectively, calculate either the x or y direction analytical cell center fluxes (or the fluxes at the the boundary if 2nd order flux option is checked on the gui). Keith wrote this. \item\end{CompactList}\item 
void \hyperlink{classElement_a76}{xdirflux} (\hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, double dz, double thisside\-Swet, double hfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}, double hrfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]})
\begin{CompactList}\small\item\em this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) x direction fluxes. Keith wrote this \item\end{CompactList}\item 
void \hyperlink{classElement_a77}{ydirflux} (\hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, double dz, double thisside\-Swet, double hfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}, double hrfv\mbox{[}3\mbox{]}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]})
\begin{CompactList}\small\item\em this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) y direction fluxes. Keith wrote this \item\end{CompactList}\item 
void \hyperlink{classElement_a78}{calc\_\-edge\_\-states} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, int myid, double dt, int $\ast$order\_\-flag, double $\ast$outflow)
\begin{CompactList}\small\item\em this function (indirectly) calculates the fluxes that will be used to perform the finite volume corrector step and stores them in element edge nodes, indirectly because it calls other functions to calculate the analytical fluxes and then calls another function to compute the riemann fluxes from the analytical fluxes. Talk to me (Keith) before you modify this, as I am fairly certain that it is now completely bug free and parts of it can be slightly confusing. \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a79}{get\_\-eigenvxymax} ()
\begin{CompactList}\small\item\em this function calculates the maximum x and y direction wavespeeds which are the eigenvalues of the flux jacobian \item\end{CompactList}\item 
void \hyperlink{classElement_a80}{correct} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, double dt, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, \hyperlink{structFluxProps}{Flux\-Props} $\ast$fluxprops\_\-ptr, \hyperlink{structTimeProps}{Time\-Props} $\ast$timeprops\_\-ptr, double $\ast$forceint, double $\ast$forcebed, double $\ast$eroded, double $\ast$deposited)
\begin{CompactList}\small\item\em this function performs the corrector update, in the predictor (finite difference) corrector (finite volume) timestepping that titan uses. Actually this function passes values to a short fortran subroutine named \char`\"{}correct\_\-\char`\"{} that performs the calculations. The \char`\"{}correct\_\-\char`\"{} fortran subroutine should be torn out and the guts rewritten in C++ here. That may make it into this release if there is time, otherwise expect it in the next release \item\end{CompactList}\item 
void \hyperlink{classElement_a81}{calc\_\-shortspeed} (double inv\_\-dt)
\begin{CompactList}\small\item\em this function calculates the shortspeed,also known as the L'Hospital (pronounced Loo-pee-tal, you can look up L'Hospital's rule in almost any calculus book if you so desire). here is a brief explanation of shortspeed: shortspeed=$|$v$|$=$|$dhv/dh$|$=$|$v$\ast$dh/dh+h$\ast$dv/dh$|$=$|$v+h$\ast$dv/dh$|$ which goes to $|$v$|$ in the limit of h-$>$0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name \char`\"{}shortspeed\char`\"{} but it is not accurate when the pile is tall, that is when h$\ast$dv/dh is large, Keith implemented this in late summer 2006 \item\end{CompactList}\item 
double \hyperlink{classElement_a82}{get\_\-shortspeed} ()
\begin{CompactList}\small\item\em this function returns the already computed shortspeed \item\end{CompactList}\item 
void \hyperlink{classElement_a83}{put\_\-shortspeed} (double shortspeedin)
\begin{CompactList}\small\item\em this function assigns the value passed in to shortspeed \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a84}{eval\_\-velocity} (double xoffset, double yoffset, double Vx\-Vy\mbox{[}2\mbox{]})
\begin{CompactList}\small\item\em this function computes the velocity, either V=h\-V/h or shortspeed in the direction of h\-V/h, if the pile is short, that is h is less than the defined (nondimensional) value of GEOFLOW\_\-SHORT, see \hyperlink{geoflow_8h}{geoflow.h}, it chooses the speed to be min($|$h\-V/h$|$,shortspeed) if h is greater than GEOFLOW\_\-SHORT it chooses h\-V/h regardless of which one is smaller. \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a85}{get\_\-coef\-ABCD} ()
\begin{CompactList}\small\item\em this function is legacy afeapi code, it is never called in the finite difference/volume version of titan \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a86}{get\_\-kactxy} ()
\begin{CompactList}\small\item\em this function returns the already calculated value(s) of k active passive, which comes from using th Coulomb friction model of granular flows (this is problem specific to titan and thus does not appear in the standard afeapi code) \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a87}{get\_\-gravity} ()
\begin{CompactList}\small\item\em returns the already computed gravity vector in local coordinates, the local z direction is normal to the terrain surface and the projection of the local x and y components into the horizontal plane are aligned with global x (UTM E) and y (UTM N) directions. \item\end{CompactList}\item 
int \hyperlink{classElement_a88}{determine\_\-refinement} (double)
\begin{CompactList}\small\item\em this function is titan legacy code it is defined in \hyperlink{constant_8h_a21}{Element2.C} but is not called anywhere \item\end{CompactList}\item 
double \hyperlink{classElement_a89}{get\_\-elevation} ()
\begin{CompactList}\small\item\em this function returns the precomputed elevation \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a90}{get\_\-d\_\-gravity} ()
\begin{CompactList}\small\item\em this function returns the precomputed derivatives of the z component of gravity, this is a purely terrain geometry dependant derivative, that is little diffent than curvature \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a91}{get\_\-curvature} ()
\begin{CompactList}\small\item\em this function returns the precomputed local terrain curvature. Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. \item\end{CompactList}\item 
void \hyperlink{classElement_a92}{put\_\-lam} (double lam\_\-in)
\begin{CompactList}\small\item\em the only place this function is called is in \hyperlink{constant_8h_a21}{move\_\-data.C}, I believe it is legacy titan code and could probably be removed \item\end{CompactList}\item 
double \hyperlink{classElement_a93}{get\_\-lam} ()
\begin{CompactList}\small\item\em this function is never called in the finite difference/volume version of titan, it is legacy (I believe titan rather than afeapi legacy code) that probably should be removed \item\end{CompactList}\item 
void \hyperlink{classElement_a94}{calc\_\-flux\_\-balance} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table)
\begin{CompactList}\small\item\em this function is called in \hyperlink{constant_8h_a21}{element\_\-weight.C}, it is used in computing the load balancing weight \item\end{CompactList}\item 
void \hyperlink{classElement_a95}{calc\_\-topo\_\-data} (\hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr)
\begin{CompactList}\small\item\em this function calculates topographic data, it calls GIS commands to compute elevation, slopes, and curvatures from the GIS map and scales them appropriately \item\end{CompactList}\item 
void \hyperlink{classElement_a96}{calc\_\-d\_\-gravity} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table)
\begin{CompactList}\small\item\em this function calculates the (global) x and y derivatives of the local z component of gravity as an approximation of the local derivatives, it wouldn't be that difficult to correct incorporating the terrain slopes in the calculation it is calculated in the creation of a father element, after mesh refinement and, during a restart. \item\end{CompactList}\item 
void \hyperlink{classElement_a97}{calc\_\-gravity\_\-vector} (\hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr)
\begin{CompactList}\small\item\em this function calculates the gravity vector in local coordinates \item\end{CompactList}\item 
int \hyperlink{classElement_a98}{find\_\-brothers} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, double target, int myid, \hyperlink{structMatProps}{Mat\-Props} $\ast$matprops\_\-ptr, void $\ast$New\-Father\-List, void $\ast$Other\-Proc\-Update)
\begin{CompactList}\small\item\em this function is defined in \hyperlink{constant_8h_a21}{unrefine.C}, it is also called in that file, it finds this element's brothers \item\end{CompactList}\item 
int \hyperlink{classElement_a99}{check\_\-unrefinement} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, double target)
\begin{CompactList}\small\item\em this function is defined in \hyperlink{constant_8h_a21}{unrefine.C}, it is also called in that file and no where else, it prevents refinement when one or more of the brothers does not belong to this processor \item\end{CompactList}\item 
void \hyperlink{classElement_a100}{change\_\-neigh\_\-info} (unsigned $\ast$fth\_\-key, unsigned $\ast$ng\_\-key, int neworder, int ng\_\-gen, int fth\_\-proc)
\begin{CompactList}\small\item\em this function updates this elements neighbor info when one of its neighbors has been unrefined \item\end{CompactList}\item 
int $\ast$ \hyperlink{classElement_a101}{get\_\-elm\_\-loc} ()
\begin{CompactList}\small\item\em this function returns the elm\_\-loc variable, which is used in unrefinement beyond the initial coarse grid \item\end{CompactList}\item 
void \hyperlink{classElement_a102}{put\_\-elm\_\-loc} (int $\ast$int\_\-in)
\begin{CompactList}\small\item\em this function sets the elm\_\-loc variable, which is used in unrefinement beyond the initial coarse grid \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a103}{get\_\-coord} ()
\begin{CompactList}\small\item\em this function returns the precomputed and scaled coordinates of this element (which would be the same as its bubble node's coordinates) \item\end{CompactList}\item 
void \hyperlink{classElement_a104}{put\_\-coord} (double $\ast$coord\_\-in)
\begin{CompactList}\small\item\em this function stores the coordinates of this element (which would be the same as its bubble node's coordinates) \item\end{CompactList}\item 
void \hyperlink{classElement_a105}{calc\_\-stop\_\-crit} (\hyperlink{structMatProps}{Mat\-Props} $\ast$)
\begin{CompactList}\small\item\em this function is part of the experimental \_\-LOCAL\_\- (not Bin Yu's) stopping criteria which has not yet been validated, I (Keith) have faith in the criteria, but enforcing the stopped after it has been decided that it needs to stop still needs some work. the only place this function is called is in \hyperlink{constant_8h_a21}{get\_\-coef\_\-and\_\-eigen.C} immediately after k\_\-active/passive and in \hyperlink{constant_8h_a21}{init\_\-piles.C} when computing the initial volume that \char`\"{}should already be\char`\"{} deposited. \item\end{CompactList}\item 
void \hyperlink{classElement_a106}{put\_\-stoppedflags} (int stoppedflagsin)
\begin{CompactList}\small\item\em this function is used to assign a value to stopped flags, for when you don't want to compute the criteria to decide whether it's stopped or not, useful during developement \item\end{CompactList}\item 
int \hyperlink{classElement_a107}{get\_\-stoppedflags} ()
\begin{CompactList}\small\item\em this function returns the value of \char`\"{}stoppedflags\char`\"{} \item\end{CompactList}\item 
void \hyperlink{classElement_a108}{zero\_\-influx} ()
\begin{CompactList}\small\item\em this function zeros the extrusion (out of the ground) fluxes in this element \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a109}{get\_\-influx} ()
\begin{CompactList}\small\item\em this function returns the stored value of the extrusion (out of the ground) fluxes in this element \item\end{CompactList}\item 
void \hyperlink{classElement_a110}{calc\_\-flux} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, \hyperlink{structFluxProps}{Flux\-Props} $\ast$fluxprops, \hyperlink{structTimeProps}{Time\-Props} $\ast$timeprops)
\begin{CompactList}\small\item\em this function calculates the extrusion (out of the ground) fluxes for this elements \item\end{CompactList}\item 
int \hyperlink{classElement_a111}{if\_\-pile\_\-boundary} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Elem\-Table, double contour\_\-height)
\begin{CompactList}\small\item\em this function returns 2 if this element contains pileheight$>$=contour\_\-height and has a neighbor who contains pileheight$<$contour\_\-height. It returns 1 if this element contains pileheight$<$contour\_\-height and has a neighbor who contains pileheight$>$=contour\_\-height. It returns 0 otherwise. The intended use if if(Em\-Temp-$>$if\_\-pile\_\-boundary(Elem\-Table,contour\_\-height)) but I (Keith) added the distinction bewteen 1 and 2 to allow future developers to distinguish between the inside and outside of a pileheight contour line, as this functionality could be useful in the future. \item\end{CompactList}\item 
int \hyperlink{classElement_a112}{if\_\-source\_\-boundary} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Elem\-Table)
\begin{CompactList}\small\item\em this function returns 2 if this element has Influx\mbox{[}0\mbox{]}$>$0 and has a neighbor who has Influx\mbox{[}0\mbox{]}$<$=0. It returns 1 if this element has Influx\mbox{[}0\mbox{]}==0 and has a neighbor who has Influx\mbox{[}0\mbox{]}!=0. It returns -1 if this element has Influx\mbox{[}0\mbox{]}$<$0 and a neighbor with Influx\mbox{[}0\mbox{]}$>$=0. It returns 0 otherwise. Influx\mbox{[}0\mbox{]} is a pileheight per unit time source term. Currently Influx\mbox{[}0\mbox{]} is restricted to be non-negative (a source or no source with sinks not allowed), but I (Keith) have added the extra functionality because it may be useful at a future date. The intended use if if(Em\-Temp-$>$if\_\-source\_\-boundary(Elem\-Table)), but the distinction between 1 and 2 allows futuredevelopers to distinguish between the strictly inside and strictly outside of an area with a flux source term. \item\end{CompactList}\item 
int \hyperlink{classElement_a113}{if\_\-first\_\-buffer\_\-boundary} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Elem\-Table, double contour\_\-height)
\begin{CompactList}\small\item\em the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight$<$contour\_\-height)\&\&(Influx\mbox{[}0\mbox{]}==0)) and adjacent to the pile. It is \char`\"{}N\char`\"{} elements wide, and the \char`\"{}N\char`\"{} element width is increased one element at a time. This function returns 2 if this element a member of the innermost boundary of the buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be members of the innermost boundary of the buffer layer \item\end{CompactList}\item 
int \hyperlink{classElement_a114}{if\_\-next\_\-buffer\_\-boundary} (\hyperlink{classHashTable}{Hash\-Table} $\ast$Elem\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, double contour\_\-height)
\begin{CompactList}\small\item\em the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight$<$contour\_\-height)\&\&(Influx\mbox{[}0\mbox{]}==0)) and adjacent to the pile. It is \char`\"{}N\char`\"{} elements wide, and the \char`\"{}N\char`\"{} element width is increased one element at a time. This function returns 2 if this element a member of the boundary of the buffer that is one element wider than the current buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be in the next buffer boundary \item\end{CompactList}\item 
int \hyperlink{classElement_a115}{get\_\-counted} ()
\begin{CompactList}\small\item\em for debugging only \item\end{CompactList}\item 
void \hyperlink{classElement_a116}{put\_\-counted} (int countedvalue)
\begin{CompactList}\small\item\em for debugging only \item\end{CompactList}\item 
int \hyperlink{classElement_a117}{get\_\-ithelem} ()
\begin{CompactList}\small\item\em when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. \item\end{CompactList}\item 
void \hyperlink{classElement_a118}{put\_\-ithelem} (int i)
\begin{CompactList}\small\item\em when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. \item\end{CompactList}\item 
double \hyperlink{classElement_a119}{get\_\-effect\_\-bedfrict} ()
\begin{CompactList}\small\item\em one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a120}{get\_\-effect\_\-kactxy} ()
\begin{CompactList}\small\item\em one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect\_\-kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows \item\end{CompactList}\item 
double \hyperlink{classElement_a121}{get\_\-Awet} ()
\begin{CompactList}\small\item\em this inline member function returns the stored value of Awet, Awet is the fraction of an element's area that is wet (has material), 0.0$<$=Awet$<$=1.0, where there is no flow (pileheight $<$ GEOFLOW\_\-TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 \item\end{CompactList}\item 
void \hyperlink{classElement_a122}{put\_\-Awet} (double Awet\_\-in)
\begin{CompactList}\small\item\em this inline member function assigns a value to Awet, Awet is the fraction of an element's area that is wet (has material), 0.0$<$=Awet$<$=1.0, where there is no flow (pileheight $<$ GEOFLOW\_\-TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 \item\end{CompactList}\item 
double \hyperlink{classElement_a123}{get\_\-Swet} ()
\begin{CompactList}\small\item\em this inline member function returns the stored value of Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight $<$ GEOFLOW\_\-TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0$<$=Swet$<$=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is called in \hyperlink{constant_8h_a21}{step.C}. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 \item\end{CompactList}\item 
void \hyperlink{classElement_a124}{put\_\-Swet} (double Swet\_\-in)
\begin{CompactList}\small\item\em this inline member function assigns a value to Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight $<$ GEOFLOW\_\-TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0$<$=Swet$<$=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is called in \hyperlink{constant_8h_a21}{step.C}. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 \item\end{CompactList}\item 
int \hyperlink{classElement_a125}{get\_\-iwetnode} ()
\begin{CompactList}\small\item\em this inline member function returns the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its \char`\"{}wettest\char`\"{} node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight $<$ GEOFLOW\_\-TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 \item\end{CompactList}\item 
void \hyperlink{classElement_a126}{put\_\-iwetnode} (int iwetnode\_\-in)
\begin{CompactList}\small\item\em this inline member function sets the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its \char`\"{}wettest\char`\"{} node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight $<$ GEOFLOW\_\-TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 \item\end{CompactList}\item 
double $\ast$ \hyperlink{classElement_a127}{get\_\-drypoint} ()
\begin{CompactList}\small\item\em this inline member function returns the array \char`\"{}drypoint\char`\"{}. drypoint\mbox{[}0\mbox{]} is the local x-coordinate, and drypoint\mbox{[}1\mbox{]} the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 \item\end{CompactList}\item 
void \hyperlink{classElement_a128}{put\_\-drypoint} (double $\ast$drypoint\_\-in)
\begin{CompactList}\small\item\em this inline member function sets the values of the array \char`\"{}drypoint\char`\"{}. drypoint\mbox{[}0\mbox{]} is the local x-coordinate, and drypoint\mbox{[}1\mbox{]} the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 \item\end{CompactList}\item 
void \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table)
\begin{CompactList}\small\item\em the element member function \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} determines the orientation of the dryline and which side of it is wet, the wet fraction (Swet) of a partially wet edge, the location of the drypoint, it does NOT calculate the wet area (Awet)... these quantities are used in the adjustment of fluxes in partially wet elements. \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is not coded for generic element orientation, i.e. the positive\_\-x\_\-side must be side 1. Keith wrote this may 2007 \item\end{CompactList}\item 
double \hyperlink{classElement_a130}{calc\_\-elem\_\-edge\_\-wet\_\-fraction} (int ineigh, int ifusewholeside)
\begin{CompactList}\small\item\em The Element member function \hyperlink{classElement_a130}{calc\_\-elem\_\-edge\_\-wet\_\-fraction()} returns the \char`\"{}how much of this is wet\char`\"{} fraction of side that this element shares with its ineigh-th neighboring element . This fraction is used to determine wether or not to \char`\"{}zero\char`\"{} the state variables used to compute physical fluxes through a \char`\"{}dry\char`\"{} side. Keith wrote this function may 2007. \item\end{CompactList}\item 
double \hyperlink{classElement_a131}{calc\_\-elem\_\-edge\_\-wetness\_\-factor} (int ineigh, double dt)
\begin{CompactList}\small\item\em this function relaxes the zeroing of fluxes through cell edges that are completely dry at the beginning of the timestep, as indicated by \hyperlink{classElement_a130}{calc\_\-elem\_\-edge\_\-wet\_\-fraction()}, but will be at least partly wet by the end of the timestep... Keith wrote this function June 2007 \item\end{CompactList}\item 
double \hyperlink{classElement_a132}{convect\_\-dryline} (double Vx\-Vy\mbox{[}2\mbox{]}, double dt)
\begin{CompactList}\small\item\em The Element member function \hyperlink{classElement_a132}{convect\_\-dryline()} calculates the coordinates of the \char`\"{}drypoint\char`\"{} in the element's local coordinate system. This is used to determine the location of the wet-dry front (or dryline) inside this element, which in turn is used (in conjunction with the location of \char`\"{}iwetnode\char`\"{} - which indicates which side of the dryline is wet) to determine the fraction of its total area that is wet (Awet). Awet is then returned by the function. Keith wrote this function may 2007. \item\end{CompactList}\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
int \hyperlink{classElement_r0}{myprocess}
\begin{CompactList}\small\item\em myprocess is id of the process(or) that owns this element \item\end{CompactList}\item 
int \hyperlink{classElement_r1}{generation}
\begin{CompactList}\small\item\em generation is how many times this element has been refined, currently -8$<$=generation$<$=3, a negative generation number means it has been unrefined beyond the orignal coarse mesh, a positive generation number means it has been refined (is smaller than the original element size) \item\end{CompactList}\item 
int \hyperlink{classElement_r2}{opposite\_\-brother\_\-flag}
\begin{CompactList}\small\item\em opposite\_\-brother\_\-flag indicate if we have the correct key for the non-neighbor brother (0:= don't have info, 1:= have info) \item\end{CompactList}\item 
int \hyperlink{classElement_r3}{material}
\begin{CompactList}\small\item\em the material flag indicates which material should be used to set this element's bed friction, this is for when a GIS material map, specifying different materials in different spatial regions of the map, the GIS material map is a non standard grass map format that Laercio Namikawa developed, it's stored in the \char`\"{}cats\char`\"{} folder under a grass mapset directory \item\end{CompactList}\item 
double \hyperlink{classElement_r4}{lb\_\-weight}
\begin{CompactList}\small\item\em this is the load-balancing weight \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r5}{lb\_\-key} \mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this is the key for load-balancing, if there is no constrained node, it is the element key, otherwise it is a construct of the element \char`\"{}bunch\char`\"{}, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r6}{key} \mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this is the element key, which has the same value as the key of the element's bubble node, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r7}{node\_\-key} \mbox{[}8\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this array holds the first 8 (0-$>$7) of this element's nodes' keys, the n9th (8 out of 0-$>$8) node is the bubble node it's key is not stored separately since it has the same key as the element, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r8}{neighbor} \mbox{[}8\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this array holds the keys of this element's 8 neighbors (2 neigbors to a side if the neighbor is more refined than this element, otherwise the two neighbor keys for that side are identical in value), having 8 neighbors is an outcome of the 1 irregularity refinement rule, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r9}{father} \mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em the key of the father it is assigned in the \hyperlink{hadpt_8C_a5}{refine()} and unrefine\_\-elements() functions \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r10}{son} \mbox{[}4\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this array holds the keys of this element's 4 sons, it is only used temporarily in the refinement process before the father (this element) is deleted, there's was an old comment \char`\"{}garantee ccw\char`\"{} associated with this variable, I don't know what it means, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
int \hyperlink{classElement_r11}{neigh\_\-proc} \mbox{[}8\mbox{]}
\begin{CompactList}\small\item\em this array holds the process(or) id of this element's 8 neighbors, there can be 8 neighbors because of the 1 irregularity rule. neigh\_\-proc\mbox{[}4:7\mbox{]} != -2 only if it has 2 neighbors on that side, a value of -1 for neigh\_\-proc means that this edge is a boundary of the computational domain. \item\end{CompactList}\item 
int \hyperlink{classElement_r12}{order} \mbox{[}5\mbox{]}
\begin{CompactList}\small\item\em this is legacy afeapi, all finite volume \char`\"{}elements\char`\"{}/cells are piece wise constant, but I believe this is actually used in the DG (Discontinuous Galerkin) version of titan \item\end{CompactList}\item 
int \hyperlink{classElement_r13}{neigh\_\-gen} \mbox{[}8\mbox{]}
\begin{CompactList}\small\item\em neigh\_\-gen is an array that holds the \char`\"{}generation\char`\"{} (how refined it is) of this element's 8 neighbors, there can-be/are 2 neighbors to a side because of the 1 irregularity rule \item\end{CompactList}\item 
\hyperlink{structBC}{BC} $\ast$ \hyperlink{classElement_r14}{bcptr}
\begin{CompactList}\small\item\em pointer to the boundary condition class, if this element is not a boundary element the pointer holds the NULL value \item\end{CompactList}\item 
int \hyperlink{classElement_r15}{ndof}
\begin{CompactList}\small\item\em the number of degrees of freedom, since Titan is a finite difference/volume code, ndof is afeapi legacy, but the DG (Discontinuous Galerkin) version of Titan actually uses this \item\end{CompactList}\item 
int \hyperlink{classElement_r16}{no\_\-of\_\-eqns}
\begin{CompactList}\small\item\em this is legacy afeapi, it is not used, but do not remove it, it could cause problems if you do \item\end{CompactList}\item 
double \hyperlink{classElement_r17}{el\_\-error} \mbox{[}\hyperlink{constant_8h_a16}{EQUATIONS}\mbox{]}
\begin{CompactList}\small\item\em this holds the \char`\"{}error\char`\"{} in the element's solution, which is useful in determining refinement, this may actually be afeapi legacy \item\end{CompactList}\item 
double \hyperlink{classElement_r18}{el\_\-solution} \mbox{[}\hyperlink{constant_8h_a16}{EQUATIONS}\mbox{]}
\begin{CompactList}\small\item\em this holds the element solution, I believe this is legacy afeapi \item\end{CompactList}\item 
int \hyperlink{classElement_r19}{refined}
\begin{CompactList}\small\item\em refined is a flag that usually has the value 0, but will be 1 if the element has been refined this iteration (used to enforce the 1 irregularity rule), or have the value \char`\"{}GHOST\char`\"{} if it is a ghost cell, refined and ghost cells are not updated, see \hyperlink{constant_8h}{constant.h} for the value of GHOST \item\end{CompactList}\item 
int \hyperlink{classElement_r20}{adapted}
\begin{CompactList}\small\item\em The magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()} and \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} with adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()} and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within \hyperlink{hadpt_8C_a12}{H\_\-adapt()}, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. \item\end{CompactList}\item 
int \hyperlink{classElement_r21}{which\_\-son}
\begin{CompactList}\small\item\em which\_\-son holds the value of which son this element is, which of the 4 squares that makes up the father elements square. \item\end{CompactList}\item 
int \hyperlink{classElement_r22}{new\_\-old}
\begin{CompactList}\small\item\em the new\_\-old flag is used in mesh adaptation and repartitioning \item\end{CompactList}\item 
unsigned \hyperlink{classElement_r23}{brothers} \mbox{[}4\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}
\begin{CompactList}\small\item\em this array holds the keys of this element's 4 brothers (an element is considered to be it's own brother), this information is used during mesh unrefinement (combining the 4 brothers to make their father), keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables \item\end{CompactList}\item 
double \hyperlink{classElement_r24}{coord} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em coord holds the coordinates of the elements cell center, these are the same as the coordinates of the element's bubble node's \item\end{CompactList}\item 
int \hyperlink{classElement_r25}{elm\_\-loc} \mbox{[}2\mbox{]}
\begin{CompactList}\small\item\em elm\_\-loc is used in unrefining beyond the original coarse mesh \item\end{CompactList}\item 
int \hyperlink{classElement_r26}{send} \mbox{[}8\mbox{]}
\begin{CompactList}\small\item\em this is afeapi legacy \item\end{CompactList}\item 
int \hyperlink{classElement_r27}{recv} \mbox{[}8\mbox{]}
\begin{CompactList}\small\item\em this is afeapi legacy \item\end{CompactList}\item 
double \hyperlink{classElement_r28}{state\_\-vars} \mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}
\begin{CompactList}\small\item\em state\_\-vars is an array that holds the current state variables: h, h\-Vx, and h\-Vy \item\end{CompactList}\item 
double \hyperlink{classElement_r29}{prev\_\-state\_\-vars} \mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}
\begin{CompactList}\small\item\em these are the values of the state variables from before the predictor step \item\end{CompactList}\item 
double \hyperlink{classElement_r30}{d\_\-state\_\-vars} \mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS} $\ast$\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em these are the spatial (x and y) derivatives of the state variables: (dh/dx, dh\-Vx/dx, dh\-Vy/dx, dh/dy, dh\-Vx/dy, dh\-Vy/dy) \item\end{CompactList}\item 
double \hyperlink{classElement_r31}{shortspeed}
\begin{CompactList}\small\item\em the short speed is the speed computed as: shortspeed=$|$v$|$=$|$dhv/dh$|$=$|$v$\ast$dh/dh+h$\ast$dv/dh$|$=$|$v+h$\ast$dv/dh$|$ which goes to $|$v$|$ in the limit of h-$>$0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name \char`\"{}shortspeed\char`\"{} but it is not accurate when the pile is tall, that is when h$\ast$dv/dh is large, this is the value from the previous iteration (so there is lagging when using the shortspeed, but this should still be much more accurate than h\-V/h when h-$>$0. Keith implemented this in late summer 2006, \item\end{CompactList}\item 
double \hyperlink{classElement_r32}{dx} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em length of the element in the global x and y directions: dx and dy \item\end{CompactList}\item 
int \hyperlink{classElement_r33}{positive\_\-x\_\-side}
\begin{CompactList}\small\item\em for structured grid, tells which side is the positive x direction \item\end{CompactList}\item 
double \hyperlink{classElement_r34}{eigenvxymax} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em maximum x and y direction wavespeeds for this element, wavespeeds are eigenvalues of the flux jacobians \item\end{CompactList}\item 
double \hyperlink{classElement_r35}{coef\-ABCD} \mbox{[}4\mbox{]}
\begin{CompactList}\small\item\em this is legacy afeapi not used in titan \item\end{CompactList}\item 
double \hyperlink{classElement_r36}{kactxy} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em k active/passive in the x and y directions, k active/passive is part of the coulomb friction model for Granular Flows \item\end{CompactList}\item 
double \hyperlink{classElement_r37}{elevation}
\begin{CompactList}\small\item\em terrain elevation at this elements center/bubble node \item\end{CompactList}\item 
double \hyperlink{classElement_r38}{zeta} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em terrain slope in the global x and y directions \item\end{CompactList}\item 
double \hyperlink{classElement_r39}{curvature} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. \item\end{CompactList}\item 
double \hyperlink{classElement_r40}{gravity} \mbox{[}3\mbox{]}
\begin{CompactList}\small\item\em the gravity vector in local x,y,z coordinates (z is normal to the terrain surface, the projections of the x and y local directions onto a horizontal plane are aligned with the global x and y directions) \item\end{CompactList}\item 
double \hyperlink{classElement_r41}{d\_\-gravity} \mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}
\begin{CompactList}\small\item\em the spatial (x and y) derivatives of the local z component of the gravity vector \item\end{CompactList}\item 
double \hyperlink{classElement_r42}{lam}
\begin{CompactList}\small\item\em legacy titan not really used, lam :=p\_\-\{bed\}/(rho$\ast$g\_\-z$\ast$h) \item\end{CompactList}\item 
int \hyperlink{classElement_r43}{stoppedflags}
\begin{CompactList}\small\item\em part of the new stopping criteria under development, has a 0 if flow is not stopped, has the value 1 if it should not be sliding but should be slumping, has the value 2 if it should neither be sliding or slumping (it should be completely stopped), I (Keith) am rather confident in the criteria used to set this the problem is determining what to do about it after you know the flow SHOULD be stopped \item\end{CompactList}\item 
double \hyperlink{classElement_r44}{effect\_\-bedfrict}
\begin{CompactList}\small\item\em one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped \item\end{CompactList}\item 
double \hyperlink{classElement_r45}{effect\_\-tanbedfrict}
\begin{CompactList}\small\item\em one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus effect\_\-tanbedfrict holds the value of the effective bed friction angle \item\end{CompactList}\item 
double \hyperlink{classElement_r46}{effect\_\-kactxy} \mbox{[}2\mbox{]}
\begin{CompactList}\small\item\em one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect\_\-kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows \item\end{CompactList}\item 
double \hyperlink{classElement_r47}{Influx} \mbox{[}3\mbox{]}
\begin{CompactList}\small\item\em extrusion flux rate for this timestep for this element, used when having material flow out of the ground, a volume per unit area influx rate source term \item\end{CompactList}\item 
int \hyperlink{classElement_r48}{counted}
\item 
int \hyperlink{classElement_r49}{ithelem}
\begin{CompactList}\small\item\em when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. \item\end{CompactList}\item 
int \hyperlink{classElement_r50}{iwetnode}
\begin{CompactList}\small\item\em the node number \{0,1,..,7\} of this element's \char`\"{}most wet node\char`\"{}, this dictates both the orientation of the \char`\"{}dryline\char`\"{} and which side of it is wet. The \char`\"{}dryline\char`\"{} is the line that divides a partially wetted element into a dry part and a wet part, for the sake of simplicity only 4 orientations are allowed, horizontal, vertical, parallel to either diagonal of the element. If the iwetnode is an edge node of this element then the dryline is parallel to the edge the element is on, if the iwetnode is a corner node of this element then dryline is parallel to the diagonal of the element that the iwetnode is not on. Which side of the dryline is wet is the same side in which the iwetnode resides (and is determined each timestep based soley on which of the elements neighbors currently have pile height greater than GEOFLOW\_\-TINY)... as such iwetnode can be thought of as the MOST WET NODE of the element. Having iwetnode==8 indicates that the element is uniformly wet if this element's pile height is greater than GEOFLOW\_\-TINY or is uniformly dry if pileheight is less than or equal to GEOFLOW\_\-TINY. \item\end{CompactList}\item 
double \hyperlink{classElement_r51}{Awet}
\begin{CompactList}\small\item\em Awet is the ratio of this element's wet area to total area (always between 0 and 1 inclusive) when taken together with iwetnode, this uniquely determines the exact placement of the \char`\"{}dryline\char`\"{} within the current element. Awet is initially set by source placement to be either 0 (no material) or 1 (material) and is updated by the corrector part of the predictor-corrector method, the new value is determined by where the dry line has been convected to over this timestep. Keith wrote this May 2007. \item\end{CompactList}\item 
double \hyperlink{classElement_r52}{drypoint} \mbox{[}2\mbox{]}
\begin{CompactList}\small\item\em center point of the \char`\"{}dryline\char`\"{}, x and y coordinates value ranges between -0.5 and 0.5 with 0 being the center of the element, since the wet/dry interface is taken to be a non-deforming non rotating (within the timestep) \char`\"{}dryline\char`\"{} convecting a single point on the dryline (called the drypoint) is sufficient to determine the new placement of the dryline which allows us to update Awet... Keith wrote this May 2007. \item\end{CompactList}\item 
double \hyperlink{classElement_r53}{Swet}
\begin{CompactList}\small\item\em when an element edge is partially wet and partially dry... Swet is the fraction of a cell edge that is partially wet, because it can only be horizontal, vertical, or parallel to either diagonal, all of one element's partially wet sides are have the same fraction of wetness. The state variables (used to compute the physical fluxes) at the element/cell edge are adjusted to be the weighted by wetness average over an element/cell edge. As such physical fluxes through completely dry edges of partially wet elements/cells are zeroed, while physical fluxes through completely wet edges are left unchanged. Because of the definition as \char`\"{}wetness weighted average\char`\"{} physical fluxes through a partially wet edge shared with a neighbor of the same generation is also left left unchanged but, when a partially wet edge is shared with two more refined neighbors the total mass and momentum at the edge is split between the two neighbors in proportion to how much of their boundary shared with this element is wet. This \char`\"{}scaling\char`\"{} of the physical fluxes is the \char`\"{}adjustment of fluxes in partially wetted cells\char`\"{} facet of our multifaceted thin-layer problem mitigation approach. And it has been shown to significantly reduce the area covered by a thin layer of material. Keith wrote this May 2007. \item\end{CompactList}\end{CompactItemize}
\subsection*{Friends}
\begin{CompactItemize}
\item 
class \hyperlink{classElement_n0}{Hash\-Table}
\item 
void \hyperlink{classElement_n1}{Assert\-Mesh\-Error\-Free} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int numprocs, int myid, double loc)
\begin{CompactList}\small\item\em this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG. \item\end{CompactList}\item 
void \hyperlink{classElement_n2}{Elem\-Background\-Check} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, unsigned $\ast$debugkey, FILE $\ast$fp)
\begin{CompactList}\small\item\em investigate an Element, question his \char`\"{}friends and family\char`\"{} about him. \item\end{CompactList}\item 
void \hyperlink{classElement_n3}{Elem\-Background\-Check2} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, void $\ast$Em\-Debug, FILE $\ast$fp)
\item 
void \hyperlink{classElement_n4}{Node\-Background\-Check} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, unsigned $\ast$debugkey, FILE $\ast$fp)
\begin{CompactList}\small\item\em investigate a \hyperlink{classNode}{Node} question his \char`\"{}friends and family\char`\"{} about him. \item\end{CompactList}\item 
void \hyperlink{classElement_n5}{delete\_\-oldsons} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int myid, void $\ast$Em\-Father)
\item 
void \hyperlink{classElement_n6}{refine\_\-neigh\_\-update} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int numprocs, int myid, void $\ast$Refined\-List, \hyperlink{structTimeProps}{Time\-Props} $\ast$timeprops\_\-ptr)
\item 
void \hyperlink{classElement_n7}{unrefine\_\-neigh\_\-update} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int myid, void $\ast$New\-Father\-List)
\item 
void \hyperlink{classElement_n8}{unrefine\_\-interp\_\-neigh\_\-update} (\hyperlink{classHashTable}{Hash\-Table} $\ast$El\_\-Table, \hyperlink{classHashTable}{Hash\-Table} $\ast$Node\-Table, int nump, int myid, void $\ast$Other\-Proc\-Update)
\item 
void \hyperlink{classElement_n9}{BSFC\_\-combine\_\-elements} (int side, \hyperlink{classElement}{Element} $\ast$Em\-Temp, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Elem\_\-Ptr, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Node\_\-Ptr, int destination\_\-proc)
\begin{CompactList}\small\item\em this function figures out how to \char`\"{}bunch\char`\"{} together elements that cannot be put on different processors because of a constrained node, B stands for bunch SFC stands for space filling curve \item\end{CompactList}\item 
void \hyperlink{classElement_n10}{Pack\_\-element} (void $\ast$sendel, \hyperlink{structElemPack}{Elem\-Pack} $\ast$elem, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Node\_\-Ptr, int destination\_\-proc)
\begin{CompactList}\small\item\em \hyperlink{classElement_n10}{Pack\_\-element()} is a friend function of the Element and \hyperlink{classNode}{Node} classes that packs relevant information from an element \char`\"{}sendel\char`\"{} into a smaller data structure (\hyperlink{structElemPack}{Elem\-Pack}) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning. \item\end{CompactList}\item 
void \hyperlink{classElement_n11}{destroy\_\-element} (void $\ast$r\_\-element, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Elem\_\-Ptr, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Node\_\-Ptr, int target\_\-pro, \hyperlink{structElementLink}{ELink\-Ptr} $\ast$EL\_\-head)
\item 
void \hyperlink{classElement_n12}{create\_\-element} (\hyperlink{structElemPack}{Elem\-Pack} $\ast$elem2, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Elem\_\-Ptr, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Node\_\-Ptr, int myid, double $\ast$e\_\-error)
\begin{CompactList}\small\item\em \hyperlink{classElement_n12}{create\_\-element()} is a friend function of the Element and \hyperlink{classNode}{Node} classes. After receiving an \hyperlink{structElemPack}{Elem\-Pack}, \hyperlink{classElement_n12}{create\_\-element()} instances a new element, calls \hyperlink{classElement_n13}{construct\_\-el()} to transfer data from \hyperlink{structElemPack}{Elem\-Pack} to the new element, and inserts the new element into the Hashtable. Don't call this if s\_\-flag is 0 (original repartitioning scheme) \item\end{CompactList}\item 
void \hyperlink{classElement_n13}{construct\_\-el} (\hyperlink{classElement}{Element} $\ast$newelement, \hyperlink{structElemPack}{Elem\-Pack} $\ast$elem2, \hyperlink{classHashTable}{Hash\-Table} $\ast$HT\_\-Node\_\-Ptr, int myid, double $\ast$e\_\-error)
\begin{CompactList}\small\item\em construct\_\-el is a friend function of the Element class that fills an element with information it receives in a variable of the \hyperlink{structElemPack}{Elem\-Pack} class from an MPI call \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
The Element class is a data structure designed to hold all the information need for an h (cell edge length) p (polynomial order) adaptive finite element. Titan doesn't use p adaptation because it is a finite difference/volume code, hence many of the members are legacy from afeapi (adaptive finite element application programmers interface) which serves as the core of titan. There is a seperate Discontinuous Galerkin Method (finite elements + finite volumes) version of titan and the polynomial information is not legacy there. However in this version of Titan elements function simply as finite volume cells. 



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classElement_a0}{
\index{Element@{Element}!Element@{Element}}
\index{Element@{Element}!Element@{Element}}
\subsubsection[Element]{\setlength{\rightskip}{0pt plus 5cm}Element::Element ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a0}


default constructor, does nothing except set stoppedflags=2, this should never be used 

\hypertarget{classElement_a1}{
\index{Element@{Element}!Element@{Element}}
\index{Element@{Element}!Element@{Element}}
\subsubsection[Element]{\setlength{\rightskip}{0pt plus 5cm}Element::Element (unsigned {\em nodekeys}\mbox{[}$\,$\mbox{]}\mbox{[}KEYLENGTH\mbox{]}, unsigned {\em neigh}\mbox{[}$\,$\mbox{]}\mbox{[}KEYLENGTH\mbox{]}, int {\em n\_\-pro}\mbox{[}$\,$\mbox{]}, \hyperlink{structBC}{BC} $\ast$ {\em b}, int {\em mat}, int $\ast$ {\em elm\_\-loc\_\-in}, double {\em pile\_\-height}, int {\em myid}, unsigned $\ast$ {\em opposite\_\-brother})}}
\label{classElement_a1}


constructor that creates an original element when funky is read in 

\hypertarget{classElement_a2}{
\index{Element@{Element}!Element@{Element}}
\index{Element@{Element}!Element@{Element}}
\subsubsection[Element]{\setlength{\rightskip}{0pt plus 5cm}Element::Element (unsigned {\em nodekeys}\mbox{[}$\,$\mbox{]}\mbox{[}KEYLENGTH\mbox{]}, unsigned {\em neigh}\mbox{[}$\,$\mbox{]}\mbox{[}KEYLENGTH\mbox{]}, int {\em n\_\-pro}\mbox{[}$\,$\mbox{]}, \hyperlink{structBC}{BC} $\ast$ {\em b}, int {\em gen}, int {\em elm\_\-loc\_\-in}\mbox{[}$\,$\mbox{]}, int $\ast$ {\em ord}, int {\em gen\_\-neigh}\mbox{[}$\,$\mbox{]}, int {\em mat}, \hyperlink{classElement}{Element} $\ast$ {\em fth\-Temp}, double $\ast$ {\em coord\_\-in}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em myid}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, int {\em iwetnodefather}, double {\em Awetfather}, double $\ast$ {\em drypoint\_\-in})}}
\label{classElement_a2}


constructor that creates a son element from its father during refinement 

\hypertarget{classElement_a3}{
\index{Element@{Element}!Element@{Element}}
\index{Element@{Element}!Element@{Element}}
\subsubsection[Element]{\setlength{\rightskip}{0pt plus 5cm}Element::Element (\hyperlink{classElement}{Element} $\ast$ {\em sons}\mbox{[}$\,$\mbox{]}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr})}}
\label{classElement_a3}


constructor that creates a father element from its four sons during unrefinement 

\hypertarget{classElement_a4}{
\index{Element@{Element}!Element@{Element}}
\index{Element@{Element}!Element@{Element}}
\subsubsection[Element]{\setlength{\rightskip}{0pt plus 5cm}Element::Element (FILE $\ast$ {\em fp}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, int {\em myid})}}
\label{classElement_a4}


constructor that creates/restores a saved element during restart 

\hypertarget{classElement_a5}{
\index{Element@{Element}!~Element@{$\sim$Element}}
\index{~Element@{$\sim$Element}!Element@{Element}}
\subsubsection[$\sim$Element]{\setlength{\rightskip}{0pt plus 5cm}Element::$\sim$\hyperlink{classElement}{Element} ()}}
\label{classElement_a5}


destructor that does nothing except delete boundary condition pointer 



\subsection{Member Function Documentation}
\hypertarget{classElement_a96}{
\index{Element@{Element}!calc_d_gravity@{calc\_\-d\_\-gravity}}
\index{calc_d_gravity@{calc\_\-d\_\-gravity}!Element@{Element}}
\subsubsection[calc\_\-d\_\-gravity]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-d\_\-gravity (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table})}}
\label{classElement_a96}


this function calculates the (global) x and y derivatives of the local z component of gravity as an approximation of the local derivatives, it wouldn't be that difficult to correct incorporating the terrain slopes in the calculation it is calculated in the creation of a father element, after mesh refinement and, during a restart. 

\hypertarget{classElement_a78}{
\index{Element@{Element}!calc_edge_states@{calc\_\-edge\_\-states}}
\index{calc_edge_states@{calc\_\-edge\_\-states}!Element@{Element}}
\subsubsection[calc\_\-edge\_\-states]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-edge\_\-states (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, int {\em myid}, double {\em dt}, int $\ast$ {\em order\_\-flag}, double $\ast$ {\em outflow})}}
\label{classElement_a78}


this function (indirectly) calculates the fluxes that will be used to perform the finite volume corrector step and stores them in element edge nodes, indirectly because it calls other functions to calculate the analytical fluxes and then calls another function to compute the riemann fluxes from the analytical fluxes. Talk to me (Keith) before you modify this, as I am fairly certain that it is now completely bug free and parts of it can be slightly confusing. 

\hypertarget{classElement_a130}{
\index{Element@{Element}!calc_elem_edge_wet_fraction@{calc\_\-elem\_\-edge\_\-wet\_\-fraction}}
\index{calc_elem_edge_wet_fraction@{calc\_\-elem\_\-edge\_\-wet\_\-fraction}!Element@{Element}}
\subsubsection[calc\_\-elem\_\-edge\_\-wet\_\-fraction]{\setlength{\rightskip}{0pt plus 5cm}double Element::calc\_\-elem\_\-edge\_\-wet\_\-fraction (int {\em ineigh}, int {\em ifusewholeside})}}
\label{classElement_a130}


The Element member function \hyperlink{classElement_a130}{calc\_\-elem\_\-edge\_\-wet\_\-fraction()} returns the \char`\"{}how much of this is wet\char`\"{} fraction of side that this element shares with its ineigh-th neighboring element . This fraction is used to determine wether or not to \char`\"{}zero\char`\"{} the state variables used to compute physical fluxes through a \char`\"{}dry\char`\"{} side. Keith wrote this function may 2007. 

\hypertarget{classElement_a131}{
\index{Element@{Element}!calc_elem_edge_wetness_factor@{calc\_\-elem\_\-edge\_\-wetness\_\-factor}}
\index{calc_elem_edge_wetness_factor@{calc\_\-elem\_\-edge\_\-wetness\_\-factor}!Element@{Element}}
\subsubsection[calc\_\-elem\_\-edge\_\-wetness\_\-factor]{\setlength{\rightskip}{0pt plus 5cm}double Element::calc\_\-elem\_\-edge\_\-wetness\_\-factor (int {\em ineigh}, double {\em dt})}}
\label{classElement_a131}


this function relaxes the zeroing of fluxes through cell edges that are completely dry at the beginning of the timestep, as indicated by \hyperlink{classElement_a130}{calc\_\-elem\_\-edge\_\-wet\_\-fraction()}, but will be at least partly wet by the end of the timestep... Keith wrote this function June 2007 

\hypertarget{classElement_a110}{
\index{Element@{Element}!calc_flux@{calc\_\-flux}}
\index{calc_flux@{calc\_\-flux}!Element@{Element}}
\subsubsection[calc\_\-flux]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-flux (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{structFluxProps}{Flux\-Props} $\ast$ {\em fluxprops}, \hyperlink{structTimeProps}{Time\-Props} $\ast$ {\em timeprops})}}
\label{classElement_a110}


this function calculates the extrusion (out of the ground) fluxes for this elements 

\hypertarget{classElement_a94}{
\index{Element@{Element}!calc_flux_balance@{calc\_\-flux\_\-balance}}
\index{calc_flux_balance@{calc\_\-flux\_\-balance}!Element@{Element}}
\subsubsection[calc\_\-flux\_\-balance]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-flux\_\-balance (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table})}}
\label{classElement_a94}


this function is called in \hyperlink{constant_8h_a21}{element\_\-weight.C}, it is used in computing the load balancing weight 

\hypertarget{classElement_a97}{
\index{Element@{Element}!calc_gravity_vector@{calc\_\-gravity\_\-vector}}
\index{calc_gravity_vector@{calc\_\-gravity\_\-vector}!Element@{Element}}
\subsubsection[calc\_\-gravity\_\-vector]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-gravity\_\-vector (\hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr})}}
\label{classElement_a97}


this function calculates the gravity vector in local coordinates 

\hypertarget{classElement_a81}{
\index{Element@{Element}!calc_shortspeed@{calc\_\-shortspeed}}
\index{calc_shortspeed@{calc\_\-shortspeed}!Element@{Element}}
\subsubsection[calc\_\-shortspeed]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-shortspeed (double {\em inv\_\-dt})}}
\label{classElement_a81}


this function calculates the shortspeed,also known as the L'Hospital (pronounced Loo-pee-tal, you can look up L'Hospital's rule in almost any calculus book if you so desire). here is a brief explanation of shortspeed: shortspeed=$|$v$|$=$|$dhv/dh$|$=$|$v$\ast$dh/dh+h$\ast$dv/dh$|$=$|$v+h$\ast$dv/dh$|$ which goes to $|$v$|$ in the limit of h-$>$0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name \char`\"{}shortspeed\char`\"{} but it is not accurate when the pile is tall, that is when h$\ast$dv/dh is large, Keith implemented this in late summer 2006 

\hypertarget{classElement_a105}{
\index{Element@{Element}!calc_stop_crit@{calc\_\-stop\_\-crit}}
\index{calc_stop_crit@{calc\_\-stop\_\-crit}!Element@{Element}}
\subsubsection[calc\_\-stop\_\-crit]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-stop\_\-crit (\hyperlink{structMatProps}{Mat\-Props} $\ast$)}}
\label{classElement_a105}


this function is part of the experimental \_\-LOCAL\_\- (not Bin Yu's) stopping criteria which has not yet been validated, I (Keith) have faith in the criteria, but enforcing the stopped after it has been decided that it needs to stop still needs some work. the only place this function is called is in \hyperlink{constant_8h_a21}{get\_\-coef\_\-and\_\-eigen.C} immediately after k\_\-active/passive and in \hyperlink{constant_8h_a21}{init\_\-piles.C} when computing the initial volume that \char`\"{}should already be\char`\"{} deposited. 

\hypertarget{classElement_a95}{
\index{Element@{Element}!calc_topo_data@{calc\_\-topo\_\-data}}
\index{calc_topo_data@{calc\_\-topo\_\-data}!Element@{Element}}
\subsubsection[calc\_\-topo\_\-data]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-topo\_\-data (\hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr})}}
\label{classElement_a95}


this function calculates topographic data, it calls GIS commands to compute elevation, slopes, and curvatures from the GIS map and scales them appropriately 

\hypertarget{classElement_a129}{
\index{Element@{Element}!calc_wet_dry_orient@{calc\_\-wet\_\-dry\_\-orient}}
\index{calc_wet_dry_orient@{calc\_\-wet\_\-dry\_\-orient}!Element@{Element}}
\subsubsection[calc\_\-wet\_\-dry\_\-orient]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-wet\_\-dry\_\-orient (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table})}}
\label{classElement_a129}


the element member function \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} determines the orientation of the dryline and which side of it is wet, the wet fraction (Swet) of a partially wet edge, the location of the drypoint, it does NOT calculate the wet area (Awet)... these quantities are used in the adjustment of fluxes in partially wet elements. \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is not coded for generic element orientation, i.e. the positive\_\-x\_\-side must be side 1. Keith wrote this may 2007 

\hypertarget{classElement_a46}{
\index{Element@{Element}!calc_which_son@{calc\_\-which\_\-son}}
\index{calc_which_son@{calc\_\-which\_\-son}!Element@{Element}}
\subsubsection[calc\_\-which\_\-son]{\setlength{\rightskip}{0pt plus 5cm}void Element::calc\_\-which\_\-son ()}}
\label{classElement_a46}


this function calculates the which\_\-son flag for the original (or restored in case of a restart) element. It also calculates which son of the grandfather element the father is durring unrefinement. 

\hypertarget{classElement_a73}{
\index{Element@{Element}!calculate_dx@{calculate\_\-dx}}
\index{calculate_dx@{calculate\_\-dx}!Element@{Element}}
\subsubsection[calculate\_\-dx]{\setlength{\rightskip}{0pt plus 5cm}void Element::calculate\_\-dx (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table})}}
\label{classElement_a73}


this function calculates the lengths of the element in the (global) x and y directions 

\hypertarget{classElement_a100}{
\index{Element@{Element}!change_neigh_info@{change\_\-neigh\_\-info}}
\index{change_neigh_info@{change\_\-neigh\_\-info}!Element@{Element}}
\subsubsection[change\_\-neigh\_\-info]{\setlength{\rightskip}{0pt plus 5cm}void Element::change\_\-neigh\_\-info (unsigned $\ast$ {\em fth\_\-key}, unsigned $\ast$ {\em ng\_\-key}, int {\em neworder}, int {\em ng\_\-gen}, int {\em fth\_\-proc})}}
\label{classElement_a100}


this function updates this elements neighbor info when one of its neighbors has been unrefined 

\hypertarget{classElement_a35}{
\index{Element@{Element}!change_neighbor@{change\_\-neighbor}}
\index{change_neighbor@{change\_\-neighbor}!Element@{Element}}
\subsubsection[change\_\-neighbor]{\setlength{\rightskip}{0pt plus 5cm}void Element::change\_\-neighbor (unsigned $\ast$ {\em newneighbs}, int {\em which\_\-side}, int {\em proc}, int {\em reg})}}
\label{classElement_a35}


call this function after this element's neighbor(s) have been refined, proc is processor id for neighbor\mbox{[}which\_\-side+4\mbox{]} 

\hypertarget{classElement_a50}{
\index{Element@{Element}!change_neighbor_process@{change\_\-neighbor\_\-process}}
\index{change_neighbor_process@{change\_\-neighbor\_\-process}!Element@{Element}}
\subsubsection[change\_\-neighbor\_\-process]{\setlength{\rightskip}{0pt plus 5cm}void Element::change\_\-neighbor\_\-process (int {\em which}, int {\em newp})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a50}


this function is called during repartitioning when one of an element's neighbors is sent to another processor 

\hypertarget{classElement_a99}{
\index{Element@{Element}!check_unrefinement@{check\_\-unrefinement}}
\index{check_unrefinement@{check\_\-unrefinement}!Element@{Element}}
\subsubsection[check\_\-unrefinement]{\setlength{\rightskip}{0pt plus 5cm}int Element::check\_\-unrefinement (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, double {\em target})}}
\label{classElement_a99}


this function is defined in \hyperlink{constant_8h_a21}{unrefine.C}, it is also called in that file and no where else, it prevents refinement when one or more of the brothers does not belong to this processor 

\hypertarget{classElement_a132}{
\index{Element@{Element}!convect_dryline@{convect\_\-dryline}}
\index{convect_dryline@{convect\_\-dryline}!Element@{Element}}
\subsubsection[convect\_\-dryline]{\setlength{\rightskip}{0pt plus 5cm}double Element::convect\_\-dryline (double {\em Vx\-Vy}\mbox{[}2\mbox{]}, double {\em dt})}}
\label{classElement_a132}


The Element member function \hyperlink{classElement_a132}{convect\_\-dryline()} calculates the coordinates of the \char`\"{}drypoint\char`\"{} in the element's local coordinate system. This is used to determine the location of the wet-dry front (or dryline) inside this element, which in turn is used (in conjunction with the location of \char`\"{}iwetnode\char`\"{} - which indicates which side of the dryline is wet) to determine the fraction of its total area that is wet (Awet). Awet is then returned by the function. Keith wrote this function may 2007. 

\hypertarget{classElement_a58}{
\index{Element@{Element}!copy_key_to_lb_key@{copy\_\-key\_\-to\_\-lb\_\-key}}
\index{copy_key_to_lb_key@{copy\_\-key\_\-to\_\-lb\_\-key}!Element@{Element}}
\subsubsection[copy\_\-key\_\-to\_\-lb\_\-key]{\setlength{\rightskip}{0pt plus 5cm}void Element::copy\_\-key\_\-to\_\-lb\_\-key ()}}
\label{classElement_a58}


this function copies the elmenent key to the load balancing key 

\hypertarget{classElement_a80}{
\index{Element@{Element}!correct@{correct}}
\index{correct@{correct}!Element@{Element}}
\subsubsection[correct]{\setlength{\rightskip}{0pt plus 5cm}void Element::correct (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, double {\em dt}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, \hyperlink{structFluxProps}{Flux\-Props} $\ast$ {\em fluxprops\_\-ptr}, \hyperlink{structTimeProps}{Time\-Props} $\ast$ {\em timeprops\_\-ptr}, double $\ast$ {\em forceint}, double $\ast$ {\em forcebed}, double $\ast$ {\em eroded}, double $\ast$ {\em deposited})}}
\label{classElement_a80}


this function performs the corrector update, in the predictor (finite difference) corrector (finite volume) timestepping that titan uses. Actually this function passes values to a short fortran subroutine named \char`\"{}correct\_\-\char`\"{} that performs the calculations. The \char`\"{}correct\_\-\char`\"{} fortran subroutine should be torn out and the guts rewritten in C++ here. That may make it into this release if there is time, otherwise expect it in the next release 

\hypertarget{classElement_a88}{
\index{Element@{Element}!determine_refinement@{determine\_\-refinement}}
\index{determine_refinement@{determine\_\-refinement}!Element@{Element}}
\subsubsection[determine\_\-refinement]{\setlength{\rightskip}{0pt plus 5cm}int Element::determine\_\-refinement (double)}}
\label{classElement_a88}


this function is titan legacy code it is defined in \hyperlink{constant_8h_a21}{Element2.C} but is not called anywhere 

\hypertarget{classElement_a84}{
\index{Element@{Element}!eval_velocity@{eval\_\-velocity}}
\index{eval_velocity@{eval\_\-velocity}!Element@{Element}}
\subsubsection[eval\_\-velocity]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::eval\_\-velocity (double {\em xoffset}, double {\em yoffset}, double {\em Vx\-Vy}\mbox{[}2\mbox{]})}}
\label{classElement_a84}


this function computes the velocity, either V=h\-V/h or shortspeed in the direction of h\-V/h, if the pile is short, that is h is less than the defined (nondimensional) value of GEOFLOW\_\-SHORT, see \hyperlink{geoflow_8h}{geoflow.h}, it chooses the speed to be min($|$h\-V/h$|$,shortspeed) if h is greater than GEOFLOW\_\-SHORT it chooses h\-V/h regardless of which one is smaller. 

\hypertarget{classElement_a98}{
\index{Element@{Element}!find_brothers@{find\_\-brothers}}
\index{find_brothers@{find\_\-brothers}!Element@{Element}}
\subsubsection[find\_\-brothers]{\setlength{\rightskip}{0pt plus 5cm}int Element::find\_\-brothers (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, double {\em target}, int {\em myid}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, void $\ast$ {\em New\-Father\-List}, void $\ast$ {\em Other\-Proc\-Update})}}
\label{classElement_a98}


this function is defined in \hyperlink{constant_8h_a21}{unrefine.C}, it is also called in that file, it finds this element's brothers 

\hypertarget{classElement_a62}{
\index{Element@{Element}!find_opposite_brother@{find\_\-opposite\_\-brother}}
\index{find_opposite_brother@{find\_\-opposite\_\-brother}!Element@{Element}}
\subsubsection[find\_\-opposite\_\-brother]{\setlength{\rightskip}{0pt plus 5cm}void Element::find\_\-opposite\_\-brother (\hyperlink{classHashTable}{Hash\-Table} $\ast$)}}
\label{classElement_a62}


this function computes searches for an element's brother, i.e. the brother (son of the same father) that is located diagonally from it, to get the brother information requires that atleast one of this element's neighboring brothers is on this process in order to get information onthe brother that is not a neighbor 

\hypertarget{classElement_a69}{
\index{Element@{Element}!find_positive_x_side@{find\_\-positive\_\-x\_\-side}}
\index{find_positive_x_side@{find\_\-positive\_\-x\_\-side}!Element@{Element}}
\subsubsection[find\_\-positive\_\-x\_\-side]{\setlength{\rightskip}{0pt plus 5cm}void Element::find\_\-positive\_\-x\_\-side (\hyperlink{classHashTable}{Hash\-Table} $\ast$)}}
\label{classElement_a69}


this function computes which side of the element is facing the positive x direction 

\hypertarget{classElement_a34}{
\index{Element@{Element}!get_adapted_flag@{get\_\-adapted\_\-flag}}
\index{get_adapted_flag@{get\_\-adapted\_\-flag}!Element@{Element}}
\subsubsection[get\_\-adapted\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-adapted\_\-flag ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a34}


magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()} and \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} with adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()} and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within \hyperlink{hadpt_8C_a12}{H\_\-adapt()}, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. 

\hypertarget{classElement_a121}{
\index{Element@{Element}!get_Awet@{get\_\-Awet}}
\index{get_Awet@{get\_\-Awet}!Element@{Element}}
\subsubsection[get\_\-Awet]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-Awet ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a121}


this inline member function returns the stored value of Awet, Awet is the fraction of an element's area that is wet (has material), 0.0$<$=Awet$<$=1.0, where there is no flow (pileheight $<$ GEOFLOW\_\-TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 

\hypertarget{classElement_a30}{
\index{Element@{Element}!get_bcptr@{get\_\-bcptr}}
\index{get_bcptr@{get\_\-bcptr}!Element@{Element}}
\subsubsection[get\_\-bcptr]{\setlength{\rightskip}{0pt plus 5cm}\hyperlink{structBC}{BC} $\ast$ Element::get\_\-bcptr ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a30}


returns the pointer to this element's array of boundary conditions, not really all that important in titan since any flow that goes beyond the boundary of the GIS map leaves the computational domain. 

\hypertarget{classElement_a16}{
\index{Element@{Element}!get_brothers@{get\_\-brothers}}
\index{get_brothers@{get\_\-brothers}!Element@{Element}}
\subsubsection[get\_\-brothers]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::get\_\-brothers ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a16}


this function returns the keys of an element's 4 brothers (an element is considered to be it's own brother) this is used during unrefinement to combine 4 brothers into their father element 

\hypertarget{classElement_a85}{
\index{Element@{Element}!get_coefABCD@{get\_\-coefABCD}}
\index{get_coefABCD@{get\_\-coefABCD}!Element@{Element}}
\subsubsection[get\_\-coefABCD]{\setlength{\rightskip}{0pt plus 5cm}double$\ast$ Element::get\_\-coef\-ABCD ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a85}


this function is legacy afeapi code, it is never called in the finite difference/volume version of titan 

\hypertarget{classElement_a103}{
\index{Element@{Element}!get_coord@{get\_\-coord}}
\index{get_coord@{get\_\-coord}!Element@{Element}}
\subsubsection[get\_\-coord]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-coord ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a103}


this function returns the precomputed and scaled coordinates of this element (which would be the same as its bubble node's coordinates) 

\hypertarget{classElement_a115}{
\index{Element@{Element}!get_counted@{get\_\-counted}}
\index{get_counted@{get\_\-counted}!Element@{Element}}
\subsubsection[get\_\-counted]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-counted ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a115}


for debugging only 

\hypertarget{classElement_a91}{
\index{Element@{Element}!get_curvature@{get\_\-curvature}}
\index{get_curvature@{get\_\-curvature}!Element@{Element}}
\subsubsection[get\_\-curvature]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-curvature ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a91}


this function returns the precomputed local terrain curvature. Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. 

\hypertarget{classElement_a90}{
\index{Element@{Element}!get_d_gravity@{get\_\-d\_\-gravity}}
\index{get_d_gravity@{get\_\-d\_\-gravity}!Element@{Element}}
\subsubsection[get\_\-d\_\-gravity]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-d\_\-gravity ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a90}


this function returns the precomputed derivatives of the z component of gravity, this is a purely terrain geometry dependant derivative, that is little diffent than curvature 

\hypertarget{classElement_a66}{
\index{Element@{Element}!get_d_state_vars@{get\_\-d\_\-state\_\-vars}}
\index{get_d_state_vars@{get\_\-d\_\-state\_\-vars}!Element@{Element}}
\subsubsection[get\_\-d\_\-state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-d\_\-state\_\-vars ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a66}


this function returns the vector of x and y derivatives of state variables, all the x derivatives come first as a group followed by the y derivatives as a group 

\hypertarget{classElement_a127}{
\index{Element@{Element}!get_drypoint@{get\_\-drypoint}}
\index{get_drypoint@{get\_\-drypoint}!Element@{Element}}
\subsubsection[get\_\-drypoint]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-drypoint ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a127}


this inline member function returns the array \char`\"{}drypoint\char`\"{}. drypoint\mbox{[}0\mbox{]} is the local x-coordinate, and drypoint\mbox{[}1\mbox{]} the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 

\hypertarget{classElement_a68}{
\index{Element@{Element}!get_dx@{get\_\-dx}}
\index{get_dx@{get\_\-dx}!Element@{Element}}
\subsubsection[get\_\-dx]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-dx ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a68}


this function returns the length of an element in the x and y directions 

\hypertarget{classElement_a119}{
\index{Element@{Element}!get_effect_bedfrict@{get\_\-effect\_\-bedfrict}}
\index{get_effect_bedfrict@{get\_\-effect\_\-bedfrict}!Element@{Element}}
\subsubsection[get\_\-effect\_\-bedfrict]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-effect\_\-bedfrict ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a119}


one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped 

\hypertarget{classElement_a120}{
\index{Element@{Element}!get_effect_kactxy@{get\_\-effect\_\-kactxy}}
\index{get_effect_kactxy@{get\_\-effect\_\-kactxy}!Element@{Element}}
\subsubsection[get\_\-effect\_\-kactxy]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-effect\_\-kactxy ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a120}


one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect\_\-kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows 

\hypertarget{classElement_a79}{
\index{Element@{Element}!get_eigenvxymax@{get\_\-eigenvxymax}}
\index{get_eigenvxymax@{get\_\-eigenvxymax}!Element@{Element}}
\subsubsection[get\_\-eigenvxymax]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-eigenvxymax ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a79}


this function calculates the maximum x and y direction wavespeeds which are the eigenvalues of the flux jacobian 

\hypertarget{classElement_a51}{
\index{Element@{Element}!get_el_err@{get\_\-el\_\-err}}
\index{get_el_err@{get\_\-el\_\-err}!Element@{Element}}
\subsubsection[get\_\-el\_\-err]{\setlength{\rightskip}{0pt plus 5cm}double$\ast$ Element::get\_\-el\_\-err ()}}
\label{classElement_a51}


the function returns the vector of element \char`\"{}error\char`\"{}, element error is used to say when a function should be refined 

\hypertarget{classElement_a27}{
\index{Element@{Element}!get_el_error@{get\_\-el\_\-error}}
\index{get_el_error@{get\_\-el\_\-error}!Element@{Element}}
\subsubsection[get\_\-el\_\-error]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-el\_\-error ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a27}


returns the element's error vector 

\hypertarget{classElement_a26}{
\index{Element@{Element}!get_el_solution@{get\_\-el\_\-solution}}
\index{get_el_solution@{get\_\-el\_\-solution}!Element@{Element}}
\subsubsection[get\_\-el\_\-solution]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-el\_\-solution ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a26}


return the element's solution vector 

\hypertarget{classElement_a89}{
\index{Element@{Element}!get_elevation@{get\_\-elevation}}
\index{get_elevation@{get\_\-elevation}!Element@{Element}}
\subsubsection[get\_\-elevation]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-elevation ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a89}


this function returns the precomputed elevation 

\hypertarget{classElement_a101}{
\index{Element@{Element}!get_elm_loc@{get\_\-elm\_\-loc}}
\index{get_elm_loc@{get\_\-elm\_\-loc}!Element@{Element}}
\subsubsection[get\_\-elm\_\-loc]{\setlength{\rightskip}{0pt plus 5cm}int $\ast$ Element::get\_\-elm\_\-loc ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a101}


this function returns the elm\_\-loc variable, which is used in unrefinement beyond the initial coarse grid 

\hypertarget{classElement_a31}{
\index{Element@{Element}!get_gen@{get\_\-gen}}
\index{get_gen@{get\_\-gen}!Element@{Element}}
\subsubsection[get\_\-gen]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-gen ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a31}


returns this elements generation, that is how many times it's been refined -8$<$=generation$<$=+3, negative means courser than original mesh 

\hypertarget{classElement_a87}{
\index{Element@{Element}!get_gravity@{get\_\-gravity}}
\index{get_gravity@{get\_\-gravity}!Element@{Element}}
\subsubsection[get\_\-gravity]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-gravity ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a87}


returns the already computed gravity vector in local coordinates, the local z direction is normal to the terrain surface and the projection of the local x and y components into the horizontal plane are aligned with global x (UTM E) and y (UTM N) directions. 

\hypertarget{classElement_a109}{
\index{Element@{Element}!get_influx@{get\_\-influx}}
\index{get_influx@{get\_\-influx}!Element@{Element}}
\subsubsection[get\_\-influx]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-influx ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a109}


this function returns the stored value of the extrusion (out of the ground) fluxes in this element 

\hypertarget{classElement_a117}{
\index{Element@{Element}!get_ithelem@{get\_\-ithelem}}
\index{get_ithelem@{get\_\-ithelem}!Element@{Element}}
\subsubsection[get\_\-ithelem]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-ithelem ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a117}


when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 

\hypertarget{classElement_a125}{
\index{Element@{Element}!get_iwetnode@{get\_\-iwetnode}}
\index{get_iwetnode@{get\_\-iwetnode}!Element@{Element}}
\subsubsection[get\_\-iwetnode]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-iwetnode ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a125}


this inline member function returns the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its \char`\"{}wettest\char`\"{} node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight $<$ GEOFLOW\_\-TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 

\hypertarget{classElement_a86}{
\index{Element@{Element}!get_kactxy@{get\_\-kactxy}}
\index{get_kactxy@{get\_\-kactxy}!Element@{Element}}
\subsubsection[get\_\-kactxy]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-kactxy ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a86}


this function returns the already calculated value(s) of k active passive, which comes from using th Coulomb friction model of granular flows (this is problem specific to titan and thus does not appear in the standard afeapi code) 

\hypertarget{classElement_a93}{
\index{Element@{Element}!get_lam@{get\_\-lam}}
\index{get_lam@{get\_\-lam}!Element@{Element}}
\subsubsection[get\_\-lam]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-lam ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a93}


this function is never called in the finite difference/volume version of titan, it is legacy (I believe titan rather than afeapi legacy code) that probably should be removed 

\hypertarget{classElement_a56}{
\index{Element@{Element}!get_lb_key@{get\_\-lb\_\-key}}
\index{get_lb_key@{get\_\-lb\_\-key}!Element@{Element}}
\subsubsection[get\_\-lb\_\-key]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::get\_\-lb\_\-key ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a56}


this function returns the load balancing key, which is used during repartitioning 

\hypertarget{classElement_a54}{
\index{Element@{Element}!get_lb_weight@{get\_\-lb\_\-weight}}
\index{get_lb_weight@{get\_\-lb\_\-weight}!Element@{Element}}
\subsubsection[get\_\-lb\_\-weight]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-lb\_\-weight ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a54}


this function returns the Load Balancing weight of an element which is used in repartitioning 

\hypertarget{classElement_a8}{
\index{Element@{Element}!get_material@{get\_\-material}}
\index{get_material@{get\_\-material}!Element@{Element}}
\subsubsection[get\_\-material]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-material ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a8}


returns the integer material flag for this element, needed for use of a material map which allows bedfriction to vary with physical position 

\hypertarget{classElement_a60}{
\index{Element@{Element}!get_myprocess@{get\_\-myprocess}}
\index{get_myprocess@{get\_\-myprocess}!Element@{Element}}
\subsubsection[get\_\-myprocess]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-myprocess ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a60}


this function returns the process(or) id of an element, it says which processor owns the element 

\hypertarget{classElement_a42}{
\index{Element@{Element}!get_neigh_gen@{get\_\-neigh\_\-gen}}
\index{get_neigh_gen@{get\_\-neigh\_\-gen}!Element@{Element}}
\subsubsection[get\_\-neigh\_\-gen]{\setlength{\rightskip}{0pt plus 5cm}int $\ast$ Element::get\_\-neigh\_\-gen ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a42}


this function returns an array holding the generation of all 8 of this element's neighbors 

\hypertarget{classElement_a29}{
\index{Element@{Element}!get_neigh_proc@{get\_\-neigh\_\-proc}}
\index{get_neigh_proc@{get\_\-neigh\_\-proc}!Element@{Element}}
\subsubsection[get\_\-neigh\_\-proc]{\setlength{\rightskip}{0pt plus 5cm}int $\ast$ Element::get\_\-neigh\_\-proc ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a29}


returns the array of processor ids for this element's 8 neighbors 

\hypertarget{classElement_a28}{
\index{Element@{Element}!get_neighbors@{get\_\-neighbors}}
\index{get_neighbors@{get\_\-neighbors}!Element@{Element}}
\subsubsection[get\_\-neighbors]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::get\_\-neighbors ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a28}


returns the array of keys for this element's 8 neighbors 

\hypertarget{classElement_a52}{
\index{Element@{Element}!get_nelb_icon@{get\_\-nelb\_\-icon}}
\index{get_nelb_icon@{get\_\-nelb\_\-icon}!Element@{Element}}
\subsubsection[get\_\-nelb\_\-icon]{\setlength{\rightskip}{0pt plus 5cm}void Element::get\_\-nelb\_\-icon (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, int $\ast$, int $\ast$)}}
\label{classElement_a52}


this function is afeapi legacy it is not called anywhere in the finite difference/volume version of titan 

\hypertarget{classElement_a48}{
\index{Element@{Element}!get_new_old@{get\_\-new\_\-old}}
\index{get_new_old@{get\_\-new\_\-old}!Element@{Element}}
\subsubsection[get\_\-new\_\-old]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-new\_\-old ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a48}


this function returns the vlaue of the new\_\-old flag which is used during mesh adaptation and repartitioning 

\hypertarget{classElement_a12}{
\index{Element@{Element}!get_no_of_dof@{get\_\-no\_\-of\_\-dof}}
\index{get_no_of_dof@{get\_\-no\_\-of\_\-dof}!Element@{Element}}
\subsubsection[get\_\-no\_\-of\_\-dof]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-no\_\-of\_\-dof ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a12}


not used in finite difference/volume version of titan, legacy, returns number of degrees of freedom, used is global stiffness matrices 

\hypertarget{classElement_a61}{
\index{Element@{Element}!get_opposite_brother_flag@{get\_\-opposite\_\-brother\_\-flag}}
\index{get_opposite_brother_flag@{get\_\-opposite\_\-brother\_\-flag}!Element@{Element}}
\subsubsection[get\_\-opposite\_\-brother\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-opposite\_\-brother\_\-flag ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a61}


this function returns the opposite\_\-brother\_\-flag, I (Keith) am not entirely sure what this flag is for, but I know that it is used in repartioning, see BSFC\_\-combine\_\-elements, I think it says if an element has an opposite brother, that is, can it be combined with it's brothers to form their father 

\hypertarget{classElement_a21}{
\index{Element@{Element}!get_order@{get\_\-order}}
\index{get_order@{get\_\-order}!Element@{Element}}
\subsubsection[get\_\-order]{\setlength{\rightskip}{0pt plus 5cm}int $\ast$ Element::get\_\-order ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a21}


afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) 

\hypertarget{classElement_a70}{
\index{Element@{Element}!get_positive_x_side@{get\_\-positive\_\-x\_\-side}}
\index{get_positive_x_side@{get\_\-positive\_\-x\_\-side}!Element@{Element}}
\subsubsection[get\_\-positive\_\-x\_\-side]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-positive\_\-x\_\-side ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a70}


this function returns which side of the element is facing the positive x direction 

\hypertarget{classElement_a72}{
\index{Element@{Element}!get_prev_state_vars@{get\_\-prev\_\-state\_\-vars}}
\index{get_prev_state_vars@{get\_\-prev\_\-state\_\-vars}!Element@{Element}}
\subsubsection[get\_\-prev\_\-state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-prev\_\-state\_\-vars ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a72}


this function returns a vector containing the previous state variables, previous mean beginning of timestep before the finite difference predictor halfstep 

\hypertarget{classElement_a41}{
\index{Element@{Element}!get_recv_flag@{get\_\-recv\_\-flag}}
\index{get_recv_flag@{get\_\-recv\_\-flag}!Element@{Element}}
\subsubsection[get\_\-recv\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-recv\_\-flag (int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a41}


this function isn't being called anywhere, which means it is afeapi legacy 

\hypertarget{classElement_a33}{
\index{Element@{Element}!get_refined_flag@{get\_\-refined\_\-flag}}
\index{get_refined_flag@{get\_\-refined\_\-flag}!Element@{Element}}
\subsubsection[get\_\-refined\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-refined\_\-flag ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a33}


refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. refined can be permanently set to GHOST (defined in \hyperlink{constant_8h}{constant.h}) or zero or temporarily set to 1 (with in the refinement and unrefinement routines), Keith believes it's not being unset (set from 1 to 0) when it should be after the refinement is done. Keith believes the problem is located within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within it, recurse down. 

\hypertarget{classElement_a40}{
\index{Element@{Element}!get_send_flag@{get\_\-send\_\-flag}}
\index{get_send_flag@{get\_\-send\_\-flag}!Element@{Element}}
\subsubsection[get\_\-send\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-send\_\-flag (int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a40}


this function isn't being called anywhere, which means it is afeapi legacy 

\hypertarget{classElement_a82}{
\index{Element@{Element}!get_shortspeed@{get\_\-shortspeed}}
\index{get_shortspeed@{get\_\-shortspeed}!Element@{Element}}
\subsubsection[get\_\-shortspeed]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-shortspeed ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a82}


this function returns the already computed shortspeed 

\hypertarget{classElement_a71}{
\index{Element@{Element}!get_slopes@{get\_\-slopes}}
\index{get_slopes@{get\_\-slopes}!Element@{Element}}
\subsubsection[get\_\-slopes]{\setlength{\rightskip}{0pt plus 5cm}void Element::get\_\-slopes (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, double)}}
\label{classElement_a71}


this function computes the x and y derivatives of the state variables 

\hypertarget{classElement_a65}{
\index{Element@{Element}!get_state_vars@{get\_\-state\_\-vars}}
\index{get_state_vars@{get\_\-state\_\-vars}!Element@{Element}}
\subsubsection[get\_\-state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-state\_\-vars ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a65}


this function returns the vector of state variables 

\hypertarget{classElement_a9}{
\index{Element@{Element}!get_stiffness@{get\_\-stiffness}}
\index{get_stiffness@{get\_\-stiffness}!Element@{Element}}
\subsubsection[get\_\-stiffness]{\setlength{\rightskip}{0pt plus 5cm}void Element::get\_\-stiffness (\hyperlink{classHashTable}{Hash\-Table} $\ast$, \hyperlink{classHashTable}{Hash\-Table} $\ast$, double $\ast$, double $\ast$, \hyperlink{classElement}{Element} $\ast$)}}
\label{classElement_a9}


legacy afeapi function prototype, this function does not exist in the finite difference/volume version of Titan 

\hypertarget{classElement_a107}{
\index{Element@{Element}!get_stoppedflags@{get\_\-stoppedflags}}
\index{get_stoppedflags@{get\_\-stoppedflags}!Element@{Element}}
\subsubsection[get\_\-stoppedflags]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-stoppedflags ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a107}


this function returns the value of \char`\"{}stoppedflags\char`\"{} 

\hypertarget{classElement_a123}{
\index{Element@{Element}!get_Swet@{get\_\-Swet}}
\index{get_Swet@{get\_\-Swet}!Element@{Element}}
\subsubsection[get\_\-Swet]{\setlength{\rightskip}{0pt plus 5cm}double Element::get\_\-Swet ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a123}


this inline member function returns the stored value of Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight $<$ GEOFLOW\_\-TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0$<$=Swet$<$=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is called in \hyperlink{constant_8h_a21}{step.C}. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 

\hypertarget{classElement_a45}{
\index{Element@{Element}!get_which_son@{get\_\-which\_\-son}}
\index{get_which_son@{get\_\-which\_\-son}!Element@{Element}}
\subsubsection[get\_\-which\_\-son]{\setlength{\rightskip}{0pt plus 5cm}int Element::get\_\-which\_\-son ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a45}


returns the which\_\-son flag, which tells the portion of the father element that this element is physically located in 

\hypertarget{classElement_a67}{
\index{Element@{Element}!get_zeta@{get\_\-zeta}}
\index{get_zeta@{get\_\-zeta}!Element@{Element}}
\subsubsection[get\_\-zeta]{\setlength{\rightskip}{0pt plus 5cm}double $\ast$ Element::get\_\-zeta ()}}
\label{classElement_a67}


this function returns the x and y slopes of the terrain elevation 

\hypertarget{classElement_a11}{
\index{Element@{Element}!getassoc@{getassoc}}
\index{getassoc@{getassoc}!Element@{Element}}
\subsubsection[getassoc]{\setlength{\rightskip}{0pt plus 5cm}int $\ast$ Element::getassoc ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a11}


returns the array of 8 processors for the 8 neigbors of this element 

\hypertarget{classElement_a22}{
\index{Element@{Element}!getfather@{getfather}}
\index{getfather@{getfather}!Element@{Element}}
\subsubsection[getfather]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::getfather ()}}
\label{classElement_a22}


find and return what the key of this element's father element would be, very simple since the bubble node has the same key as the element, so all this function does is find which of its corner nodes will be the father element's bubble node, which it knows since it knows which\_\-son it is. 

\hypertarget{classElement_a10}{
\index{Element@{Element}!getNode@{getNode}}
\index{getNode@{getNode}!Element@{Element}}
\subsubsection[getNode]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::get\-Node ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a10}


returns the address of the first of 8 (nodes 0-7) node keys in an array, the node keys are used to access the nodes through the node hashtable 

\hypertarget{classElement_a24}{
\index{Element@{Element}!getson@{getson}}
\index{getson@{getson}!Element@{Element}}
\subsubsection[getson]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::getson ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a24}


return the element keys of this element's 4 sons, used during refinement 

\hypertarget{classElement_a113}{
\index{Element@{Element}!if_first_buffer_boundary@{if\_\-first\_\-buffer\_\-boundary}}
\index{if_first_buffer_boundary@{if\_\-first\_\-buffer\_\-boundary}!Element@{Element}}
\subsubsection[if\_\-first\_\-buffer\_\-boundary]{\setlength{\rightskip}{0pt plus 5cm}int Element::if\_\-first\_\-buffer\_\-boundary (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Elem\-Table}, double {\em contour\_\-height})}}
\label{classElement_a113}


the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight$<$contour\_\-height)\&\&(Influx\mbox{[}0\mbox{]}==0)) and adjacent to the pile. It is \char`\"{}N\char`\"{} elements wide, and the \char`\"{}N\char`\"{} element width is increased one element at a time. This function returns 2 if this element a member of the innermost boundary of the buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be members of the innermost boundary of the buffer layer 

\hypertarget{classElement_a114}{
\index{Element@{Element}!if_next_buffer_boundary@{if\_\-next\_\-buffer\_\-boundary}}
\index{if_next_buffer_boundary@{if\_\-next\_\-buffer\_\-boundary}!Element@{Element}}
\subsubsection[if\_\-next\_\-buffer\_\-boundary]{\setlength{\rightskip}{0pt plus 5cm}int Element::if\_\-next\_\-buffer\_\-boundary (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Elem\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, double {\em contour\_\-height})}}
\label{classElement_a114}


the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight$<$contour\_\-height)\&\&(Influx\mbox{[}0\mbox{]}==0)) and adjacent to the pile. It is \char`\"{}N\char`\"{} elements wide, and the \char`\"{}N\char`\"{} element width is increased one element at a time. This function returns 2 if this element a member of the boundary of the buffer that is one element wider than the current buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be in the next buffer boundary 

\hypertarget{classElement_a111}{
\index{Element@{Element}!if_pile_boundary@{if\_\-pile\_\-boundary}}
\index{if_pile_boundary@{if\_\-pile\_\-boundary}!Element@{Element}}
\subsubsection[if\_\-pile\_\-boundary]{\setlength{\rightskip}{0pt plus 5cm}int Element::if\_\-pile\_\-boundary (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Elem\-Table}, double {\em contour\_\-height})}}
\label{classElement_a111}


this function returns 2 if this element contains pileheight$>$=contour\_\-height and has a neighbor who contains pileheight$<$contour\_\-height. It returns 1 if this element contains pileheight$<$contour\_\-height and has a neighbor who contains pileheight$>$=contour\_\-height. It returns 0 otherwise. The intended use if if(Em\-Temp-$>$if\_\-pile\_\-boundary(Elem\-Table,contour\_\-height)) but I (Keith) added the distinction bewteen 1 and 2 to allow future developers to distinguish between the inside and outside of a pileheight contour line, as this functionality could be useful in the future. 

\hypertarget{classElement_a112}{
\index{Element@{Element}!if_source_boundary@{if\_\-source\_\-boundary}}
\index{if_source_boundary@{if\_\-source\_\-boundary}!Element@{Element}}
\subsubsection[if\_\-source\_\-boundary]{\setlength{\rightskip}{0pt plus 5cm}int Element::if\_\-source\_\-boundary (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Elem\-Table})}}
\label{classElement_a112}


this function returns 2 if this element has Influx\mbox{[}0\mbox{]}$>$0 and has a neighbor who has Influx\mbox{[}0\mbox{]}$<$=0. It returns 1 if this element has Influx\mbox{[}0\mbox{]}==0 and has a neighbor who has Influx\mbox{[}0\mbox{]}!=0. It returns -1 if this element has Influx\mbox{[}0\mbox{]}$<$0 and a neighbor with Influx\mbox{[}0\mbox{]}$>$=0. It returns 0 otherwise. Influx\mbox{[}0\mbox{]} is a pileheight per unit time source term. Currently Influx\mbox{[}0\mbox{]} is restricted to be non-negative (a source or no source with sinks not allowed), but I (Keith) have added the extra functionality because it may be useful at a future date. The intended use if if(Em\-Temp-$>$if\_\-source\_\-boundary(Elem\-Table)), but the distinction between 1 and 2 allows futuredevelopers to distinguish between the strictly inside and strictly outside of an area with a flux source term. 

\hypertarget{classElement_a74}{
\index{Element@{Element}!insert_coord@{insert\_\-coord}}
\index{insert_coord@{insert\_\-coord}!Element@{Element}}
\subsubsection[insert\_\-coord]{\setlength{\rightskip}{0pt plus 5cm}void Element::insert\_\-coord (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table})}}
\label{classElement_a74}


this function assigns the element's coordinates to be its bubble node's coordinates 

\hypertarget{classElement_a7}{
\index{Element@{Element}!pass_key@{pass\_\-key}}
\index{pass_key@{pass\_\-key}!Element@{Element}}
\subsubsection[pass\_\-key]{\setlength{\rightskip}{0pt plus 5cm}unsigned $\ast$ Element::pass\_\-key ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a7}


returns address of element (same as bubble node, node 8 out of 0-$>$8) hashtable key 

\hypertarget{classElement_a37}{
\index{Element@{Element}!put_adapted_flag@{put\_\-adapted\_\-flag}}
\index{put_adapted_flag@{put\_\-adapted\_\-flag}!Element@{Element}}
\subsubsection[put\_\-adapted\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-adapted\_\-flag (int {\em new\_\-adapted\_\-status})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a37}


refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. The magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. These values are defined in \hyperlink{constant_8h}{constant.h}. The NEWSON value has allowed Keith to provide one time only immunity from unrefinement to recently refined elements, after which the \char`\"{}adapted\char`\"{} flag is resent to NOTRECADAPTED. 

\hypertarget{classElement_a122}{
\index{Element@{Element}!put_Awet@{put\_\-Awet}}
\index{put_Awet@{put\_\-Awet}!Element@{Element}}
\subsubsection[put\_\-Awet]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-Awet (double {\em Awet\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a122}


this inline member function assigns a value to Awet, Awet is the fraction of an element's area that is wet (has material), 0.0$<$=Awet$<$=1.0, where there is no flow (pileheight $<$ GEOFLOW\_\-TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 

\hypertarget{classElement_a104}{
\index{Element@{Element}!put_coord@{put\_\-coord}}
\index{put_coord@{put\_\-coord}!Element@{Element}}
\subsubsection[put\_\-coord]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-coord (double $\ast$ {\em coord\_\-in})}}
\label{classElement_a104}


this function stores the coordinates of this element (which would be the same as its bubble node's coordinates) 

\hypertarget{classElement_a116}{
\index{Element@{Element}!put_counted@{put\_\-counted}}
\index{put_counted@{put\_\-counted}!Element@{Element}}
\subsubsection[put\_\-counted]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-counted (int {\em countedvalue})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a116}


for debugging only 

\hypertarget{classElement_a128}{
\index{Element@{Element}!put_drypoint@{put\_\-drypoint}}
\index{put_drypoint@{put\_\-drypoint}!Element@{Element}}
\subsubsection[put\_\-drypoint]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-drypoint (double $\ast$ {\em drypoint\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a128}


this inline member function sets the values of the array \char`\"{}drypoint\char`\"{}. drypoint\mbox{[}0\mbox{]} is the local x-coordinate, and drypoint\mbox{[}1\mbox{]} the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 

\hypertarget{classElement_a102}{
\index{Element@{Element}!put_elm_loc@{put\_\-elm\_\-loc}}
\index{put_elm_loc@{put\_\-elm\_\-loc}!Element@{Element}}
\subsubsection[put\_\-elm\_\-loc]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-elm\_\-loc (int $\ast$ {\em int\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a102}


this function sets the elm\_\-loc variable, which is used in unrefinement beyond the initial coarse grid 

\hypertarget{classElement_a23}{
\index{Element@{Element}!put_father@{put\_\-father}}
\index{put_father@{put\_\-father}!Element@{Element}}
\subsubsection[put\_\-father]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-father (unsigned {\em fatherin}\mbox{[}KEYLENGTH\mbox{]})}}
\label{classElement_a23}


store the father's key in the \char`\"{}father\char`\"{} variable, the \char`\"{}father's\char`\"{} key is zero until an element has been unrefined (and has not yet been deleted) it is only used in unrefinement. The \hyperlink{classElement_a22}{getfather()} member function computes the father key from \char`\"{}which\_\-son\char`\"{} and it's nodes and is totally unrelated to the father variable. 

\hypertarget{classElement_a13}{
\index{Element@{Element}!put_gen@{put\_\-gen}}
\index{put_gen@{put\_\-gen}!Element@{Element}}
\subsubsection[put\_\-gen]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-gen (int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a13}


set the generation (number of times it's been refined -8$<$=gen$<$=+3) of this \char`\"{}element\char`\"{}/cell 

\hypertarget{classElement_a64}{
\index{Element@{Element}!put_height@{put\_\-height}}
\index{put_height@{put\_\-height}!Element@{Element}}
\subsubsection[put\_\-height]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-height (double {\em pile\_\-height})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a64}


this function assigns a specified value to the pileheight and zeros to the momentums and shortspeed 

\hypertarget{classElement_a63}{
\index{Element@{Element}!put_height_mom@{put\_\-height\_\-mom}}
\index{put_height_mom@{put\_\-height\_\-mom}!Element@{Element}}
\subsubsection[put\_\-height\_\-mom]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-height\_\-mom (double {\em pile\_\-height}, double {\em xmom}, double {\em ymom})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a63}


this function initializes pileheight, momentums and shortspeed (also known as the L'Hosptial speed see calc\_\-shortspeed for an explanation),this function is called in \hyperlink{constant_8h_a21}{init\_\-piles.C} 

\hypertarget{classElement_a118}{
\index{Element@{Element}!put_ithelem@{put\_\-ithelem}}
\index{put_ithelem@{put\_\-ithelem}!Element@{Element}}
\subsubsection[put\_\-ithelem]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-ithelem (int {\em i})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a118}


when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 

\hypertarget{classElement_a126}{
\index{Element@{Element}!put_iwetnode@{put\_\-iwetnode}}
\index{put_iwetnode@{put\_\-iwetnode}!Element@{Element}}
\subsubsection[put\_\-iwetnode]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-iwetnode (int {\em iwetnode\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a126}


this inline member function sets the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its \char`\"{}wettest\char`\"{} node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight $<$ GEOFLOW\_\-TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 

\hypertarget{classElement_a92}{
\index{Element@{Element}!put_lam@{put\_\-lam}}
\index{put_lam@{put\_\-lam}!Element@{Element}}
\subsubsection[put\_\-lam]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-lam (double {\em lam\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a92}


the only place this function is called is in \hyperlink{constant_8h_a21}{move\_\-data.C}, I believe it is legacy titan code and could probably be removed 

\hypertarget{classElement_a57}{
\index{Element@{Element}!put_lb_key@{put\_\-lb\_\-key}}
\index{put_lb_key@{put\_\-lb\_\-key}!Element@{Element}}
\subsubsection[put\_\-lb\_\-key]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-lb\_\-key (unsigned $\ast$ {\em in\_\-key})}}
\label{classElement_a57}


this function sets the load balancing key, which is used during repartitioning 

\hypertarget{classElement_a55}{
\index{Element@{Element}!put_lb_weight@{put\_\-lb\_\-weight}}
\index{put_lb_weight@{put\_\-lb\_\-weight}!Element@{Element}}
\subsubsection[put\_\-lb\_\-weight]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-lb\_\-weight (double {\em dd\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a55}


this function stores an element's load balancing weight, which is used during repartitioning 

\hypertarget{classElement_a59}{
\index{Element@{Element}!put_myprocess@{put\_\-myprocess}}
\index{put_myprocess@{put\_\-myprocess}!Element@{Element}}
\subsubsection[put\_\-myprocess]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-myprocess (int {\em in\_\-proc})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a59}


this function sets the process(or) id of an element, it says which processor owns the element. 

\hypertarget{classElement_a43}{
\index{Element@{Element}!put_neigh_gen@{put\_\-neigh\_\-gen}}
\index{put_neigh_gen@{put\_\-neigh\_\-gen}!Element@{Element}}
\subsubsection[put\_\-neigh\_\-gen]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-neigh\_\-gen (int {\em i}, int {\em gen})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a43}


this function sets the ith neighbor's generation to \char`\"{}gen\char`\"{} 

\hypertarget{classElement_a19}{
\index{Element@{Element}!put_neigh_proc@{put\_\-neigh\_\-proc}}
\index{put_neigh_proc@{put\_\-neigh\_\-proc}!Element@{Element}}
\subsubsection[put\_\-neigh\_\-proc]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-neigh\_\-proc (int {\em i}, int {\em proc})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a19}


this function stores the processor id \char`\"{}proc\char`\"{} of neighbor \char`\"{}i\char`\"{} in the 8 element array of neighbor processors, use this function instead of putassoc. 

\hypertarget{classElement_a47}{
\index{Element@{Element}!put_new_old@{put\_\-new\_\-old}}
\index{put_new_old@{put\_\-new\_\-old}!Element@{Element}}
\subsubsection[put\_\-new\_\-old]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-new\_\-old (int {\em i})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a47}


this function sets the new or old flag, it is initialized in \hyperlink{constant_8h_a21}{htflush.C} and reset during repartitioning (\hyperlink{constant_8h_a21}{repartition\_\-BSFC.C} and \hyperlink{constant_8h_a21}{BSFC\_\-update\_\-and\_\-send\_\-elements.C}) 

\hypertarget{classElement_a20}{
\index{Element@{Element}!put_order@{put\_\-order}}
\index{put_order@{put\_\-order}!Element@{Element}}
\subsubsection[put\_\-order]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-order (int, int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a20}


afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) 

\hypertarget{classElement_a39}{
\index{Element@{Element}!put_recv_flag@{put\_\-recv\_\-flag}}
\index{put_recv_flag@{put\_\-recv\_\-flag}!Element@{Element}}
\subsubsection[put\_\-recv\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-recv\_\-flag (int, int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a39}


this function is only called in \hyperlink{constant_8h_a21}{htflush.C} to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that 

\hypertarget{classElement_a36}{
\index{Element@{Element}!put_refined_flag@{put\_\-refined\_\-flag}}
\index{put_refined_flag@{put\_\-refined\_\-flag}!Element@{Element}}
\subsubsection[put\_\-refined\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-refined\_\-flag (int {\em i})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a36}


set this element's refined flag to i, can set it to normal (hasn't just been refined and isn't a ghost cell), \char`\"{}temporarily\char`\"{} set to \char`\"{}refined\char`\"{} (has just been refined so don't refine again), or say that it's a GHOST cell, see \hyperlink{constant_8h}{constant.h}, (which means you don't update it, instead you get new values from the processor that owns it and you don't refine it.) refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()}, \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} are the partly replaced predecessors of adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()}, and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}. 

\hypertarget{classElement_a38}{
\index{Element@{Element}!put_send_flag@{put\_\-send\_\-flag}}
\index{put_send_flag@{put\_\-send\_\-flag}!Element@{Element}}
\subsubsection[put\_\-send\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-send\_\-flag (int, int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a38}


this function is only called in \hyperlink{constant_8h_a21}{htflush.C} to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that 

\hypertarget{classElement_a83}{
\index{Element@{Element}!put_shortspeed@{put\_\-shortspeed}}
\index{put_shortspeed@{put\_\-shortspeed}!Element@{Element}}
\subsubsection[put\_\-shortspeed]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-shortspeed (double {\em shortspeedin})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a83}


this function assigns the value passed in to shortspeed 

\hypertarget{classElement_a106}{
\index{Element@{Element}!put_stoppedflags@{put\_\-stoppedflags}}
\index{put_stoppedflags@{put\_\-stoppedflags}!Element@{Element}}
\subsubsection[put\_\-stoppedflags]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-stoppedflags (int {\em stoppedflagsin})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a106}


this function is used to assign a value to stopped flags, for when you don't want to compute the criteria to decide whether it's stopped or not, useful during developement 

\hypertarget{classElement_a124}{
\index{Element@{Element}!put_Swet@{put\_\-Swet}}
\index{put_Swet@{put\_\-Swet}!Element@{Element}}
\subsubsection[put\_\-Swet]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-Swet (double {\em Swet\_\-in})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a124}


this inline member function assigns a value to Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight $<$ GEOFLOW\_\-TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0$<$=Swet$<$=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when \hyperlink{classElement_a129}{calc\_\-wet\_\-dry\_\-orient()} is called in \hyperlink{constant_8h_a21}{step.C}. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 

\hypertarget{classElement_a44}{
\index{Element@{Element}!put_which_son@{put\_\-which\_\-son}}
\index{put_which_son@{put\_\-which\_\-son}!Element@{Element}}
\subsubsection[put\_\-which\_\-son]{\setlength{\rightskip}{0pt plus 5cm}void Element::put\_\-which\_\-son (int)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a44}


this function sets the which\_\-son flag when a father element is refined into its 4 sons, the which\_\-son flag tells the portion of the father element that this element is physically located in 

\hypertarget{classElement_a17}{
\index{Element@{Element}!putassoc@{putassoc}}
\index{putassoc@{putassoc}!Element@{Element}}
\subsubsection[putassoc]{\setlength{\rightskip}{0pt plus 5cm}void Element::putassoc (int {\em a}, int {\em i})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a17}


this function stores the processor id \char`\"{}a\char`\"{} of neighbor \char`\"{}i\char`\"{} in the 8 element array of neighbor processors, this functionality is duplicated by put\_\-neigh\_\-proc which is the preferred function to use (don't use this one it's legacy) 

\hypertarget{classElement_a15}{
\index{Element@{Element}!putbrothers@{putbrothers}}
\index{putbrothers@{putbrothers}!Element@{Element}}
\subsubsection[putbrothers]{\setlength{\rightskip}{0pt plus 5cm}void Element::putbrothers (unsigned $\ast$)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a15}


when a father element is refined into 4 son elements, the 4 son elements are \char`\"{}brothers\char`\"{} (they can be recombined into the father), this function stores the keys of all four brothers in one of them, it should be called 4 times one for each brother 

\hypertarget{classElement_a25}{
\index{Element@{Element}!putel_sq@{putel\_\-sq}}
\index{putel_sq@{putel\_\-sq}!Element@{Element}}
\subsubsection[putel\_\-sq]{\setlength{\rightskip}{0pt plus 5cm}void Element::putel\_\-sq (double {\em solsq}, double {\em ellsq})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a25}


stores the ?square? of the \char`\"{}solution\char`\"{} and solution error, used durring refinement 

\hypertarget{classElement_a18}{
\index{Element@{Element}!putneighbor@{putneighbor}}
\index{putneighbor@{putneighbor}!Element@{Element}}
\subsubsection[putneighbor]{\setlength{\rightskip}{0pt plus 5cm}void Element::putneighbor (unsigned $\ast$ {\em n}, int {\em i})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a18}


this function stores the key \char`\"{}n\char`\"{} of neighbor \char`\"{}i\char`\"{} in the array of the 8 keys of the neighbor keys 

\hypertarget{classElement_a14}{
\index{Element@{Element}!putson@{putson}}
\index{putson@{putson}!Element@{Element}}
\subsubsection[putson]{\setlength{\rightskip}{0pt plus 5cm}void Element::putson (unsigned $\ast$)\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a14}


store the keys for the four son \char`\"{}elements\char`\"{} in the father element, used temporarily during refinement 

\hypertarget{classElement_a6}{
\index{Element@{Element}!save_elem@{save\_\-elem}}
\index{save_elem@{save\_\-elem}!Element@{Element}}
\subsubsection[save\_\-elem]{\setlength{\rightskip}{0pt plus 5cm}void Element::save\_\-elem (FILE $\ast$ {\em fp}, FILE $\ast$ {\em fptxt})}}
\label{classElement_a6}


this member function saves a single element to a file with a single fwrite call, this allows the element to be recreated/restored upon restart of a simulation 

\hypertarget{classElement_a49}{
\index{Element@{Element}!update_ndof@{update\_\-ndof}}
\index{update_ndof@{update\_\-ndof}!Element@{Element}}
\subsubsection[update\_\-ndof]{\setlength{\rightskip}{0pt plus 5cm}void Element::update\_\-ndof ()}}
\label{classElement_a49}


this function is legacy afeapi code, the function is defined in \hyperlink{constant_8h_a21}{element2.C} but it is never called anywhere in the finite difference/volume version of titan because it's finite element (including Discontinuous Galerkin) specific code 

\hypertarget{classElement_a53}{
\index{Element@{Element}!void_bcptr@{void\_\-bcptr}}
\index{void_bcptr@{void\_\-bcptr}!Element@{Element}}
\subsubsection[void\_\-bcptr]{\setlength{\rightskip}{0pt plus 5cm}void Element::void\_\-bcptr ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a53}


this function sets the pointer to an element's boundary conditions to NULL 

\hypertarget{classElement_a32}{
\index{Element@{Element}!which_neighbor@{which\_\-neighbor}}
\index{which_neighbor@{which\_\-neighbor}!Element@{Element}}
\subsubsection[which\_\-neighbor]{\setlength{\rightskip}{0pt plus 5cm}int Element::which\_\-neighbor (unsigned $\ast$ {\em Find\-Neigh})}}
\label{classElement_a32}


compare the Find\-Neigh key against the keys of this element's 8 neighbors to determine which if any neighbor Find\-Neigh is 

\hypertarget{classElement_a76}{
\index{Element@{Element}!xdirflux@{xdirflux}}
\index{xdirflux@{xdirflux}!Element@{Element}}
\subsubsection[xdirflux]{\setlength{\rightskip}{0pt plus 5cm}void Element::xdirflux (\hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, double {\em dz}, double {\em thisside\-Swet}, double {\em hfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]}, double {\em hrfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]})}}
\label{classElement_a76}


this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) x direction fluxes. Keith wrote this 

\hypertarget{classElement_a77}{
\index{Element@{Element}!ydirflux@{ydirflux}}
\index{ydirflux@{ydirflux}!Element@{Element}}
\subsubsection[ydirflux]{\setlength{\rightskip}{0pt plus 5cm}void Element::ydirflux (\hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, double {\em dz}, double {\em thisside\-Swet}, double {\em hfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]}, double {\em hrfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]})}}
\label{classElement_a77}


this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) y direction fluxes. Keith wrote this 

\hypertarget{classElement_a75}{
\index{Element@{Element}!zdirflux@{zdirflux}}
\index{zdirflux@{zdirflux}!Element@{Element}}
\subsubsection[zdirflux]{\setlength{\rightskip}{0pt plus 5cm}void Element::zdirflux (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, \hyperlink{structMatProps}{Mat\-Props} $\ast$ {\em matprops\_\-ptr}, int {\em order\_\-flag}, int {\em dir}, double {\em hfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]}, double {\em hrfv}\mbox{[}3\mbox{]}\mbox{[}NUM\_\-STATE\_\-VARS\mbox{]}, \hyperlink{classElement}{Element} $\ast$ {\em Em\-Neigh}, double {\em dt})}}
\label{classElement_a75}


this function, based on the dir flag, chooses between calling xdirflux and ydirflux, which respectively, calculate either the x or y direction analytical cell center fluxes (or the fluxes at the the boundary if 2nd order flux option is checked on the gui). Keith wrote this. 

\hypertarget{classElement_a108}{
\index{Element@{Element}!zero_influx@{zero\_\-influx}}
\index{zero_influx@{zero\_\-influx}!Element@{Element}}
\subsubsection[zero\_\-influx]{\setlength{\rightskip}{0pt plus 5cm}void Element::zero\_\-influx ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classElement_a108}


this function zeros the extrusion (out of the ground) fluxes in this element 



\subsection{Friends And Related Function Documentation}
\hypertarget{classElement_n1}{
\index{Element@{Element}!AssertMeshErrorFree@{AssertMeshErrorFree}}
\index{AssertMeshErrorFree@{AssertMeshErrorFree}!Element@{Element}}
\subsubsection[AssertMeshErrorFree]{\setlength{\rightskip}{0pt plus 5cm}void Assert\-Mesh\-Error\-Free (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em numprocs}, int {\em myid}, double {\em loc})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n1}


this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG. 

\hypertarget{classElement_n9}{
\index{Element@{Element}!BSFC_combine_elements@{BSFC\_\-combine\_\-elements}}
\index{BSFC_combine_elements@{BSFC\_\-combine\_\-elements}!Element@{Element}}
\subsubsection[BSFC\_\-combine\_\-elements]{\setlength{\rightskip}{0pt plus 5cm}void BSFC\_\-combine\_\-elements (int {\em side}, \hyperlink{classElement}{Element} $\ast$ {\em Em\-Temp}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Elem\_\-Ptr}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Node\_\-Ptr}, int {\em destination\_\-proc})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n9}


this function figures out how to \char`\"{}bunch\char`\"{} together elements that cannot be put on different processors because of a constrained node, B stands for bunch SFC stands for space filling curve 

\hypertarget{classElement_n13}{
\index{Element@{Element}!construct_el@{construct\_\-el}}
\index{construct_el@{construct\_\-el}!Element@{Element}}
\subsubsection[construct\_\-el]{\setlength{\rightskip}{0pt plus 5cm}void construct\_\-el (\hyperlink{classElement}{Element} $\ast$ {\em newelement}, \hyperlink{structElemPack}{Elem\-Pack} $\ast$ {\em elem2}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Node\_\-Ptr}, int {\em myid}, double $\ast$ {\em e\_\-error})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n13}


construct\_\-el is a friend function of the Element class that fills an element with information it receives in a variable of the \hyperlink{structElemPack}{Elem\-Pack} class from an MPI call 

\hypertarget{classElement_n12}{
\index{Element@{Element}!create_element@{create\_\-element}}
\index{create_element@{create\_\-element}!Element@{Element}}
\subsubsection[create\_\-element]{\setlength{\rightskip}{0pt plus 5cm}void create\_\-element (\hyperlink{structElemPack}{Elem\-Pack} $\ast$ {\em elem2}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Elem\_\-Ptr}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Node\_\-Ptr}, int {\em myid}, double $\ast$ {\em e\_\-error})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n12}


\hyperlink{classElement_n12}{create\_\-element()} is a friend function of the Element and \hyperlink{classNode}{Node} classes. After receiving an \hyperlink{structElemPack}{Elem\-Pack}, \hyperlink{classElement_n12}{create\_\-element()} instances a new element, calls \hyperlink{classElement_n13}{construct\_\-el()} to transfer data from \hyperlink{structElemPack}{Elem\-Pack} to the new element, and inserts the new element into the Hashtable. Don't call this if s\_\-flag is 0 (original repartitioning scheme) 

\hypertarget{classElement_n5}{
\index{Element@{Element}!delete_oldsons@{delete\_\-oldsons}}
\index{delete_oldsons@{delete\_\-oldsons}!Element@{Element}}
\subsubsection[delete\_\-oldsons]{\setlength{\rightskip}{0pt plus 5cm}void delete\_\-oldsons (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em myid}, void $\ast$ {\em Em\-Father})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n5}


\hypertarget{classElement_n11}{
\index{Element@{Element}!destroy_element@{destroy\_\-element}}
\index{destroy_element@{destroy\_\-element}!Element@{Element}}
\subsubsection[destroy\_\-element]{\setlength{\rightskip}{0pt plus 5cm}void destroy\_\-element (void $\ast$ {\em r\_\-element}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Elem\_\-Ptr}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Node\_\-Ptr}, int {\em target\_\-pro}, \hyperlink{structElementLink}{ELink\-Ptr} $\ast$ {\em EL\_\-head})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n11}


\hyperlink{classElement_n11}{destroy\_\-element()} is a friend function of the Element and \hyperlink{classNode}{Node} classes that does the following

1. Update the neighbor\_\-proc of the neighbors 1.1 if neighbor is at the same proc----$>$ok 1.2 if neighbor is at the target proc--$>$done when the element is created in its new subdomain 1.3 if neighbor is at a 3rd proc-------$>$these elements are linked for later communication

2. Remove element from the hashtable

3. Remove some nodes..........later not now \hypertarget{classElement_n2}{
\index{Element@{Element}!ElemBackgroundCheck@{ElemBackgroundCheck}}
\index{ElemBackgroundCheck@{ElemBackgroundCheck}!Element@{Element}}
\subsubsection[ElemBackgroundCheck]{\setlength{\rightskip}{0pt plus 5cm}void Elem\-Background\-Check (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, unsigned $\ast$ {\em debugkey}, FILE $\ast$ {\em fp})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n2}


investigate an Element, question his \char`\"{}friends and family\char`\"{} about him. 

\hypertarget{classElement_n3}{
\index{Element@{Element}!ElemBackgroundCheck2@{ElemBackgroundCheck2}}
\index{ElemBackgroundCheck2@{ElemBackgroundCheck2}!Element@{Element}}
\subsubsection[ElemBackgroundCheck2]{\setlength{\rightskip}{0pt plus 5cm}void Elem\-Background\-Check2 (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, void $\ast$ {\em Em\-Debug}, FILE $\ast$ {\em fp})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n3}


\hypertarget{classElement_n0}{
\index{Element@{Element}!HashTable@{HashTable}}
\index{HashTable@{HashTable}!Element@{Element}}
\subsubsection[HashTable]{\setlength{\rightskip}{0pt plus 5cm}friend class \hyperlink{classHashTable}{Hash\-Table}\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n0}


\hypertarget{classElement_n4}{
\index{Element@{Element}!NodeBackgroundCheck@{NodeBackgroundCheck}}
\index{NodeBackgroundCheck@{NodeBackgroundCheck}!Element@{Element}}
\subsubsection[NodeBackgroundCheck]{\setlength{\rightskip}{0pt plus 5cm}void Node\-Background\-Check (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, unsigned $\ast$ {\em debugkey}, FILE $\ast$ {\em fp})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n4}


investigate a \hyperlink{classNode}{Node} question his \char`\"{}friends and family\char`\"{} about him. 

\hypertarget{classElement_n10}{
\index{Element@{Element}!Pack_element@{Pack\_\-element}}
\index{Pack_element@{Pack\_\-element}!Element@{Element}}
\subsubsection[Pack\_\-element]{\setlength{\rightskip}{0pt plus 5cm}void Pack\_\-element (void $\ast$ {\em sendel}, \hyperlink{structElemPack}{Elem\-Pack} $\ast$ {\em elem}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em HT\_\-Node\_\-Ptr}, int {\em destination\_\-proc})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n10}


\hyperlink{classElement_n10}{Pack\_\-element()} is a friend function of the Element and \hyperlink{classNode}{Node} classes that packs relevant information from an element \char`\"{}sendel\char`\"{} into a smaller data structure (\hyperlink{structElemPack}{Elem\-Pack}) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning. 

\hypertarget{classElement_n6}{
\index{Element@{Element}!refine_neigh_update@{refine\_\-neigh\_\-update}}
\index{refine_neigh_update@{refine\_\-neigh\_\-update}!Element@{Element}}
\subsubsection[refine\_\-neigh\_\-update]{\setlength{\rightskip}{0pt plus 5cm}void refine\_\-neigh\_\-update (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em numprocs}, int {\em myid}, void $\ast$ {\em Refined\-List}, \hyperlink{structTimeProps}{Time\-Props} $\ast$ {\em timeprops\_\-ptr})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n6}


\hypertarget{classElement_n8}{
\index{Element@{Element}!unrefine_interp_neigh_update@{unrefine\_\-interp\_\-neigh\_\-update}}
\index{unrefine_interp_neigh_update@{unrefine\_\-interp\_\-neigh\_\-update}!Element@{Element}}
\subsubsection[unrefine\_\-interp\_\-neigh\_\-update]{\setlength{\rightskip}{0pt plus 5cm}void unrefine\_\-interp\_\-neigh\_\-update (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em nump}, int {\em myid}, void $\ast$ {\em Other\-Proc\-Update})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n8}


\hypertarget{classElement_n7}{
\index{Element@{Element}!unrefine_neigh_update@{unrefine\_\-neigh\_\-update}}
\index{unrefine_neigh_update@{unrefine\_\-neigh\_\-update}!Element@{Element}}
\subsubsection[unrefine\_\-neigh\_\-update]{\setlength{\rightskip}{0pt plus 5cm}void unrefine\_\-neigh\_\-update (\hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em El\_\-Table}, \hyperlink{classHashTable}{Hash\-Table} $\ast$ {\em Node\-Table}, int {\em myid}, void $\ast$ {\em New\-Father\-List})\hspace{0.3cm}{\tt  \mbox{[}friend\mbox{]}}}}
\label{classElement_n7}




\subsection{Member Data Documentation}
\hypertarget{classElement_r20}{
\index{Element@{Element}!adapted@{adapted}}
\index{adapted@{adapted}!Element@{Element}}
\subsubsection[adapted]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r20}{Element::adapted}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r20}


The magnitude of the \char`\"{}adapted\char`\"{} flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, \hyperlink{classElement_a33}{get\_\-refined\_\-flag()} and \hyperlink{classElement_a36}{put\_\-refined\_\-flag()} with adapted, \hyperlink{classElement_a34}{get\_\-adapted\_\-flag()} and \hyperlink{classElement_a37}{put\_\-adapted\_\-flag()}, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within \hyperlink{hadpt_8C_a12}{H\_\-adapt()} or a function called from within \hyperlink{hadpt_8C_a12}{H\_\-adapt()}, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. 

\hypertarget{classElement_r51}{
\index{Element@{Element}!Awet@{Awet}}
\index{Awet@{Awet}!Element@{Element}}
\subsubsection[Awet]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r51}{Element::Awet}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r51}


Awet is the ratio of this element's wet area to total area (always between 0 and 1 inclusive) when taken together with iwetnode, this uniquely determines the exact placement of the \char`\"{}dryline\char`\"{} within the current element. Awet is initially set by source placement to be either 0 (no material) or 1 (material) and is updated by the corrector part of the predictor-corrector method, the new value is determined by where the dry line has been convected to over this timestep. Keith wrote this May 2007. 

\hypertarget{classElement_r14}{
\index{Element@{Element}!bcptr@{bcptr}}
\index{bcptr@{bcptr}!Element@{Element}}
\subsubsection[bcptr]{\setlength{\rightskip}{0pt plus 5cm}\hyperlink{structBC}{BC}$\ast$ \hyperlink{classElement_r14}{Element::bcptr}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r14}


pointer to the boundary condition class, if this element is not a boundary element the pointer holds the NULL value 

\hypertarget{classElement_r23}{
\index{Element@{Element}!brothers@{brothers}}
\index{brothers@{brothers}!Element@{Element}}
\subsubsection[brothers]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r23}{Element::brothers}\mbox{[}4\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r23}


this array holds the keys of this element's 4 brothers (an element is considered to be it's own brother), this information is used during mesh unrefinement (combining the 4 brothers to make their father), keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r35}{
\index{Element@{Element}!coefABCD@{coefABCD}}
\index{coefABCD@{coefABCD}!Element@{Element}}
\subsubsection[coefABCD]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r35}{Element::coef\-ABCD}\mbox{[}4\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r35}


this is legacy afeapi not used in titan 

\hypertarget{classElement_r24}{
\index{Element@{Element}!coord@{coord}}
\index{coord@{coord}!Element@{Element}}
\subsubsection[coord]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r24}{Element::coord}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r24}


coord holds the coordinates of the elements cell center, these are the same as the coordinates of the element's bubble node's 

\hypertarget{classElement_r48}{
\index{Element@{Element}!counted@{counted}}
\index{counted@{counted}!Element@{Element}}
\subsubsection[counted]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r48}{Element::counted}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r48}


\hypertarget{classElement_r39}{
\index{Element@{Element}!curvature@{curvature}}
\index{curvature@{curvature}!Element@{Element}}
\subsubsection[curvature]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r39}{Element::curvature}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r39}


Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. 

\hypertarget{classElement_r41}{
\index{Element@{Element}!d_gravity@{d\_\-gravity}}
\index{d_gravity@{d\_\-gravity}!Element@{Element}}
\subsubsection[d\_\-gravity]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r41}{Element::d\_\-gravity}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r41}


the spatial (x and y) derivatives of the local z component of the gravity vector 

\hypertarget{classElement_r30}{
\index{Element@{Element}!d_state_vars@{d\_\-state\_\-vars}}
\index{d_state_vars@{d\_\-state\_\-vars}!Element@{Element}}
\subsubsection[d\_\-state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r30}{Element::d\_\-state\_\-vars}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS} $\ast$\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r30}


these are the spatial (x and y) derivatives of the state variables: (dh/dx, dh\-Vx/dx, dh\-Vy/dx, dh/dy, dh\-Vx/dy, dh\-Vy/dy) 

\hypertarget{classElement_r52}{
\index{Element@{Element}!drypoint@{drypoint}}
\index{drypoint@{drypoint}!Element@{Element}}
\subsubsection[drypoint]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r52}{Element::drypoint}\mbox{[}2\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r52}


center point of the \char`\"{}dryline\char`\"{}, x and y coordinates value ranges between -0.5 and 0.5 with 0 being the center of the element, since the wet/dry interface is taken to be a non-deforming non rotating (within the timestep) \char`\"{}dryline\char`\"{} convecting a single point on the dryline (called the drypoint) is sufficient to determine the new placement of the dryline which allows us to update Awet... Keith wrote this May 2007. 

\hypertarget{classElement_r32}{
\index{Element@{Element}!dx@{dx}}
\index{dx@{dx}!Element@{Element}}
\subsubsection[dx]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r32}{Element::dx}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r32}


length of the element in the global x and y directions: dx and dy 

\hypertarget{classElement_r44}{
\index{Element@{Element}!effect_bedfrict@{effect\_\-bedfrict}}
\index{effect_bedfrict@{effect\_\-bedfrict}!Element@{Element}}
\subsubsection[effect\_\-bedfrict]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r44}{Element::effect\_\-bedfrict}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r44}


one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped 

\hypertarget{classElement_r46}{
\index{Element@{Element}!effect_kactxy@{effect\_\-kactxy}}
\index{effect_kactxy@{effect\_\-kactxy}!Element@{Element}}
\subsubsection[effect\_\-kactxy]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r46}{Element::effect\_\-kactxy}\mbox{[}2\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r46}


one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect\_\-kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows 

\hypertarget{classElement_r45}{
\index{Element@{Element}!effect_tanbedfrict@{effect\_\-tanbedfrict}}
\index{effect_tanbedfrict@{effect\_\-tanbedfrict}!Element@{Element}}
\subsubsection[effect\_\-tanbedfrict]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r45}{Element::effect\_\-tanbedfrict}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r45}


one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus effect\_\-tanbedfrict holds the value of the effective bed friction angle 

\hypertarget{classElement_r34}{
\index{Element@{Element}!eigenvxymax@{eigenvxymax}}
\index{eigenvxymax@{eigenvxymax}!Element@{Element}}
\subsubsection[eigenvxymax]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r34}{Element::eigenvxymax}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r34}


maximum x and y direction wavespeeds for this element, wavespeeds are eigenvalues of the flux jacobians 

\hypertarget{classElement_r17}{
\index{Element@{Element}!el_error@{el\_\-error}}
\index{el_error@{el\_\-error}!Element@{Element}}
\subsubsection[el\_\-error]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r17}{Element::el\_\-error}\mbox{[}\hyperlink{constant_8h_a16}{EQUATIONS}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r17}


this holds the \char`\"{}error\char`\"{} in the element's solution, which is useful in determining refinement, this may actually be afeapi legacy 

\hypertarget{classElement_r18}{
\index{Element@{Element}!el_solution@{el\_\-solution}}
\index{el_solution@{el\_\-solution}!Element@{Element}}
\subsubsection[el\_\-solution]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r18}{Element::el\_\-solution}\mbox{[}\hyperlink{constant_8h_a16}{EQUATIONS}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r18}


this holds the element solution, I believe this is legacy afeapi 

\hypertarget{classElement_r37}{
\index{Element@{Element}!elevation@{elevation}}
\index{elevation@{elevation}!Element@{Element}}
\subsubsection[elevation]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r37}{Element::elevation}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r37}


terrain elevation at this elements center/bubble node 

\hypertarget{classElement_r25}{
\index{Element@{Element}!elm_loc@{elm\_\-loc}}
\index{elm_loc@{elm\_\-loc}!Element@{Element}}
\subsubsection[elm\_\-loc]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r25}{Element::elm\_\-loc}\mbox{[}2\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r25}


elm\_\-loc is used in unrefining beyond the original coarse mesh 

\hypertarget{classElement_r9}{
\index{Element@{Element}!father@{father}}
\index{father@{father}!Element@{Element}}
\subsubsection[father]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r9}{Element::father}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r9}


the key of the father it is assigned in the \hyperlink{hadpt_8C_a5}{refine()} and unrefine\_\-elements() functions 

\hypertarget{classElement_r1}{
\index{Element@{Element}!generation@{generation}}
\index{generation@{generation}!Element@{Element}}
\subsubsection[generation]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r1}{Element::generation}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r1}


generation is how many times this element has been refined, currently -8$<$=generation$<$=3, a negative generation number means it has been unrefined beyond the orignal coarse mesh, a positive generation number means it has been refined (is smaller than the original element size) 

\hypertarget{classElement_r40}{
\index{Element@{Element}!gravity@{gravity}}
\index{gravity@{gravity}!Element@{Element}}
\subsubsection[gravity]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r40}{Element::gravity}\mbox{[}3\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r40}


the gravity vector in local x,y,z coordinates (z is normal to the terrain surface, the projections of the x and y local directions onto a horizontal plane are aligned with the global x and y directions) 

\hypertarget{classElement_r47}{
\index{Element@{Element}!Influx@{Influx}}
\index{Influx@{Influx}!Element@{Element}}
\subsubsection[Influx]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r47}{Element::Influx}\mbox{[}3\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r47}


extrusion flux rate for this timestep for this element, used when having material flow out of the ground, a volume per unit area influx rate source term 

\hypertarget{classElement_r49}{
\index{Element@{Element}!ithelem@{ithelem}}
\index{ithelem@{ithelem}!Element@{Element}}
\subsubsection[ithelem]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r49}{Element::ithelem}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r49}


when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 

\hypertarget{classElement_r50}{
\index{Element@{Element}!iwetnode@{iwetnode}}
\index{iwetnode@{iwetnode}!Element@{Element}}
\subsubsection[iwetnode]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r50}{Element::iwetnode}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r50}


the node number \{0,1,..,7\} of this element's \char`\"{}most wet node\char`\"{}, this dictates both the orientation of the \char`\"{}dryline\char`\"{} and which side of it is wet. The \char`\"{}dryline\char`\"{} is the line that divides a partially wetted element into a dry part and a wet part, for the sake of simplicity only 4 orientations are allowed, horizontal, vertical, parallel to either diagonal of the element. If the iwetnode is an edge node of this element then the dryline is parallel to the edge the element is on, if the iwetnode is a corner node of this element then dryline is parallel to the diagonal of the element that the iwetnode is not on. Which side of the dryline is wet is the same side in which the iwetnode resides (and is determined each timestep based soley on which of the elements neighbors currently have pile height greater than GEOFLOW\_\-TINY)... as such iwetnode can be thought of as the MOST WET NODE of the element. Having iwetnode==8 indicates that the element is uniformly wet if this element's pile height is greater than GEOFLOW\_\-TINY or is uniformly dry if pileheight is less than or equal to GEOFLOW\_\-TINY. 

\hypertarget{classElement_r36}{
\index{Element@{Element}!kactxy@{kactxy}}
\index{kactxy@{kactxy}!Element@{Element}}
\subsubsection[kactxy]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r36}{Element::kactxy}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r36}


k active/passive in the x and y directions, k active/passive is part of the coulomb friction model for Granular Flows 

\hypertarget{classElement_r6}{
\index{Element@{Element}!key@{key}}
\index{key@{key}!Element@{Element}}
\subsubsection[key]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r6}{Element::key}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r6}


this is the element key, which has the same value as the key of the element's bubble node, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r42}{
\index{Element@{Element}!lam@{lam}}
\index{lam@{lam}!Element@{Element}}
\subsubsection[lam]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r42}{Element::lam}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r42}


legacy titan not really used, lam :=p\_\-\{bed\}/(rho$\ast$g\_\-z$\ast$h) 

\hypertarget{classElement_r5}{
\index{Element@{Element}!lb_key@{lb\_\-key}}
\index{lb_key@{lb\_\-key}!Element@{Element}}
\subsubsection[lb\_\-key]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r5}{Element::lb\_\-key}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r5}


this is the key for load-balancing, if there is no constrained node, it is the element key, otherwise it is a construct of the element \char`\"{}bunch\char`\"{}, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r4}{
\index{Element@{Element}!lb_weight@{lb\_\-weight}}
\index{lb_weight@{lb\_\-weight}!Element@{Element}}
\subsubsection[lb\_\-weight]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r4}{Element::lb\_\-weight}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r4}


this is the load-balancing weight 

! ! THE MAT. FLAG ! ! ! \hypertarget{classElement_r3}{
\index{Element@{Element}!material@{material}}
\index{material@{material}!Element@{Element}}
\subsubsection[material]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r3}{Element::material}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r3}


the material flag indicates which material should be used to set this element's bed friction, this is for when a GIS material map, specifying different materials in different spatial regions of the map, the GIS material map is a non standard grass map format that Laercio Namikawa developed, it's stored in the \char`\"{}cats\char`\"{} folder under a grass mapset directory 

\hypertarget{classElement_r0}{
\index{Element@{Element}!myprocess@{myprocess}}
\index{myprocess@{myprocess}!Element@{Element}}
\subsubsection[myprocess]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r0}{Element::myprocess}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r0}


myprocess is id of the process(or) that owns this element 

\hypertarget{classElement_r15}{
\index{Element@{Element}!ndof@{ndof}}
\index{ndof@{ndof}!Element@{Element}}
\subsubsection[ndof]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r15}{Element::ndof}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r15}


the number of degrees of freedom, since Titan is a finite difference/volume code, ndof is afeapi legacy, but the DG (Discontinuous Galerkin) version of Titan actually uses this 

\hypertarget{classElement_r13}{
\index{Element@{Element}!neigh_gen@{neigh\_\-gen}}
\index{neigh_gen@{neigh\_\-gen}!Element@{Element}}
\subsubsection[neigh\_\-gen]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r13}{Element::neigh\_\-gen}\mbox{[}8\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r13}


neigh\_\-gen is an array that holds the \char`\"{}generation\char`\"{} (how refined it is) of this element's 8 neighbors, there can-be/are 2 neighbors to a side because of the 1 irregularity rule 

\hypertarget{classElement_r11}{
\index{Element@{Element}!neigh_proc@{neigh\_\-proc}}
\index{neigh_proc@{neigh\_\-proc}!Element@{Element}}
\subsubsection[neigh\_\-proc]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r11}{Element::neigh\_\-proc}\mbox{[}8\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r11}


this array holds the process(or) id of this element's 8 neighbors, there can be 8 neighbors because of the 1 irregularity rule. neigh\_\-proc\mbox{[}4:7\mbox{]} != -2 only if it has 2 neighbors on that side, a value of -1 for neigh\_\-proc means that this edge is a boundary of the computational domain. 

\hypertarget{classElement_r8}{
\index{Element@{Element}!neighbor@{neighbor}}
\index{neighbor@{neighbor}!Element@{Element}}
\subsubsection[neighbor]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r8}{Element::neighbor}\mbox{[}8\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r8}


this array holds the keys of this element's 8 neighbors (2 neigbors to a side if the neighbor is more refined than this element, otherwise the two neighbor keys for that side are identical in value), having 8 neighbors is an outcome of the 1 irregularity refinement rule, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r22}{
\index{Element@{Element}!new_old@{new\_\-old}}
\index{new_old@{new\_\-old}!Element@{Element}}
\subsubsection[new\_\-old]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r22}{Element::new\_\-old}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r22}


the new\_\-old flag is used in mesh adaptation and repartitioning 

\hypertarget{classElement_r16}{
\index{Element@{Element}!no_of_eqns@{no\_\-of\_\-eqns}}
\index{no_of_eqns@{no\_\-of\_\-eqns}!Element@{Element}}
\subsubsection[no\_\-of\_\-eqns]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r16}{Element::no\_\-of\_\-eqns}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r16}


this is legacy afeapi, it is not used, but do not remove it, it could cause problems if you do 

\hypertarget{classElement_r7}{
\index{Element@{Element}!node_key@{node\_\-key}}
\index{node_key@{node\_\-key}!Element@{Element}}
\subsubsection[node\_\-key]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r7}{Element::node\_\-key}\mbox{[}8\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r7}


this array holds the first 8 (0-$>$7) of this element's nodes' keys, the n9th (8 out of 0-$>$8) node is the bubble node it's key is not stored separately since it has the same key as the element, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r2}{
\index{Element@{Element}!opposite_brother_flag@{opposite\_\-brother\_\-flag}}
\index{opposite_brother_flag@{opposite\_\-brother\_\-flag}!Element@{Element}}
\subsubsection[opposite\_\-brother\_\-flag]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r2}{Element::opposite\_\-brother\_\-flag}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r2}


opposite\_\-brother\_\-flag indicate if we have the correct key for the non-neighbor brother (0:= don't have info, 1:= have info) 

\hypertarget{classElement_r12}{
\index{Element@{Element}!order@{order}}
\index{order@{order}!Element@{Element}}
\subsubsection[order]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r12}{Element::order}\mbox{[}5\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r12}


this is legacy afeapi, all finite volume \char`\"{}elements\char`\"{}/cells are piece wise constant, but I believe this is actually used in the DG (Discontinuous Galerkin) version of titan 

\hypertarget{classElement_r33}{
\index{Element@{Element}!positive_x_side@{positive\_\-x\_\-side}}
\index{positive_x_side@{positive\_\-x\_\-side}!Element@{Element}}
\subsubsection[positive\_\-x\_\-side]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r33}{Element::positive\_\-x\_\-side}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r33}


for structured grid, tells which side is the positive x direction 

\hypertarget{classElement_r29}{
\index{Element@{Element}!prev_state_vars@{prev\_\-state\_\-vars}}
\index{prev_state_vars@{prev\_\-state\_\-vars}!Element@{Element}}
\subsubsection[prev\_\-state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r29}{Element::prev\_\-state\_\-vars}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r29}


these are the values of the state variables from before the predictor step 

\hypertarget{classElement_r27}{
\index{Element@{Element}!recv@{recv}}
\index{recv@{recv}!Element@{Element}}
\subsubsection[recv]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r27}{Element::recv}\mbox{[}8\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r27}


this is afeapi legacy 

\hypertarget{classElement_r19}{
\index{Element@{Element}!refined@{refined}}
\index{refined@{refined}!Element@{Element}}
\subsubsection[refined]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r19}{Element::refined}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r19}


refined is a flag that usually has the value 0, but will be 1 if the element has been refined this iteration (used to enforce the 1 irregularity rule), or have the value \char`\"{}GHOST\char`\"{} if it is a ghost cell, refined and ghost cells are not updated, see \hyperlink{constant_8h}{constant.h} for the value of GHOST 

\hypertarget{classElement_r26}{
\index{Element@{Element}!send@{send}}
\index{send@{send}!Element@{Element}}
\subsubsection[send]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r26}{Element::send}\mbox{[}8\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r26}


this is afeapi legacy 

\hypertarget{classElement_r31}{
\index{Element@{Element}!shortspeed@{shortspeed}}
\index{shortspeed@{shortspeed}!Element@{Element}}
\subsubsection[shortspeed]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r31}{Element::shortspeed}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r31}


the short speed is the speed computed as: shortspeed=$|$v$|$=$|$dhv/dh$|$=$|$v$\ast$dh/dh+h$\ast$dv/dh$|$=$|$v+h$\ast$dv/dh$|$ which goes to $|$v$|$ in the limit of h-$>$0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name \char`\"{}shortspeed\char`\"{} but it is not accurate when the pile is tall, that is when h$\ast$dv/dh is large, this is the value from the previous iteration (so there is lagging when using the shortspeed, but this should still be much more accurate than h\-V/h when h-$>$0. Keith implemented this in late summer 2006, 

\hypertarget{classElement_r10}{
\index{Element@{Element}!son@{son}}
\index{son@{son}!Element@{Element}}
\subsubsection[son]{\setlength{\rightskip}{0pt plus 5cm}unsigned \hyperlink{classElement_r10}{Element::son}\mbox{[}4\mbox{]}\mbox{[}\hyperlink{constant_8h_a10}{KEYLENGTH}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r10}


this array holds the keys of this element's 4 sons, it is only used temporarily in the refinement process before the father (this element) is deleted, there's was an old comment \char`\"{}garantee ccw\char`\"{} associated with this variable, I don't know what it means, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 

\hypertarget{classElement_r28}{
\index{Element@{Element}!state_vars@{state\_\-vars}}
\index{state_vars@{state\_\-vars}!Element@{Element}}
\subsubsection[state\_\-vars]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r28}{Element::state\_\-vars}\mbox{[}\hyperlink{constant_8h_a45}{NUM\_\-STATE\_\-VARS}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r28}


state\_\-vars is an array that holds the current state variables: h, h\-Vx, and h\-Vy 

\hypertarget{classElement_r43}{
\index{Element@{Element}!stoppedflags@{stoppedflags}}
\index{stoppedflags@{stoppedflags}!Element@{Element}}
\subsubsection[stoppedflags]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r43}{Element::stoppedflags}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r43}


part of the new stopping criteria under development, has a 0 if flow is not stopped, has the value 1 if it should not be sliding but should be slumping, has the value 2 if it should neither be sliding or slumping (it should be completely stopped), I (Keith) am rather confident in the criteria used to set this the problem is determining what to do about it after you know the flow SHOULD be stopped 

\hypertarget{classElement_r53}{
\index{Element@{Element}!Swet@{Swet}}
\index{Swet@{Swet}!Element@{Element}}
\subsubsection[Swet]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r53}{Element::Swet}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r53}


when an element edge is partially wet and partially dry... Swet is the fraction of a cell edge that is partially wet, because it can only be horizontal, vertical, or parallel to either diagonal, all of one element's partially wet sides are have the same fraction of wetness. The state variables (used to compute the physical fluxes) at the element/cell edge are adjusted to be the weighted by wetness average over an element/cell edge. As such physical fluxes through completely dry edges of partially wet elements/cells are zeroed, while physical fluxes through completely wet edges are left unchanged. Because of the definition as \char`\"{}wetness weighted average\char`\"{} physical fluxes through a partially wet edge shared with a neighbor of the same generation is also left left unchanged but, when a partially wet edge is shared with two more refined neighbors the total mass and momentum at the edge is split between the two neighbors in proportion to how much of their boundary shared with this element is wet. This \char`\"{}scaling\char`\"{} of the physical fluxes is the \char`\"{}adjustment of fluxes in partially wetted cells\char`\"{} facet of our multifaceted thin-layer problem mitigation approach. And it has been shown to significantly reduce the area covered by a thin layer of material. Keith wrote this May 2007. 

\hypertarget{classElement_r21}{
\index{Element@{Element}!which_son@{which\_\-son}}
\index{which_son@{which\_\-son}!Element@{Element}}
\subsubsection[which\_\-son]{\setlength{\rightskip}{0pt plus 5cm}int \hyperlink{classElement_r21}{Element::which\_\-son}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r21}


which\_\-son holds the value of which son this element is, which of the 4 squares that makes up the father elements square. 

\hypertarget{classElement_r38}{
\index{Element@{Element}!zeta@{zeta}}
\index{zeta@{zeta}!Element@{Element}}
\subsubsection[zeta]{\setlength{\rightskip}{0pt plus 5cm}double \hyperlink{classElement_r38}{Element::zeta}\mbox{[}\hyperlink{constant_8h_a15}{DIMENSION}\mbox{]}\hspace{0.3cm}{\tt  \mbox{[}private\mbox{]}}}}
\label{classElement_r38}


terrain slope in the global x and y directions 



The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
\hyperlink{element2_8h}{element2.h}\item 
\hyperlink{unrefine_8C}{unrefine.C}\item 
\hyperlink{element2_8C}{element2.C}\item 
\hyperlink{flux__srcs_8C}{flux\_\-srcs.C}\end{CompactItemize}
