<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Titan: Element Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Element Class Reference</h1>The Element class is a data structure designed to hold all the information need for an h (cell edge length) p (polynomial order) adaptive finite element. Titan doesn't use p adaptation because it is a finite difference/volume code, hence many of the members are legacy from afeapi (adaptive finite element application programmers interface) which serves as the core of titan. There is a seperate Discontinuous Galerkin Method (finite elements + finite volumes) version of titan and the polynomial information is not legacy there. However in this version of Titan elements function simply as finite volume cells.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="element2_8h-source.html">element2.h</a>&gt;</code>
<p>
<a href="classElement-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a0">Element</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default constructor, does nothing except set stoppedflags=2, this should never be used  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a1">Element</a> (unsigned nodekeys[][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>], unsigned neigh[][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>], int n_pro[], <a class="el" href="structBC.html">BC</a> *b, int mat, int *elm_loc_in, double pile_height, int myid, unsigned *opposite_brother)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor that creates an original element when funky is read in  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a2">Element</a> (unsigned nodekeys[][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>], unsigned neigh[][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>], int n_pro[], <a class="el" href="structBC.html">BC</a> *b, int gen, int elm_loc_in[], int *ord, int gen_neigh[], int mat, <a class="el" href="classElement.html">Element</a> *fthTemp, double *coord_in, <a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int myid, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, int iwetnodefather, double Awetfather, double *drypoint_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor that creates a son element from its father during refinement  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a3">Element</a> (<a class="el" href="classElement.html">Element</a> *sons[], <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor that creates a father element from its four sons during unrefinement  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a4">Element</a> (FILE *fp, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, int myid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor that creates/restores a saved element during restart  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a5">~Element</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor that does nothing except delete boundary condition pointer  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a6">save_elem</a> (FILE *fp, FILE *fptxt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this member function saves a single element to a file with a single fwrite call, this allows the element to be recreated/restored upon restart of a simulation  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a7">pass_key</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns address of element (same as bubble node, node 8 out of 0-&gt;8) hashtable key  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a8">get_material</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the integer material flag for this element, needed for use of a material map which allows bedfriction to vary with physical position  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a9">get_stiffness</a> (<a class="el" href="classHashTable.html">HashTable</a> *, <a class="el" href="classHashTable.html">HashTable</a> *, double *, double *, <a class="el" href="classElement.html">Element</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">legacy afeapi function prototype, this function does not exist in the finite difference/volume version of Titan  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a10">getNode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the address of the first of 8 (nodes 0-7) node keys in an array, the node keys are used to access the nodes through the node hashtable  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a11">getassoc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array of 8 processors for the 8 neigbors of this element  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a12">get_no_of_dof</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not used in finite difference/volume version of titan, legacy, returns number of degrees of freedom, used is global stiffness matrices  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a13">put_gen</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the generation (number of times it's been refined -8&lt;=gen&lt;=+3) of this "element"/cell  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a14">putson</a> (unsigned *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">store the keys for the four son "elements" in the father element, used temporarily during refinement  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a15">putbrothers</a> (unsigned *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when a father element is refined into 4 son elements, the 4 son elements are "brothers" (they can be recombined into the father), this function stores the keys of all four brothers in one of them, it should be called 4 times one for each brother  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a16">get_brothers</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the keys of an element's 4 brothers (an element is considered to be it's own brother) this is used during unrefinement to combine 4 brothers into their father element  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a17">putassoc</a> (int a, int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores the processor id "a" of neighbor "i" in the 8 element array of neighbor processors, this functionality is duplicated by put_neigh_proc which is the preferred function to use (don't use this one it's legacy)  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a18">putneighbor</a> (unsigned *n, int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores the key "n" of neighbor "i" in the array of the 8 keys of the neighbor keys  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a19">put_neigh_proc</a> (int i, int proc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores the processor id "proc" of neighbor "i" in the 8 element array of neighbor processors, use this function instead of putassoc.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a20">put_order</a> (int, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code)  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a21">get_order</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code)  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a22">getfather</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find and return what the key of this element's father element would be, very simple since the bubble node has the same key as the element, so all this function does is find which of its corner nodes will be the father element's bubble node, which it knows since it knows which_son it is.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a23">put_father</a> (unsigned fatherin[<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">store the father's key in the "father" variable, the "father's" key is zero until an element has been unrefined (and has not yet been deleted) it is only used in unrefinement. The <a class="el" href="classElement.html#a22">getfather()</a> member function computes the father key from "which_son" and it's nodes and is totally unrelated to the father variable.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a24">getson</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the element keys of this element's 4 sons, used during refinement  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a25">putel_sq</a> (double solsq, double ellsq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">stores the ?square? of the "solution" and solution error, used durring refinement  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a26">get_el_solution</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the element's solution vector  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a27">get_el_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the element's error vector  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a28">get_neighbors</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array of keys for this element's 8 neighbors  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a29">get_neigh_proc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array of processor ids for this element's 8 neighbors  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structBC.html">BC</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a30">get_bcptr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the pointer to this element's array of boundary conditions, not really all that important in titan since any flow that goes beyond the boundary of the GIS map leaves the computational domain.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a31">get_gen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns this elements generation, that is how many times it's been refined -8&lt;=generation&lt;=+3, negative means courser than original mesh  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a32">which_neighbor</a> (unsigned *FindNeigh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compare the FindNeigh key against the keys of this element's 8 neighbors to determine which if any neighbor FindNeigh is  <a href="#a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a33">get_refined_flag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>. refined can be permanently set to GHOST (defined in <a class="el" href="constant_8h.html">constant.h</a>) or zero or temporarily set to 1 (with in the refinement and unrefinement routines), Keith believes it's not being unset (set from 1 to 0) when it should be after the refinement is done. Keith believes the problem is located within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within it, recurse down.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a34">get_adapted_flag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a> and <a class="el" href="classElement.html#a36">put_refined_flag()</a> with adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a> and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a>, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a35">change_neighbor</a> (unsigned *newneighbs, int which_side, int proc, int reg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">call this function after this element's neighbor(s) have been refined, proc is processor id for neighbor[which_side+4]  <a href="#a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a36">put_refined_flag</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this element's refined flag to i, can set it to normal (hasn't just been refined and isn't a ghost cell), "temporarily" set to "refined" (has just been refined so don't refine again), or say that it's a GHOST cell, see <a class="el" href="constant_8h.html">constant.h</a>, (which means you don't update it, instead you get new values from the processor that owns it and you don't refine it.) refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>.  <a href="#a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a37">put_adapted_flag</a> (int new_adapted_status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>. The magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. These values are defined in <a class="el" href="constant_8h.html">constant.h</a>. The NEWSON value has allowed Keith to provide one time only immunity from unrefinement to recently refined elements, after which the "adapted" flag is resent to NOTRECADAPTED.  <a href="#a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a38">put_send_flag</a> (int, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is only called in <a class="el" href="constant_8h.html#a21">htflush.C</a> to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a39">put_recv_flag</a> (int, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is only called in <a class="el" href="constant_8h.html#a21">htflush.C</a> to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that  <a href="#a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a40">get_send_flag</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function isn't being called anywhere, which means it is afeapi legacy  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a41">get_recv_flag</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function isn't being called anywhere, which means it is afeapi legacy  <a href="#a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a42">get_neigh_gen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns an array holding the generation of all 8 of this element's neighbors  <a href="#a42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a43">put_neigh_gen</a> (int i, int gen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the ith neighbor's generation to "gen"  <a href="#a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a44">put_which_son</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the which_son flag when a father element is refined into its 4 sons, the which_son flag tells the portion of the father element that this element is physically located in  <a href="#a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a45">get_which_son</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the which_son flag, which tells the portion of the father element that this element is physically located in  <a href="#a45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a46">calc_which_son</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the which_son flag for the original (or restored in case of a restart) element. It also calculates which son of the grandfather element the father is durring unrefinement.  <a href="#a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a47">put_new_old</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the new or old flag, it is initialized in <a class="el" href="constant_8h.html#a21">htflush.C</a> and reset during repartitioning (<a class="el" href="constant_8h.html#a21">repartition_BSFC.C</a> and <a class="el" href="constant_8h.html#a21">BSFC_update_and_send_elements.C</a>)  <a href="#a47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a48">get_new_old</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the vlaue of the new_old flag which is used during mesh adaptation and repartitioning  <a href="#a48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a49">update_ndof</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi code, the function is defined in <a class="el" href="constant_8h.html#a21">element2.C</a> but it is never called anywhere in the finite difference/volume version of titan because it's finite element (including Discontinuous Galerkin) specific code  <a href="#a49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a50">change_neighbor_process</a> (int which, int newp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is called during repartitioning when one of an element's neighbors is sent to another processor  <a href="#a50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a51">get_el_err</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the function returns the vector of element "error", element error is used to say when a function should be refined  <a href="#a51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a52">get_nelb_icon</a> (<a class="el" href="classHashTable.html">HashTable</a> *, <a class="el" href="classHashTable.html">HashTable</a> *, int *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is afeapi legacy it is not called anywhere in the finite difference/volume version of titan  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a53">void_bcptr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the pointer to an element's boundary conditions to NULL  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a54">get_lb_weight</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the Load Balancing weight of an element which is used in repartitioning  <a href="#a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a55">put_lb_weight</a> (double dd_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores an element's load balancing weight, which is used during repartitioning  <a href="#a55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a56">get_lb_key</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the load balancing key, which is used during repartitioning  <a href="#a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a57">put_lb_key</a> (unsigned *in_key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the load balancing key, which is used during repartitioning  <a href="#a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a58">copy_key_to_lb_key</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function copies the elmenent key to the load balancing key  <a href="#a58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a59">put_myprocess</a> (int in_proc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the process(or) id of an element, it says which processor owns the element.  <a href="#a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a60">get_myprocess</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the process(or) id of an element, it says which processor owns the element  <a href="#a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a61">get_opposite_brother_flag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the opposite_brother_flag, I (Keith) am not entirely sure what this flag is for, but I know that it is used in repartioning, see BSFC_combine_elements, I think it says if an element has an opposite brother, that is, can it be combined with it's brothers to form their father  <a href="#a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a62">find_opposite_brother</a> (<a class="el" href="classHashTable.html">HashTable</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function computes searches for an element's brother, i.e. the brother (son of the same father) that is located diagonally from it, to get the brother information requires that atleast one of this element's neighboring brothers is on this process in order to get information onthe brother that is not a neighbor  <a href="#a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a63">put_height_mom</a> (double pile_height, double xmom, double ymom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function initializes pileheight, momentums and shortspeed (also known as the L'Hosptial speed see calc_shortspeed for an explanation),this function is called in <a class="el" href="constant_8h.html#a21">init_piles.C</a>  <a href="#a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a64">put_height</a> (double pile_height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function assigns a specified value to the pileheight and zeros to the momentums and shortspeed  <a href="#a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a65">get_state_vars</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the vector of state variables  <a href="#a65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a66">get_d_state_vars</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the vector of x and y derivatives of state variables, all the x derivatives come first as a group followed by the y derivatives as a group  <a href="#a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a67">get_zeta</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the x and y slopes of the terrain elevation  <a href="#a67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a68">get_dx</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the length of an element in the x and y directions  <a href="#a68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a69">find_positive_x_side</a> (<a class="el" href="classHashTable.html">HashTable</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function computes which side of the element is facing the positive x direction  <a href="#a69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a70">get_positive_x_side</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns which side of the element is facing the positive x direction  <a href="#a70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a71">get_slopes</a> (<a class="el" href="classHashTable.html">HashTable</a> *, <a class="el" href="classHashTable.html">HashTable</a> *, double)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function computes the x and y derivatives of the state variables  <a href="#a71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a72">get_prev_state_vars</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns a vector containing the previous state variables, previous mean beginning of timestep before the finite difference predictor halfstep  <a href="#a72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a73">calculate_dx</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the lengths of the element in the (global) x and y directions  <a href="#a73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a74">insert_coord</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function assigns the element's coordinates to be its bubble node's coordinates  <a href="#a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a75">zdirflux</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, int order_flag, int dir, double hfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>], double hrfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>], <a class="el" href="classElement.html">Element</a> *EmNeigh, double dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function, based on the dir flag, chooses between calling xdirflux and ydirflux, which respectively, calculate either the x or y direction analytical cell center fluxes (or the fluxes at the the boundary if 2nd order flux option is checked on the gui). Keith wrote this.  <a href="#a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a76">xdirflux</a> (<a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, double dz, double thissideSwet, double hfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>], double hrfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) x direction fluxes. Keith wrote this  <a href="#a76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a77">ydirflux</a> (<a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, double dz, double thissideSwet, double hfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>], double hrfv[3][<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) y direction fluxes. Keith wrote this  <a href="#a77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a78">calc_edge_states</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, int myid, double dt, int *order_flag, double *outflow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function (indirectly) calculates the fluxes that will be used to perform the finite volume corrector step and stores them in element edge nodes, indirectly because it calls other functions to calculate the analytical fluxes and then calls another function to compute the riemann fluxes from the analytical fluxes. Talk to me (Keith) before you modify this, as I am fairly certain that it is now completely bug free and parts of it can be slightly confusing.  <a href="#a78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a79">get_eigenvxymax</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the maximum x and y direction wavespeeds which are the eigenvalues of the flux jacobian  <a href="#a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a80">correct</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="classHashTable.html">HashTable</a> *El_Table, double dt, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, <a class="el" href="structFluxProps.html">FluxProps</a> *fluxprops_ptr, <a class="el" href="structTimeProps.html">TimeProps</a> *timeprops_ptr, double *forceint, double *forcebed, double *eroded, double *deposited)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function performs the corrector update, in the predictor (finite difference) corrector (finite volume) timestepping that titan uses. Actually this function passes values to a short fortran subroutine named "correct_" that performs the calculations. The "correct_" fortran subroutine should be torn out and the guts rewritten in C++ here. That may make it into this release if there is time, otherwise expect it in the next release  <a href="#a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a81">calc_shortspeed</a> (double inv_dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the shortspeed,also known as the L'Hospital (pronounced Loo-pee-tal, you can look up L'Hospital's rule in almost any calculus book if you so desire). here is a brief explanation of shortspeed: shortspeed=|v|=|dhv/dh|=|v*dh/dh+h*dv/dh|=|v+h*dv/dh| which goes to |v| in the limit of h-&gt;0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name "shortspeed" but it is not accurate when the pile is tall, that is when h*dv/dh is large, Keith implemented this in late summer 2006  <a href="#a81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a82">get_shortspeed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the already computed shortspeed  <a href="#a82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a83">put_shortspeed</a> (double shortspeedin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function assigns the value passed in to shortspeed  <a href="#a83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a84">eval_velocity</a> (double xoffset, double yoffset, double VxVy[2])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function computes the velocity, either V=hV/h or shortspeed in the direction of hV/h, if the pile is short, that is h is less than the defined (nondimensional) value of GEOFLOW_SHORT, see <a class="el" href="geoflow_8h.html">geoflow.h</a>, it chooses the speed to be min(|hV/h|,shortspeed) if h is greater than GEOFLOW_SHORT it chooses hV/h regardless of which one is smaller.  <a href="#a84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a85">get_coefABCD</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi code, it is never called in the finite difference/volume version of titan  <a href="#a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a86">get_kactxy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the already calculated value(s) of k active passive, which comes from using th Coulomb friction model of granular flows (this is problem specific to titan and thus does not appear in the standard afeapi code)  <a href="#a86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a87">get_gravity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the already computed gravity vector in local coordinates, the local z direction is normal to the terrain surface and the projection of the local x and y components into the horizontal plane are aligned with global x (UTM E) and y (UTM N) directions.  <a href="#a87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a88">determine_refinement</a> (double)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is titan legacy code it is defined in <a class="el" href="constant_8h.html#a21">Element2.C</a> but is not called anywhere  <a href="#a88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a89">get_elevation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the precomputed elevation  <a href="#a89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a90">get_d_gravity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the precomputed derivatives of the z component of gravity, this is a purely terrain geometry dependant derivative, that is little diffent than curvature  <a href="#a90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a91">get_curvature</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the precomputed local terrain curvature. Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation.  <a href="#a91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a92">put_lam</a> (double lam_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the only place this function is called is in <a class="el" href="constant_8h.html#a21">move_data.C</a>, I believe it is legacy titan code and could probably be removed  <a href="#a92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a93">get_lam</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is never called in the finite difference/volume version of titan, it is legacy (I believe titan rather than afeapi legacy code) that probably should be removed  <a href="#a93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a94">calc_flux_balance</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is called in <a class="el" href="constant_8h.html#a21">element_weight.C</a>, it is used in computing the load balancing weight  <a href="#a94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a95">calc_topo_data</a> (<a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates topographic data, it calls GIS commands to compute elevation, slopes, and curvatures from the GIS map and scales them appropriately  <a href="#a95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a96">calc_d_gravity</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the (global) x and y derivatives of the local z component of gravity as an approximation of the local derivatives, it wouldn't be that difficult to correct incorporating the terrain slopes in the calculation it is calculated in the creation of a father element, after mesh refinement and, during a restart.  <a href="#a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a97">calc_gravity_vector</a> (<a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the gravity vector in local coordinates  <a href="#a97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a98">find_brothers</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, double target, int myid, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, void *NewFatherList, void *OtherProcUpdate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is defined in <a class="el" href="constant_8h.html#a21">unrefine.C</a>, it is also called in that file, it finds this element's brothers  <a href="#a98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a99">check_unrefinement</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, double target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is defined in <a class="el" href="constant_8h.html#a21">unrefine.C</a>, it is also called in that file and no where else, it prevents refinement when one or more of the brothers does not belong to this processor  <a href="#a99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a100">change_neigh_info</a> (unsigned *fth_key, unsigned *ng_key, int neworder, int ng_gen, int fth_proc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function updates this elements neighbor info when one of its neighbors has been unrefined  <a href="#a100"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a101">get_elm_loc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the elm_loc variable, which is used in unrefinement beyond the initial coarse grid  <a href="#a101"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a102">put_elm_loc</a> (int *int_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the elm_loc variable, which is used in unrefinement beyond the initial coarse grid  <a href="#a102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a103">get_coord</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the precomputed and scaled coordinates of this element (which would be the same as its bubble node's coordinates)  <a href="#a103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a104">put_coord</a> (double *coord_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores the coordinates of this element (which would be the same as its bubble node's coordinates)  <a href="#a104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a105">calc_stop_crit</a> (<a class="el" href="structMatProps.html">MatProps</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is part of the experimental _LOCAL_ (not Bin Yu's) stopping criteria which has not yet been validated, I (Keith) have faith in the criteria, but enforcing the stopped after it has been decided that it needs to stop still needs some work. the only place this function is called is in <a class="el" href="constant_8h.html#a21">get_coef_and_eigen.C</a> immediately after k_active/passive and in <a class="el" href="constant_8h.html#a21">init_piles.C</a> when computing the initial volume that "should already be" deposited.  <a href="#a105"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a106">put_stoppedflags</a> (int stoppedflagsin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is used to assign a value to stopped flags, for when you don't want to compute the criteria to decide whether it's stopped or not, useful during developement  <a href="#a106"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a107">get_stoppedflags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the value of "stoppedflags"  <a href="#a107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a108">zero_influx</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function zeros the extrusion (out of the ground) fluxes in this element  <a href="#a108"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a109">get_influx</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the stored value of the extrusion (out of the ground) fluxes in this element  <a href="#a109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a110">calc_flux</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="structFluxProps.html">FluxProps</a> *fluxprops, <a class="el" href="structTimeProps.html">TimeProps</a> *timeprops)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function calculates the extrusion (out of the ground) fluxes for this elements  <a href="#a110"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a111">if_pile_boundary</a> (<a class="el" href="classHashTable.html">HashTable</a> *ElemTable, double contour_height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns 2 if this element contains pileheight&gt;=contour_height and has a neighbor who contains pileheight&lt;contour_height. It returns 1 if this element contains pileheight&lt;contour_height and has a neighbor who contains pileheight&gt;=contour_height. It returns 0 otherwise. The intended use if if(EmTemp-&gt;if_pile_boundary(ElemTable,contour_height)) but I (Keith) added the distinction bewteen 1 and 2 to allow future developers to distinguish between the inside and outside of a pileheight contour line, as this functionality could be useful in the future.  <a href="#a111"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a112">if_source_boundary</a> (<a class="el" href="classHashTable.html">HashTable</a> *ElemTable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns 2 if this element has Influx[0]&gt;0 and has a neighbor who has Influx[0]&lt;=0. It returns 1 if this element has Influx[0]==0 and has a neighbor who has Influx[0]!=0. It returns -1 if this element has Influx[0]&lt;0 and a neighbor with Influx[0]&gt;=0. It returns 0 otherwise. Influx[0] is a pileheight per unit time source term. Currently Influx[0] is restricted to be non-negative (a source or no source with sinks not allowed), but I (Keith) have added the extra functionality because it may be useful at a future date. The intended use if if(EmTemp-&gt;if_source_boundary(ElemTable)), but the distinction between 1 and 2 allows futuredevelopers to distinguish between the strictly inside and strictly outside of an area with a flux source term.  <a href="#a112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a113">if_first_buffer_boundary</a> (<a class="el" href="classHashTable.html">HashTable</a> *ElemTable, double contour_height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight&lt;contour_height)&amp;&amp;(Influx[0]==0)) and adjacent to the pile. It is "N" elements wide, and the "N" element width is increased one element at a time. This function returns 2 if this element a member of the innermost boundary of the buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be members of the innermost boundary of the buffer layer  <a href="#a113"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a114">if_next_buffer_boundary</a> (<a class="el" href="classHashTable.html">HashTable</a> *ElemTable, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, double contour_height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight&lt;contour_height)&amp;&amp;(Influx[0]==0)) and adjacent to the pile. It is "N" elements wide, and the "N" element width is increased one element at a time. This function returns 2 if this element a member of the boundary of the buffer that is one element wider than the current buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be in the next buffer boundary  <a href="#a114"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a115">get_counted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for debugging only  <a href="#a115"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a116">put_counted</a> (int countedvalue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for debugging only  <a href="#a116"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a117">get_ithelem</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong.  <a href="#a117"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a118">put_ithelem</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong.  <a href="#a118"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a119">get_effect_bedfrict</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped  <a href="#a119"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a120">get_effect_kactxy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect_kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows  <a href="#a120"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a121">get_Awet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function returns the stored value of Awet, Awet is the fraction of an element's area that is wet (has material), 0.0&lt;=Awet&lt;=1.0, where there is no flow (pileheight &lt; GEOFLOW_TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007  <a href="#a121"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a122">put_Awet</a> (double Awet_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function assigns a value to Awet, Awet is the fraction of an element's area that is wet (has material), 0.0&lt;=Awet&lt;=1.0, where there is no flow (pileheight &lt; GEOFLOW_TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007  <a href="#a122"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a123">get_Swet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function returns the stored value of Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight &lt; GEOFLOW_TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0&lt;=Swet&lt;=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is called in <a class="el" href="constant_8h.html#a21">step.C</a>. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007  <a href="#a123"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a124">put_Swet</a> (double Swet_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function assigns a value to Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight &lt; GEOFLOW_TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0&lt;=Swet&lt;=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is called in <a class="el" href="constant_8h.html#a21">step.C</a>. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007  <a href="#a124"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a125">get_iwetnode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function returns the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its "wettest" node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight &lt; GEOFLOW_TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007  <a href="#a125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a126">put_iwetnode</a> (int iwetnode_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function sets the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its "wettest" node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight &lt; GEOFLOW_TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007  <a href="#a126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a127">get_drypoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function returns the array "drypoint". drypoint[0] is the local x-coordinate, and drypoint[1] the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007  <a href="#a127"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a128">put_drypoint</a> (double *drypoint_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this inline member function sets the values of the array "drypoint". drypoint[0] is the local x-coordinate, and drypoint[1] the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007  <a href="#a128"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a129">calc_wet_dry_orient</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the element member function <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> determines the orientation of the dryline and which side of it is wet, the wet fraction (Swet) of a partially wet edge, the location of the drypoint, it does NOT calculate the wet area (Awet)... these quantities are used in the adjustment of fluxes in partially wet elements. <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is not coded for generic element orientation, i.e. the positive_x_side must be side 1. Keith wrote this may 2007  <a href="#a129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a130">calc_elem_edge_wet_fraction</a> (int ineigh, int ifusewholeside)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Element member function <a class="el" href="classElement.html#a130">calc_elem_edge_wet_fraction()</a> returns the "how much of this is wet" fraction of side that this element shares with its ineigh-th neighboring element . This fraction is used to determine wether or not to "zero" the state variables used to compute physical fluxes through a "dry" side. Keith wrote this function may 2007.  <a href="#a130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a131">calc_elem_edge_wetness_factor</a> (int ineigh, double dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function relaxes the zeroing of fluxes through cell edges that are completely dry at the beginning of the timestep, as indicated by <a class="el" href="classElement.html#a130">calc_elem_edge_wet_fraction()</a>, but will be at least partly wet by the end of the timestep... Keith wrote this function June 2007  <a href="#a131"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#a132">convect_dryline</a> (double VxVy[2], double dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Element member function <a class="el" href="classElement.html#a132">convect_dryline()</a> calculates the coordinates of the "drypoint" in the element's local coordinate system. This is used to determine the location of the wet-dry front (or dryline) inside this element, which in turn is used (in conjunction with the location of "iwetnode" - which indicates which side of the dryline is wet) to determine the fraction of its total area that is wet (Awet). Awet is then returned by the function. Keith wrote this function may 2007.  <a href="#a132"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r0">myprocess</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">myprocess is id of the process(or) that owns this element  <a href="#r0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r1">generation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generation is how many times this element has been refined, currently -8&lt;=generation&lt;=3, a negative generation number means it has been unrefined beyond the orignal coarse mesh, a positive generation number means it has been refined (is smaller than the original element size)  <a href="#r1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r2">opposite_brother_flag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">opposite_brother_flag indicate if we have the correct key for the non-neighbor brother (0:= don't have info, 1:= have info)  <a href="#r2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r3">material</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the material flag indicates which material should be used to set this element's bed friction, this is for when a GIS material map, specifying different materials in different spatial regions of the map, the GIS material map is a non standard grass map format that Laercio Namikawa developed, it's stored in the "cats" folder under a grass mapset directory  <a href="#r3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r4">lb_weight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the load-balancing weight  <a href="#r4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r5">lb_key</a> [<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the key for load-balancing, if there is no constrained node, it is the element key, otherwise it is a construct of the element "bunch", keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r6">key</a> [<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the element key, which has the same value as the key of the element's bubble node, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r7">node_key</a> [8][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this array holds the first 8 (0-&gt;7) of this element's nodes' keys, the n9th (8 out of 0-&gt;8) node is the bubble node it's key is not stored separately since it has the same key as the element, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r8">neighbor</a> [8][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this array holds the keys of this element's 8 neighbors (2 neigbors to a side if the neighbor is more refined than this element, otherwise the two neighbor keys for that side are identical in value), having 8 neighbors is an outcome of the 1 irregularity refinement rule, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r9">father</a> [<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the key of the father it is assigned in the <a class="el" href="hadpt_8C.html#a5">refine()</a> and unrefine_elements() functions  <a href="#r9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r10">son</a> [4][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this array holds the keys of this element's 4 sons, it is only used temporarily in the refinement process before the father (this element) is deleted, there's was an old comment "garantee ccw" associated with this variable, I don't know what it means, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r11">neigh_proc</a> [8]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this array holds the process(or) id of this element's 8 neighbors, there can be 8 neighbors because of the 1 irregularity rule. neigh_proc[4:7] != -2 only if it has 2 neighbors on that side, a value of -1 for neigh_proc means that this edge is a boundary of the computational domain.  <a href="#r11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r12">order</a> [5]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi, all finite volume "elements"/cells are piece wise constant, but I believe this is actually used in the DG (Discontinuous Galerkin) version of titan  <a href="#r12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r13">neigh_gen</a> [8]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">neigh_gen is an array that holds the "generation" (how refined it is) of this element's 8 neighbors, there can-be/are 2 neighbors to a side because of the 1 irregularity rule  <a href="#r13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structBC.html">BC</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r14">bcptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to the boundary condition class, if this element is not a boundary element the pointer holds the NULL value  <a href="#r14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r15">ndof</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the number of degrees of freedom, since Titan is a finite difference/volume code, ndof is afeapi legacy, but the DG (Discontinuous Galerkin) version of Titan actually uses this  <a href="#r15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r16">no_of_eqns</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi, it is not used, but do not remove it, it could cause problems if you do  <a href="#r16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r17">el_error</a> [<a class="el" href="constant_8h.html#a16">EQUATIONS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this holds the "error" in the element's solution, which is useful in determining refinement, this may actually be afeapi legacy  <a href="#r17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r18">el_solution</a> [<a class="el" href="constant_8h.html#a16">EQUATIONS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this holds the element solution, I believe this is legacy afeapi  <a href="#r18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r19">refined</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">refined is a flag that usually has the value 0, but will be 1 if the element has been refined this iteration (used to enforce the 1 irregularity rule), or have the value "GHOST" if it is a ghost cell, refined and ghost cells are not updated, see <a class="el" href="constant_8h.html">constant.h</a> for the value of GHOST  <a href="#r19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r20">adapted</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a> and <a class="el" href="classElement.html#a36">put_refined_flag()</a> with adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a> and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a>, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be.  <a href="#r20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r21">which_son</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">which_son holds the value of which son this element is, which of the 4 squares that makes up the father elements square.  <a href="#r21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r22">new_old</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the new_old flag is used in mesh adaptation and repartitioning  <a href="#r22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r23">brothers</a> [4][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this array holds the keys of this element's 4 brothers (an element is considered to be it's own brother), this information is used during mesh unrefinement (combining the 4 brothers to make their father), keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables  <a href="#r23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r24">coord</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">coord holds the coordinates of the elements cell center, these are the same as the coordinates of the element's bubble node's  <a href="#r24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r25">elm_loc</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">elm_loc is used in unrefining beyond the original coarse mesh  <a href="#r25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r26">send</a> [8]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is afeapi legacy  <a href="#r26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r27">recv</a> [8]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is afeapi legacy  <a href="#r27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r28">state_vars</a> [<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">state_vars is an array that holds the current state variables: h, hVx, and hVy  <a href="#r28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r29">prev_state_vars</a> [<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">these are the values of the state variables from before the predictor step  <a href="#r29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r30">d_state_vars</a> [<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a> *<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">these are the spatial (x and y) derivatives of the state variables: (dh/dx, dhVx/dx, dhVy/dx, dh/dy, dhVx/dy, dhVy/dy)  <a href="#r30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r31">shortspeed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the short speed is the speed computed as: shortspeed=|v|=|dhv/dh|=|v*dh/dh+h*dv/dh|=|v+h*dv/dh| which goes to |v| in the limit of h-&gt;0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name "shortspeed" but it is not accurate when the pile is tall, that is when h*dv/dh is large, this is the value from the previous iteration (so there is lagging when using the shortspeed, but this should still be much more accurate than hV/h when h-&gt;0. Keith implemented this in late summer 2006,  <a href="#r31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r32">dx</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">length of the element in the global x and y directions: dx and dy  <a href="#r32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r33">positive_x_side</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for structured grid, tells which side is the positive x direction  <a href="#r33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r34">eigenvxymax</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum x and y direction wavespeeds for this element, wavespeeds are eigenvalues of the flux jacobians  <a href="#r34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r35">coefABCD</a> [4]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi not used in titan  <a href="#r35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r36">kactxy</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">k active/passive in the x and y directions, k active/passive is part of the coulomb friction model for Granular Flows  <a href="#r36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r37">elevation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">terrain elevation at this elements center/bubble node  <a href="#r37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r38">zeta</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">terrain slope in the global x and y directions  <a href="#r38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r39">curvature</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation.  <a href="#r39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r40">gravity</a> [3]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the gravity vector in local x,y,z coordinates (z is normal to the terrain surface, the projections of the x and y local directions onto a horizontal plane are aligned with the global x and y directions)  <a href="#r40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r41">d_gravity</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the spatial (x and y) derivatives of the local z component of the gravity vector  <a href="#r41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r42">lam</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">legacy titan not really used, lam :=p_{bed}/(rho*g_z*h)  <a href="#r42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r43">stoppedflags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">part of the new stopping criteria under development, has a 0 if flow is not stopped, has the value 1 if it should not be sliding but should be slumping, has the value 2 if it should neither be sliding or slumping (it should be completely stopped), I (Keith) am rather confident in the criteria used to set this the problem is determining what to do about it after you know the flow SHOULD be stopped  <a href="#r43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r44">effect_bedfrict</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped  <a href="#r44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r45">effect_tanbedfrict</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus effect_tanbedfrict holds the value of the effective bed friction angle  <a href="#r45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r46">effect_kactxy</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect_kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows  <a href="#r46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r47">Influx</a> [3]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">extrusion flux rate for this timestep for this element, used when having material flow out of the ground, a volume per unit area influx rate source term  <a href="#r47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r48">counted</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r49">ithelem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong.  <a href="#r49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r50">iwetnode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the node number {0,1,..,7} of this element's "most wet node", this dictates both the orientation of the "dryline" and which side of it is wet. The "dryline" is the line that divides a partially wetted element into a dry part and a wet part, for the sake of simplicity only 4 orientations are allowed, horizontal, vertical, parallel to either diagonal of the element. If the iwetnode is an edge node of this element then the dryline is parallel to the edge the element is on, if the iwetnode is a corner node of this element then dryline is parallel to the diagonal of the element that the iwetnode is not on. Which side of the dryline is wet is the same side in which the iwetnode resides (and is determined each timestep based soley on which of the elements neighbors currently have pile height greater than GEOFLOW_TINY)... as such iwetnode can be thought of as the MOST WET NODE of the element. Having iwetnode==8 indicates that the element is uniformly wet if this element's pile height is greater than GEOFLOW_TINY or is uniformly dry if pileheight is less than or equal to GEOFLOW_TINY.  <a href="#r50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r51">Awet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Awet is the ratio of this element's wet area to total area (always between 0 and 1 inclusive) when taken together with iwetnode, this uniquely determines the exact placement of the "dryline" within the current element. Awet is initially set by source placement to be either 0 (no material) or 1 (material) and is updated by the corrector part of the predictor-corrector method, the new value is determined by where the dry line has been convected to over this timestep. Keith wrote this May 2007.  <a href="#r51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r52">drypoint</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">center point of the "dryline", x and y coordinates value ranges between -0.5 and 0.5 with 0 being the center of the element, since the wet/dry interface is taken to be a non-deforming non rotating (within the timestep) "dryline" convecting a single point on the dryline (called the drypoint) is sufficient to determine the new placement of the dryline which allows us to update Awet... Keith wrote this May 2007.  <a href="#r52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#r53">Swet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when an element edge is partially wet and partially dry... Swet is the fraction of a cell edge that is partially wet, because it can only be horizontal, vertical, or parallel to either diagonal, all of one element's partially wet sides are have the same fraction of wetness. The state variables (used to compute the physical fluxes) at the element/cell edge are adjusted to be the weighted by wetness average over an element/cell edge. As such physical fluxes through completely dry edges of partially wet elements/cells are zeroed, while physical fluxes through completely wet edges are left unchanged. Because of the definition as "wetness weighted average" physical fluxes through a partially wet edge shared with a neighbor of the same generation is also left left unchanged but, when a partially wet edge is shared with two more refined neighbors the total mass and momentum at the edge is split between the two neighbors in proportion to how much of their boundary shared with this element is wet. This "scaling" of the physical fluxes is the "adjustment of fluxes in partially wetted cells" facet of our multifaceted thin-layer problem mitigation approach. And it has been shown to significantly reduce the area covered by a thin layer of material. Keith wrote this May 2007.  <a href="#r53"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n0">HashTable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n1">AssertMeshErrorFree</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int numprocs, int myid, double loc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG.  <a href="#n1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n2">ElemBackgroundCheck</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, unsigned *debugkey, FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">investigate an Element, question his "friends and family" about him.  <a href="#n2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n3">ElemBackgroundCheck2</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, void *EmDebug, FILE *fp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n4">NodeBackgroundCheck</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, unsigned *debugkey, FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">investigate a <a class="el" href="classNode.html">Node</a> question his "friends and family" about him.  <a href="#n4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n5">delete_oldsons</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int myid, void *EmFather)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n6">refine_neigh_update</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int numprocs, int myid, void *RefinedList, <a class="el" href="structTimeProps.html">TimeProps</a> *timeprops_ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n7">unrefine_neigh_update</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int myid, void *NewFatherList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n8">unrefine_interp_neigh_update</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int nump, int myid, void *OtherProcUpdate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n9">BSFC_combine_elements</a> (int side, <a class="el" href="classElement.html">Element</a> *EmTemp, <a class="el" href="classHashTable.html">HashTable</a> *HT_Elem_Ptr, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int destination_proc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function figures out how to "bunch" together elements that cannot be put on different processors because of a constrained node, B stands for bunch SFC stands for space filling curve  <a href="#n9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n10">Pack_element</a> (void *sendel, <a class="el" href="structElemPack.html">ElemPack</a> *elem, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int destination_proc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classElement.html#n10">Pack_element()</a> is a friend function of the Element and <a class="el" href="classNode.html">Node</a> classes that packs relevant information from an element "sendel" into a smaller data structure (<a class="el" href="structElemPack.html">ElemPack</a>) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning.  <a href="#n10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n11">destroy_element</a> (void *r_element, <a class="el" href="classHashTable.html">HashTable</a> *HT_Elem_Ptr, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int target_pro, <a class="el" href="structElementLink.html">ELinkPtr</a> *EL_head)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n12">create_element</a> (<a class="el" href="structElemPack.html">ElemPack</a> *elem2, <a class="el" href="classHashTable.html">HashTable</a> *HT_Elem_Ptr, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int myid, double *e_error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classElement.html#n12">create_element()</a> is a friend function of the Element and <a class="el" href="classNode.html">Node</a> classes. After receiving an <a class="el" href="structElemPack.html">ElemPack</a>, <a class="el" href="classElement.html#n12">create_element()</a> instances a new element, calls <a class="el" href="classElement.html#n13">construct_el()</a> to transfer data from <a class="el" href="structElemPack.html">ElemPack</a> to the new element, and inserts the new element into the Hashtable. Don't call this if s_flag is 0 (original repartitioning scheme)  <a href="#n12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html#n13">construct_el</a> (<a class="el" href="classElement.html">Element</a> *newelement, <a class="el" href="structElemPack.html">ElemPack</a> *elem2, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int myid, double *e_error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct_el is a friend function of the Element class that fills an element with information it receives in a variable of the <a class="el" href="structElemPack.html">ElemPack</a> class from an MPI call  <a href="#n13"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The Element class is a data structure designed to hold all the information need for an h (cell edge length) p (polynomial order) adaptive finite element. Titan doesn't use p adaptation because it is a finite difference/volume code, hence many of the members are legacy from afeapi (adaptive finite element application programmers interface) which serves as the core of titan. There is a seperate Discontinuous Galerkin Method (finite elements + finite volumes) version of titan and the polynomial information is not legacy there. However in this version of Titan elements function simply as finite volume cells. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="Element::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::Element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
default constructor, does nothing except set stoppedflags=2, this should never be used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="Element::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::Element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>nodekeys</em>[][KEYLENGTH], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>neigh</em>[][KEYLENGTH], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_pro</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structBC.html">BC</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>elm_loc_in</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>pile_height</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>opposite_brother</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor that creates an original element when funky is read in 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="Element::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::Element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>nodekeys</em>[][KEYLENGTH], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>neigh</em>[][KEYLENGTH], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_pro</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structBC.html">BC</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>gen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>elm_loc_in</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>gen_neigh</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fthTemp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>coord_in</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iwetnodefather</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>Awetfather</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>drypoint_in</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor that creates a son element from its father during refinement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="Element::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::Element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sons</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor that creates a father element from its four sons during unrefinement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="Element::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::Element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor that creates/restores a saved element during restart 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="Element::~Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Element::~<a class="el" href="classElement.html">Element</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
destructor that does nothing except delete boundary condition pointer 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a96" doxytag="Element::calc_d_gravity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_d_gravity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>El_Table</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the (global) x and y derivatives of the local z component of gravity as an approximation of the local derivatives, it wouldn't be that difficult to correct incorporating the terrain slopes in the calculation it is calculated in the creation of a father element, after mesh refinement and, during a restart. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a78" doxytag="Element::calc_edge_states"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_edge_states           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>order_flag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>outflow</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function (indirectly) calculates the fluxes that will be used to perform the finite volume corrector step and stores them in element edge nodes, indirectly because it calls other functions to calculate the analytical fluxes and then calls another function to compute the riemann fluxes from the analytical fluxes. Talk to me (Keith) before you modify this, as I am fairly certain that it is now completely bug free and parts of it can be slightly confusing. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a130" doxytag="Element::calc_elem_edge_wet_fraction"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::calc_elem_edge_wet_fraction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>ineigh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ifusewholeside</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The Element member function <a class="el" href="classElement.html#a130">calc_elem_edge_wet_fraction()</a> returns the "how much of this is wet" fraction of side that this element shares with its ineigh-th neighboring element . This fraction is used to determine wether or not to "zero" the state variables used to compute physical fluxes through a "dry" side. Keith wrote this function may 2007. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a131" doxytag="Element::calc_elem_edge_wetness_factor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::calc_elem_edge_wetness_factor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>ineigh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function relaxes the zeroing of fluxes through cell edges that are completely dry at the beginning of the timestep, as indicated by <a class="el" href="classElement.html#a130">calc_elem_edge_wet_fraction()</a>, but will be at least partly wet by the end of the timestep... Keith wrote this function June 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a110" doxytag="Element::calc_flux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_flux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFluxProps.html">FluxProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fluxprops</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structTimeProps.html">TimeProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeprops</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the extrusion (out of the ground) fluxes for this elements 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a94" doxytag="Element::calc_flux_balance"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_flux_balance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>NodeTable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is called in <a class="el" href="constant_8h.html#a21">element_weight.C</a>, it is used in computing the load balancing weight 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a97" doxytag="Element::calc_gravity_vector"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_gravity_vector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>matprops_ptr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the gravity vector in local coordinates 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a81" doxytag="Element::calc_shortspeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_shortspeed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>inv_dt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the shortspeed,also known as the L'Hospital (pronounced Loo-pee-tal, you can look up L'Hospital's rule in almost any calculus book if you so desire). here is a brief explanation of shortspeed: shortspeed=|v|=|dhv/dh|=|v*dh/dh+h*dv/dh|=|v+h*dv/dh| which goes to |v| in the limit of h-&gt;0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name "shortspeed" but it is not accurate when the pile is tall, that is when h*dv/dh is large, Keith implemented this in late summer 2006 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a105" doxytag="Element::calc_stop_crit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_stop_crit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is part of the experimental _LOCAL_ (not Bin Yu's) stopping criteria which has not yet been validated, I (Keith) have faith in the criteria, but enforcing the stopped after it has been decided that it needs to stop still needs some work. the only place this function is called is in <a class="el" href="constant_8h.html#a21">get_coef_and_eigen.C</a> immediately after k_active/passive and in <a class="el" href="constant_8h.html#a21">init_piles.C</a> when computing the initial volume that "should already be" deposited. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a95" doxytag="Element::calc_topo_data"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_topo_data           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>matprops_ptr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates topographic data, it calls GIS commands to compute elevation, slopes, and curvatures from the GIS map and scales them appropriately 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a129" doxytag="Element::calc_wet_dry_orient"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_wet_dry_orient           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>El_Table</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the element member function <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> determines the orientation of the dryline and which side of it is wet, the wet fraction (Swet) of a partially wet edge, the location of the drypoint, it does NOT calculate the wet area (Awet)... these quantities are used in the adjustment of fluxes in partially wet elements. <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is not coded for generic element orientation, i.e. the positive_x_side must be side 1. Keith wrote this may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="Element::calc_which_son"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calc_which_son           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the which_son flag for the original (or restored in case of a restart) element. It also calculates which son of the grandfather element the father is durring unrefinement. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a73" doxytag="Element::calculate_dx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::calculate_dx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>NodeTable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the lengths of the element in the (global) x and y directions 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a100" doxytag="Element::change_neigh_info"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::change_neigh_info           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>fth_key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>ng_key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>neworder</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ng_gen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>fth_proc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function updates this elements neighbor info when one of its neighbors has been unrefined 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="Element::change_neighbor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::change_neighbor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>newneighbs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>which_side</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
call this function after this element's neighbor(s) have been refined, proc is processor id for neighbor[which_side+4] 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="Element::change_neighbor_process"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::change_neighbor_process           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>newp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is called during repartitioning when one of an element's neighbors is sent to another processor 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a99" doxytag="Element::check_unrefinement"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::check_unrefinement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>target</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is defined in <a class="el" href="constant_8h.html#a21">unrefine.C</a>, it is also called in that file and no where else, it prevents refinement when one or more of the brothers does not belong to this processor 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a132" doxytag="Element::convect_dryline"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::convect_dryline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>VxVy</em>[2], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The Element member function <a class="el" href="classElement.html#a132">convect_dryline()</a> calculates the coordinates of the "drypoint" in the element's local coordinate system. This is used to determine the location of the wet-dry front (or dryline) inside this element, which in turn is used (in conjunction with the location of "iwetnode" - which indicates which side of the dryline is wet) to determine the fraction of its total area that is wet (Awet). Awet is then returned by the function. Keith wrote this function may 2007. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="Element::copy_key_to_lb_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::copy_key_to_lb_key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function copies the elmenent key to the load balancing key 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a80" doxytag="Element::correct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::correct           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFluxProps.html">FluxProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fluxprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structTimeProps.html">TimeProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>forceint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>forcebed</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>eroded</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>deposited</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function performs the corrector update, in the predictor (finite difference) corrector (finite volume) timestepping that titan uses. Actually this function passes values to a short fortran subroutine named "correct_" that performs the calculations. The "correct_" fortran subroutine should be torn out and the guts rewritten in C++ here. That may make it into this release if there is time, otherwise expect it in the next release 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a88" doxytag="Element::determine_refinement"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::determine_refinement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is titan legacy code it is defined in <a class="el" href="constant_8h.html#a21">Element2.C</a> but is not called anywhere 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a84" doxytag="Element::eval_velocity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::eval_velocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>xoffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>yoffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>VxVy</em>[2]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function computes the velocity, either V=hV/h or shortspeed in the direction of hV/h, if the pile is short, that is h is less than the defined (nondimensional) value of GEOFLOW_SHORT, see <a class="el" href="geoflow_8h.html">geoflow.h</a>, it chooses the speed to be min(|hV/h|,shortspeed) if h is greater than GEOFLOW_SHORT it chooses hV/h regardless of which one is smaller. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a98" doxytag="Element::find_brothers"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::find_brothers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>NewFatherList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>OtherProcUpdate</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is defined in <a class="el" href="constant_8h.html#a21">unrefine.C</a>, it is also called in that file, it finds this element's brothers 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="Element::find_opposite_brother"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::find_opposite_brother           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function computes searches for an element's brother, i.e. the brother (son of the same father) that is located diagonally from it, to get the brother information requires that atleast one of this element's neighboring brothers is on this process in order to get information onthe brother that is not a neighbor 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="Element::find_positive_x_side"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::find_positive_x_side           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function computes which side of the element is facing the positive x direction 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="Element::get_adapted_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_adapted_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a> and <a class="el" href="classElement.html#a36">put_refined_flag()</a> with adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a> and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a>, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a121" doxytag="Element::get_Awet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_Awet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function returns the stored value of Awet, Awet is the fraction of an element's area that is wet (has material), 0.0&lt;=Awet&lt;=1.0, where there is no flow (pileheight &lt; GEOFLOW_TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="Element::get_bcptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structBC.html">BC</a> * Element::get_bcptr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the pointer to this element's array of boundary conditions, not really all that important in titan since any flow that goes beyond the boundary of the GIS map leaves the computational domain. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="Element::get_brothers"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::get_brothers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the keys of an element's 4 brothers (an element is considered to be it's own brother) this is used during unrefinement to combine 4 brothers into their father element 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a85" doxytag="Element::get_coefABCD"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double* Element::get_coefABCD           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi code, it is never called in the finite difference/volume version of titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a103" doxytag="Element::get_coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_coord           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the precomputed and scaled coordinates of this element (which would be the same as its bubble node's coordinates) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a115" doxytag="Element::get_counted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_counted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
for debugging only 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a91" doxytag="Element::get_curvature"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_curvature           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the precomputed local terrain curvature. Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a90" doxytag="Element::get_d_gravity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_d_gravity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the precomputed derivatives of the z component of gravity, this is a purely terrain geometry dependant derivative, that is little diffent than curvature 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a66" doxytag="Element::get_d_state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_d_state_vars           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the vector of x and y derivatives of state variables, all the x derivatives come first as a group followed by the y derivatives as a group 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a127" doxytag="Element::get_drypoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_drypoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function returns the array "drypoint". drypoint[0] is the local x-coordinate, and drypoint[1] the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="Element::get_dx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_dx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the length of an element in the x and y directions 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a119" doxytag="Element::get_effect_bedfrict"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_effect_bedfrict           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a120" doxytag="Element::get_effect_kactxy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_effect_kactxy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect_kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a79" doxytag="Element::get_eigenvxymax"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_eigenvxymax           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the maximum x and y direction wavespeeds which are the eigenvalues of the flux jacobian 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="Element::get_el_err"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double* Element::get_el_err           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the function returns the vector of element "error", element error is used to say when a function should be refined 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="Element::get_el_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_el_error           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the element's error vector 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="Element::get_el_solution"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_el_solution           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the element's solution vector 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a89" doxytag="Element::get_elevation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_elevation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the precomputed elevation 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a101" doxytag="Element::get_elm_loc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Element::get_elm_loc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the elm_loc variable, which is used in unrefinement beyond the initial coarse grid 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="Element::get_gen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_gen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns this elements generation, that is how many times it's been refined -8&lt;=generation&lt;=+3, negative means courser than original mesh 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a87" doxytag="Element::get_gravity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_gravity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the already computed gravity vector in local coordinates, the local z direction is normal to the terrain surface and the projection of the local x and y components into the horizontal plane are aligned with global x (UTM E) and y (UTM N) directions. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a109" doxytag="Element::get_influx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_influx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the stored value of the extrusion (out of the ground) fluxes in this element 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a117" doxytag="Element::get_ithelem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_ithelem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a125" doxytag="Element::get_iwetnode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_iwetnode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function returns the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its "wettest" node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight &lt; GEOFLOW_TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a86" doxytag="Element::get_kactxy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_kactxy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the already calculated value(s) of k active passive, which comes from using th Coulomb friction model of granular flows (this is problem specific to titan and thus does not appear in the standard afeapi code) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a93" doxytag="Element::get_lam"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_lam           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is never called in the finite difference/volume version of titan, it is legacy (I believe titan rather than afeapi legacy code) that probably should be removed 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a56" doxytag="Element::get_lb_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::get_lb_key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the load balancing key, which is used during repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="Element::get_lb_weight"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_lb_weight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the Load Balancing weight of an element which is used in repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="Element::get_material"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_material           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the integer material flag for this element, needed for use of a material map which allows bedfriction to vary with physical position 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="Element::get_myprocess"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_myprocess           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the process(or) id of an element, it says which processor owns the element 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="Element::get_neigh_gen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Element::get_neigh_gen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns an array holding the generation of all 8 of this element's neighbors 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="Element::get_neigh_proc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Element::get_neigh_proc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the array of processor ids for this element's 8 neighbors 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="Element::get_neighbors"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::get_neighbors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the array of keys for this element's 8 neighbors 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="Element::get_nelb_icon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::get_nelb_icon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is afeapi legacy it is not called anywhere in the finite difference/volume version of titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="Element::get_new_old"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_new_old           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the vlaue of the new_old flag which is used during mesh adaptation and repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="Element::get_no_of_dof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_no_of_dof           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
not used in finite difference/volume version of titan, legacy, returns number of degrees of freedom, used is global stiffness matrices 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="Element::get_opposite_brother_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_opposite_brother_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the opposite_brother_flag, I (Keith) am not entirely sure what this flag is for, but I know that it is used in repartioning, see BSFC_combine_elements, I think it says if an element has an opposite brother, that is, can it be combined with it's brothers to form their father 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="Element::get_order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Element::get_order           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="Element::get_positive_x_side"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_positive_x_side           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns which side of the element is facing the positive x direction 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a72" doxytag="Element::get_prev_state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_prev_state_vars           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns a vector containing the previous state variables, previous mean beginning of timestep before the finite difference predictor halfstep 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="Element::get_recv_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_recv_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function isn't being called anywhere, which means it is afeapi legacy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="Element::get_refined_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_refined_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>. refined can be permanently set to GHOST (defined in <a class="el" href="constant_8h.html">constant.h</a>) or zero or temporarily set to 1 (with in the refinement and unrefinement routines), Keith believes it's not being unset (set from 1 to 0) when it should be after the refinement is done. Keith believes the problem is located within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within it, recurse down. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="Element::get_send_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_send_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function isn't being called anywhere, which means it is afeapi legacy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a82" doxytag="Element::get_shortspeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_shortspeed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the already computed shortspeed 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a71" doxytag="Element::get_slopes"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::get_slopes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function computes the x and y derivatives of the state variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="Element::get_state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_state_vars           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the vector of state variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="Element::get_stiffness"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::get_stiffness           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
legacy afeapi function prototype, this function does not exist in the finite difference/volume version of Titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a107" doxytag="Element::get_stoppedflags"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_stoppedflags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the value of "stoppedflags" 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a123" doxytag="Element::get_Swet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Element::get_Swet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function returns the stored value of Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight &lt; GEOFLOW_TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0&lt;=Swet&lt;=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is called in <a class="el" href="constant_8h.html#a21">step.C</a>. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="Element::get_which_son"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::get_which_son           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the which_son flag, which tells the portion of the father element that this element is physically located in 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a67" doxytag="Element::get_zeta"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Element::get_zeta           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the x and y slopes of the terrain elevation 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="Element::getassoc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Element::getassoc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the array of 8 processors for the 8 neigbors of this element 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="Element::getfather"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::getfather           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
find and return what the key of this element's father element would be, very simple since the bubble node has the same key as the element, so all this function does is find which of its corner nodes will be the father element's bubble node, which it knows since it knows which_son it is. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="Element::getNode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::getNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns the address of the first of 8 (nodes 0-7) node keys in an array, the node keys are used to access the nodes through the node hashtable 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="Element::getson"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::getson           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the element keys of this element's 4 sons, used during refinement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a113" doxytag="Element::if_first_buffer_boundary"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::if_first_buffer_boundary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ElemTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>contour_height</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight&lt;contour_height)&amp;&amp;(Influx[0]==0)) and adjacent to the pile. It is "N" elements wide, and the "N" element width is increased one element at a time. This function returns 2 if this element a member of the innermost boundary of the buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be members of the innermost boundary of the buffer layer 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a114" doxytag="Element::if_next_buffer_boundary"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::if_next_buffer_boundary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ElemTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>contour_height</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the buffer layer is a layer of refined cells on the outside of the pile, i.e. ((pileheight&lt;contour_height)&amp;&amp;(Influx[0]==0)) and adjacent to the pile. It is "N" elements wide, and the "N" element width is increased one element at a time. This function returns 2 if this element a member of the boundary of the buffer that is one element wider than the current buffer and does not need to be adapted. It returns 1 if this elment needs to be refined and some of its sons will be in the next buffer boundary 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a111" doxytag="Element::if_pile_boundary"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::if_pile_boundary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ElemTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>contour_height</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns 2 if this element contains pileheight&gt;=contour_height and has a neighbor who contains pileheight&lt;contour_height. It returns 1 if this element contains pileheight&lt;contour_height and has a neighbor who contains pileheight&gt;=contour_height. It returns 0 otherwise. The intended use if if(EmTemp-&gt;if_pile_boundary(ElemTable,contour_height)) but I (Keith) added the distinction bewteen 1 and 2 to allow future developers to distinguish between the inside and outside of a pileheight contour line, as this functionality could be useful in the future. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a112" doxytag="Element::if_source_boundary"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::if_source_boundary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ElemTable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns 2 if this element has Influx[0]&gt;0 and has a neighbor who has Influx[0]&lt;=0. It returns 1 if this element has Influx[0]==0 and has a neighbor who has Influx[0]!=0. It returns -1 if this element has Influx[0]&lt;0 and a neighbor with Influx[0]&gt;=0. It returns 0 otherwise. Influx[0] is a pileheight per unit time source term. Currently Influx[0] is restricted to be non-negative (a source or no source with sinks not allowed), but I (Keith) have added the extra functionality because it may be useful at a future date. The intended use if if(EmTemp-&gt;if_source_boundary(ElemTable)), but the distinction between 1 and 2 allows futuredevelopers to distinguish between the strictly inside and strictly outside of an area with a flux source term. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a74" doxytag="Element::insert_coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::insert_coord           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>NodeTable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function assigns the element's coordinates to be its bubble node's coordinates 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="Element::pass_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Element::pass_key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns address of element (same as bubble node, node 8 out of 0-&gt;8) hashtable key 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="Element::put_adapted_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_adapted_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>new_adapted_status</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>. The magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. These values are defined in <a class="el" href="constant_8h.html">constant.h</a>. The NEWSON value has allowed Keith to provide one time only immunity from unrefinement to recently refined elements, after which the "adapted" flag is resent to NOTRECADAPTED. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a122" doxytag="Element::put_Awet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_Awet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Awet_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function assigns a value to Awet, Awet is the fraction of an element's area that is wet (has material), 0.0&lt;=Awet&lt;=1.0, where there is no flow (pileheight &lt; GEOFLOW_TINY) Awet=0, in the interior of the Flow Awet=1.0, at the boundary of the flow, elements will be PARTIALLY WET (i.e. where the element SHOULD be separated into a dry part and wet part), Awet is the fraction that should be wet, Awet is updated during the corrector part of the (finite difference)predictor-(finite volume)corrector update. Fluxes are adjusted to acount for how wet/dry an edge of an element is. Keith wrote this may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a104" doxytag="Element::put_coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_coord           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>coord_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores the coordinates of this element (which would be the same as its bubble node's coordinates) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a116" doxytag="Element::put_counted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_counted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>countedvalue</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
for debugging only 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a128" doxytag="Element::put_drypoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_drypoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drypoint_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function sets the values of the array "drypoint". drypoint[0] is the local x-coordinate, and drypoint[1] the local y-coordinate of its namesake, which is used to specify the position of the flow-front (or dryline) inside a given element. The position of the dryline along with iwetnode is used to determine Awet, i.e. which fraction of a partially wet element is wet (contains material). Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a102" doxytag="Element::put_elm_loc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_elm_loc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>int_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the elm_loc variable, which is used in unrefinement beyond the initial coarse grid 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="Element::put_father"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_father           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fatherin</em>[KEYLENGTH]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
store the father's key in the "father" variable, the "father's" key is zero until an element has been unrefined (and has not yet been deleted) it is only used in unrefinement. The <a class="el" href="classElement.html#a22">getfather()</a> member function computes the father key from "which_son" and it's nodes and is totally unrelated to the father variable. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="Element::put_gen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_gen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set the generation (number of times it's been refined -8&lt;=gen&lt;=+3) of this "element"/cell 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="Element::put_height"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_height           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pile_height</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function assigns a specified value to the pileheight and zeros to the momentums and shortspeed 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="Element::put_height_mom"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_height_mom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>pile_height</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>xmom</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ymom</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function initializes pileheight, momentums and shortspeed (also known as the L'Hosptial speed see calc_shortspeed for an explanation),this function is called in <a class="el" href="constant_8h.html#a21">init_piles.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a118" doxytag="Element::put_ithelem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_ithelem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a126" doxytag="Element::put_iwetnode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_iwetnode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iwetnode_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function sets the value of iwetnode. iwetnode is an integer that defines which of an element's 9 nodes is its "wettest" node (wet elements are those containing material). In the interior of a flow, iwetnode=8 (the center node), indicating a fully wet element. Outside of a flow (where an element and all it's neighbors have pileheight &lt; GEOFLOW_TINY), iwetnode is also 8. Along a flow boundary, partially wet elements with 1,2, or 3 wet sides can have an iwetnode other than 8. iwetnode is used to determine which side of the dryline in a partially wet element has material. Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a92" doxytag="Element::put_lam"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_lam           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lam_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the only place this function is called is in <a class="el" href="constant_8h.html#a21">move_data.C</a>, I believe it is legacy titan code and could probably be removed 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="Element::put_lb_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_lb_key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in_key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the load balancing key, which is used during repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="Element::put_lb_weight"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_lb_weight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dd_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores an element's load balancing weight, which is used during repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="Element::put_myprocess"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_myprocess           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in_proc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the process(or) id of an element, it says which processor owns the element. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="Element::put_neigh_gen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_neigh_gen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>gen</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the ith neighbor's generation to "gen" 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="Element::put_neigh_proc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_neigh_proc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>proc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores the processor id "proc" of neighbor "i" in the 8 element array of neighbor processors, use this function instead of putassoc. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="Element::put_new_old"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_new_old           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the new or old flag, it is initialized in <a class="el" href="constant_8h.html#a21">htflush.C</a> and reset during repartitioning (<a class="el" href="constant_8h.html#a21">repartition_BSFC.C</a> and <a class="el" href="constant_8h.html#a21">BSFC_update_and_send_elements.C</a>) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="Element::put_order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_order           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
afeapi legacy not used in the finite difference/volume version of Titan, but it is used in the discontinuous galerkin version (a separate more accurate less stable implementation with a lot of things in common with the finite difference/volume code) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="Element::put_recv_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_recv_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is only called in <a class="el" href="constant_8h.html#a21">htflush.C</a> to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="Element::put_refined_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_refined_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set this element's refined flag to i, can set it to normal (hasn't just been refined and isn't a ghost cell), "temporarily" set to "refined" (has just been refined so don't refine again), or say that it's a GHOST cell, see <a class="el" href="constant_8h.html">constant.h</a>, (which means you don't update it, instead you get new values from the processor that owns it and you don't refine it.) refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a>, <a class="el" href="classElement.html#a36">put_refined_flag()</a> are the partly replaced predecessors of adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a>, and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="Element::put_send_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_send_flag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is only called in <a class="el" href="constant_8h.html#a21">htflush.C</a> to initialize it to zero, I (Keith) think it is afeapi legacy that isn't being used anymore but I'm not sure about that 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a83" doxytag="Element::put_shortspeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_shortspeed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>shortspeedin</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function assigns the value passed in to shortspeed 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a106" doxytag="Element::put_stoppedflags"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_stoppedflags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>stoppedflagsin</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is used to assign a value to stopped flags, for when you don't want to compute the criteria to decide whether it's stopped or not, useful during developement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a124" doxytag="Element::put_Swet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_Swet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Swet_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this inline member function assigns a value to Swet. Swet is the fraction of the element's partially wet sides that are wet (i.e. have material). Where there is no flow (pileheight &lt; GEOFLOW_TINY), Swet=0. In the interior of a flow, Swet=1.0. At the flow boundary, elements will be PARTIALLY WET, 0.0&lt;=Swet&lt;=1.0. Due to symmetry, any element can only have 0 or 2 partially wet sides, each of which (for normalized elements) will have the same fraction that is wet, Swet. Swet for each partially wet cell is updated every time-step when <a class="el" href="classElement.html#a129">calc_wet_dry_orient()</a> is called in <a class="el" href="constant_8h.html#a21">step.C</a>. Fluxes are adjusted to account for how wet/dry an edge of an element is. Keith wrote this function may 2007 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="Element::put_which_son"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::put_which_son           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the which_son flag when a father element is refined into its 4 sons, the which_son flag tells the portion of the father element that this element is physically located in 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="Element::putassoc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::putassoc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores the processor id "a" of neighbor "i" in the 8 element array of neighbor processors, this functionality is duplicated by put_neigh_proc which is the preferred function to use (don't use this one it's legacy) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="Element::putbrothers"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::putbrothers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
when a father element is refined into 4 son elements, the 4 son elements are "brothers" (they can be recombined into the father), this function stores the keys of all four brothers in one of them, it should be called 4 times one for each brother 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="Element::putel_sq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::putel_sq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>solsq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ellsq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
stores the ?square? of the "solution" and solution error, used durring refinement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="Element::putneighbor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::putneighbor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores the key "n" of neighbor "i" in the array of the 8 keys of the neighbor keys 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="Element::putson"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::putson           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
store the keys for the four son "elements" in the father element, used temporarily during refinement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="Element::save_elem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::save_elem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fptxt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this member function saves a single element to a file with a single fwrite call, this allows the element to be recreated/restored upon restart of a simulation 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="Element::update_ndof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::update_ndof           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi code, the function is defined in <a class="el" href="constant_8h.html#a21">element2.C</a> but it is never called anywhere in the finite difference/volume version of titan because it's finite element (including Discontinuous Galerkin) specific code 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="Element::void_bcptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::void_bcptr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the pointer to an element's boundary conditions to NULL 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="Element::which_neighbor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Element::which_neighbor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>FindNeigh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
compare the FindNeigh key against the keys of this element's 8 neighbors to determine which if any neighbor FindNeigh is 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a76" doxytag="Element::xdirflux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::xdirflux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>thissideSwet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hfv</em>[3][NUM_STATE_VARS], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hrfv</em>[3][NUM_STATE_VARS]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) x direction fluxes. Keith wrote this 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a77" doxytag="Element::ydirflux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::ydirflux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dz</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>thissideSwet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hfv</em>[3][NUM_STATE_VARS], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hrfv</em>[3][NUM_STATE_VARS]</td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function calculates the analytical cell center (or cell boundary if 2nd order flux flag is checked on the gui) y direction fluxes. Keith wrote this 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a75" doxytag="Element::zdirflux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::zdirflux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>order_flag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hfv</em>[3][NUM_STATE_VARS], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>hrfv</em>[3][NUM_STATE_VARS], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmNeigh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function, based on the dir flag, chooses between calling xdirflux and ydirflux, which respectively, calculate either the x or y direction analytical cell center fluxes (or the fluxes at the the boundary if 2nd order flux option is checked on the gui). Keith wrote this. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a108" doxytag="Element::zero_influx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Element::zero_influx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function zeros the extrusion (out of the ground) fluxes in this element 
<p>
    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n1" doxytag="Element::AssertMeshErrorFree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void AssertMeshErrorFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>numprocs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>loc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n9" doxytag="Element::BSFC_combine_elements"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void BSFC_combine_elements           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmTemp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Elem_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>destination_proc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function figures out how to "bunch" together elements that cannot be put on different processors because of a constrained node, B stands for bunch SFC stands for space filling curve 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n13" doxytag="Element::construct_el"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void construct_el           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classElement.html">Element</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>newelement</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structElemPack.html">ElemPack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>e_error</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
construct_el is a friend function of the Element class that fills an element with information it receives in a variable of the <a class="el" href="structElemPack.html">ElemPack</a> class from an MPI call 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n12" doxytag="Element::create_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void create_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structElemPack.html">ElemPack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Elem_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>e_error</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classElement.html#n12">create_element()</a> is a friend function of the Element and <a class="el" href="classNode.html">Node</a> classes. After receiving an <a class="el" href="structElemPack.html">ElemPack</a>, <a class="el" href="classElement.html#n12">create_element()</a> instances a new element, calls <a class="el" href="classElement.html#n13">construct_el()</a> to transfer data from <a class="el" href="structElemPack.html">ElemPack</a> to the new element, and inserts the new element into the Hashtable. Don't call this if s_flag is 0 (original repartitioning scheme) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n5" doxytag="Element::delete_oldsons"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void delete_oldsons           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmFather</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n11" doxytag="Element::destroy_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void destroy_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>r_element</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Elem_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>target_pro</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structElementLink.html">ELinkPtr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>EL_head</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classElement.html#n11">destroy_element()</a> is a friend function of the Element and <a class="el" href="classNode.html">Node</a> classes that does the following<p>
1. Update the neighbor_proc of the neighbors 1.1 if neighbor is at the same proc----&gt;ok 1.2 if neighbor is at the target proc--&gt;done when the element is created in its new subdomain 1.3 if neighbor is at a 3rd proc-------&gt;these elements are linked for later communication<p>
2. Remove element from the hashtable<p>
3. Remove some nodes..........later not now     </td>
  </tr>
</table>
<a class="anchor" name="n2" doxytag="Element::ElemBackgroundCheck"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ElemBackgroundCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>debugkey</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
investigate an Element, question his "friends and family" about him. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n3" doxytag="Element::ElemBackgroundCheck2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ElemBackgroundCheck2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmDebug</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n0" doxytag="Element::HashTable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classHashTable.html">HashTable</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n4" doxytag="Element::NodeBackgroundCheck"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NodeBackgroundCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>debugkey</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
investigate a <a class="el" href="classNode.html">Node</a> question his "friends and family" about him. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n10" doxytag="Element::Pack_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Pack_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>sendel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structElemPack.html">ElemPack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>destination_proc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classElement.html#n10">Pack_element()</a> is a friend function of the Element and <a class="el" href="classNode.html">Node</a> classes that packs relevant information from an element "sendel" into a smaller data structure (<a class="el" href="structElemPack.html">ElemPack</a>) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n6" doxytag="Element::refine_neigh_update"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void refine_neigh_update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>numprocs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>RefinedList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structTimeProps.html">TimeProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n8" doxytag="Element::unrefine_interp_neigh_update"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void unrefine_interp_neigh_update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nump</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>OtherProcUpdate</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n7" doxytag="Element::unrefine_neigh_update"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void unrefine_neigh_update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>NewFatherList</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="r20" doxytag="Element::adapted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r20">Element::adapted</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The magnitude of the "adapted" flag indicates whether the cell is NEWSON, NEWFATHER, NOTRECADAPTED, or TOBEDELETED. A postive value indicates it's on this processor, a negative sign indicates a GHOST cell. This allowed Keith to implement one time only immunity to unrefinement for recently refined (NEWSON) elements, which allowed him to protect a refined layer of buffer cells around piles. Keith has partially replaced refined, <a class="el" href="classElement.html#a33">get_refined_flag()</a> and <a class="el" href="classElement.html#a36">put_refined_flag()</a> with adapted, <a class="el" href="classElement.html#a34">get_adapted_flag()</a> and <a class="el" href="classElement.html#a37">put_adapted_flag()</a>, but has left the if statements in the code responsible for refinement and unrefinement untouched because he encountered a bug, that he narrowed to within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a> or a function called from within <a class="el" href="hadpt_8C.html#a12">H_adapt()</a>, recurse down, but has not pinpointed. Keith believes the bug is related to the refined flag being inappropriately set to 1, or not unset to zero when it should be. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r51" doxytag="Element::Awet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r51">Element::Awet</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Awet is the ratio of this element's wet area to total area (always between 0 and 1 inclusive) when taken together with iwetnode, this uniquely determines the exact placement of the "dryline" within the current element. Awet is initially set by source placement to be either 0 (no material) or 1 (material) and is updated by the corrector part of the predictor-corrector method, the new value is determined by where the dry line has been convected to over this timestep. Keith wrote this May 2007. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r14" doxytag="Element::bcptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structBC.html">BC</a>* <a class="el" href="classElement.html#r14">Element::bcptr</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
pointer to the boundary condition class, if this element is not a boundary element the pointer holds the NULL value 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r23" doxytag="Element::brothers"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r23">Element::brothers</a>[4][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this array holds the keys of this element's 4 brothers (an element is considered to be it's own brother), this information is used during mesh unrefinement (combining the 4 brothers to make their father), keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r35" doxytag="Element::coefABCD"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r35">Element::coefABCD</a>[4]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi not used in titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r24" doxytag="Element::coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r24">Element::coord</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
coord holds the coordinates of the elements cell center, these are the same as the coordinates of the element's bubble node's 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r48" doxytag="Element::counted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r48">Element::counted</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r39" doxytag="Element::curvature"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r39">Element::curvature</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Curvature itself is the inverse of radius of curvature. The exact value of curvature is the spatial second derivative of the normal coordinate of the surface along directions tangent to the surface at that point (local x and y). However I believe that Laercio Namikawa implemented it approximately, i.e. as the global x and y second derivatives of terrain elevation. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r41" doxytag="Element::d_gravity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r41">Element::d_gravity</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the spatial (x and y) derivatives of the local z component of the gravity vector 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r30" doxytag="Element::d_state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r30">Element::d_state_vars</a>[<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a> *<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
these are the spatial (x and y) derivatives of the state variables: (dh/dx, dhVx/dx, dhVy/dx, dh/dy, dhVx/dy, dhVy/dy) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r52" doxytag="Element::drypoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r52">Element::drypoint</a>[2]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
center point of the "dryline", x and y coordinates value ranges between -0.5 and 0.5 with 0 being the center of the element, since the wet/dry interface is taken to be a non-deforming non rotating (within the timestep) "dryline" convecting a single point on the dryline (called the drypoint) is sufficient to determine the new placement of the dryline which allows us to update Awet... Keith wrote this May 2007. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r32" doxytag="Element::dx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r32">Element::dx</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
length of the element in the global x and y directions: dx and dy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r44" doxytag="Element::effect_bedfrict"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r44">Element::effect_bedfrict</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus the effective bed friction angle holds either the value of the actual bed friction angle if it should not be stopped or the value of the internal friction angle if it should not be stopped 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r46" doxytag="Element::effect_kactxy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r46">Element::effect_kactxy</a>[2]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, if the effective bed friction angle equals the internal friction angle effect_kactxy takes on the value 1, k active/passive comes from using a Coulomb friction model for granular flows 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r45" doxytag="Element::effect_tanbedfrict"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r45">Element::effect_tanbedfrict</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
one option for what to do when you know the flow should be stopped is to reset the bed friction angle to take on the value of the internal friction angle, thus effect_tanbedfrict holds the value of the effective bed friction angle 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r34" doxytag="Element::eigenvxymax"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r34">Element::eigenvxymax</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
maximum x and y direction wavespeeds for this element, wavespeeds are eigenvalues of the flux jacobians 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r17" doxytag="Element::el_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r17">Element::el_error</a>[<a class="el" href="constant_8h.html#a16">EQUATIONS</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this holds the "error" in the element's solution, which is useful in determining refinement, this may actually be afeapi legacy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r18" doxytag="Element::el_solution"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r18">Element::el_solution</a>[<a class="el" href="constant_8h.html#a16">EQUATIONS</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this holds the element solution, I believe this is legacy afeapi 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r37" doxytag="Element::elevation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r37">Element::elevation</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
terrain elevation at this elements center/bubble node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r25" doxytag="Element::elm_loc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r25">Element::elm_loc</a>[2]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
elm_loc is used in unrefining beyond the original coarse mesh 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r9" doxytag="Element::father"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r9">Element::father</a>[<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the key of the father it is assigned in the <a class="el" href="hadpt_8C.html#a5">refine()</a> and unrefine_elements() functions 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r1" doxytag="Element::generation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r1">Element::generation</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
generation is how many times this element has been refined, currently -8&lt;=generation&lt;=3, a negative generation number means it has been unrefined beyond the orignal coarse mesh, a positive generation number means it has been refined (is smaller than the original element size) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r40" doxytag="Element::gravity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r40">Element::gravity</a>[3]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the gravity vector in local x,y,z coordinates (z is normal to the terrain surface, the projections of the x and y local directions onto a horizontal plane are aligned with the global x and y directions) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r47" doxytag="Element::Influx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r47">Element::Influx</a>[3]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
extrusion flux rate for this timestep for this element, used when having material flow out of the ground, a volume per unit area influx rate source term 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r49" doxytag="Element::ithelem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r49">Element::ithelem</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
when sorted by keys this element is the ithelem element on this processor, ithelem is just storage for a value you have to assign before using, if you do not compute it before you use it will be wrong. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r50" doxytag="Element::iwetnode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r50">Element::iwetnode</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the node number {0,1,..,7} of this element's "most wet node", this dictates both the orientation of the "dryline" and which side of it is wet. The "dryline" is the line that divides a partially wetted element into a dry part and a wet part, for the sake of simplicity only 4 orientations are allowed, horizontal, vertical, parallel to either diagonal of the element. If the iwetnode is an edge node of this element then the dryline is parallel to the edge the element is on, if the iwetnode is a corner node of this element then dryline is parallel to the diagonal of the element that the iwetnode is not on. Which side of the dryline is wet is the same side in which the iwetnode resides (and is determined each timestep based soley on which of the elements neighbors currently have pile height greater than GEOFLOW_TINY)... as such iwetnode can be thought of as the MOST WET NODE of the element. Having iwetnode==8 indicates that the element is uniformly wet if this element's pile height is greater than GEOFLOW_TINY or is uniformly dry if pileheight is less than or equal to GEOFLOW_TINY. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r36" doxytag="Element::kactxy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r36">Element::kactxy</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
k active/passive in the x and y directions, k active/passive is part of the coulomb friction model for Granular Flows 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r6" doxytag="Element::key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r6">Element::key</a>[<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the element key, which has the same value as the key of the element's bubble node, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r42" doxytag="Element::lam"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r42">Element::lam</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
legacy titan not really used, lam :=p_{bed}/(rho*g_z*h) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r5" doxytag="Element::lb_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r5">Element::lb_key</a>[<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the key for load-balancing, if there is no constrained node, it is the element key, otherwise it is a construct of the element "bunch", keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r4" doxytag="Element::lb_weight"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r4">Element::lb_weight</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the load-balancing weight 
<p>
! ! THE MAT. FLAG ! ! !     </td>
  </tr>
</table>
<a class="anchor" name="r3" doxytag="Element::material"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r3">Element::material</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the material flag indicates which material should be used to set this element's bed friction, this is for when a GIS material map, specifying different materials in different spatial regions of the map, the GIS material map is a non standard grass map format that Laercio Namikawa developed, it's stored in the "cats" folder under a grass mapset directory 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r0" doxytag="Element::myprocess"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r0">Element::myprocess</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
myprocess is id of the process(or) that owns this element 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r15" doxytag="Element::ndof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r15">Element::ndof</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the number of degrees of freedom, since Titan is a finite difference/volume code, ndof is afeapi legacy, but the DG (Discontinuous Galerkin) version of Titan actually uses this 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r13" doxytag="Element::neigh_gen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r13">Element::neigh_gen</a>[8]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
neigh_gen is an array that holds the "generation" (how refined it is) of this element's 8 neighbors, there can-be/are 2 neighbors to a side because of the 1 irregularity rule 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r11" doxytag="Element::neigh_proc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r11">Element::neigh_proc</a>[8]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this array holds the process(or) id of this element's 8 neighbors, there can be 8 neighbors because of the 1 irregularity rule. neigh_proc[4:7] != -2 only if it has 2 neighbors on that side, a value of -1 for neigh_proc means that this edge is a boundary of the computational domain. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r8" doxytag="Element::neighbor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r8">Element::neighbor</a>[8][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this array holds the keys of this element's 8 neighbors (2 neigbors to a side if the neighbor is more refined than this element, otherwise the two neighbor keys for that side are identical in value), having 8 neighbors is an outcome of the 1 irregularity refinement rule, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r22" doxytag="Element::new_old"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r22">Element::new_old</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the new_old flag is used in mesh adaptation and repartitioning 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r16" doxytag="Element::no_of_eqns"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r16">Element::no_of_eqns</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi, it is not used, but do not remove it, it could cause problems if you do 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r7" doxytag="Element::node_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r7">Element::node_key</a>[8][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this array holds the first 8 (0-&gt;7) of this element's nodes' keys, the n9th (8 out of 0-&gt;8) node is the bubble node it's key is not stored separately since it has the same key as the element, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r2" doxytag="Element::opposite_brother_flag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r2">Element::opposite_brother_flag</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
opposite_brother_flag indicate if we have the correct key for the non-neighbor brother (0:= don't have info, 1:= have info) 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r12" doxytag="Element::order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r12">Element::order</a>[5]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi, all finite volume "elements"/cells are piece wise constant, but I believe this is actually used in the DG (Discontinuous Galerkin) version of titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r33" doxytag="Element::positive_x_side"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r33">Element::positive_x_side</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
for structured grid, tells which side is the positive x direction 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r29" doxytag="Element::prev_state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r29">Element::prev_state_vars</a>[<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
these are the values of the state variables from before the predictor step 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r27" doxytag="Element::recv"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r27">Element::recv</a>[8]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is afeapi legacy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r19" doxytag="Element::refined"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r19">Element::refined</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
refined is a flag that usually has the value 0, but will be 1 if the element has been refined this iteration (used to enforce the 1 irregularity rule), or have the value "GHOST" if it is a ghost cell, refined and ghost cells are not updated, see <a class="el" href="constant_8h.html">constant.h</a> for the value of GHOST 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r26" doxytag="Element::send"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r26">Element::send</a>[8]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is afeapi legacy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r31" doxytag="Element::shortspeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r31">Element::shortspeed</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the short speed is the speed computed as: shortspeed=|v|=|dhv/dh|=|v*dh/dh+h*dv/dh|=|v+h*dv/dh| which goes to |v| in the limit of h-&gt;0, this is a more accurate way to compute speed when the pile in this cell is short, hence the name "shortspeed" but it is not accurate when the pile is tall, that is when h*dv/dh is large, this is the value from the previous iteration (so there is lagging when using the shortspeed, but this should still be much more accurate than hV/h when h-&gt;0. Keith implemented this in late summer 2006, 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r10" doxytag="Element::son"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classElement.html#r10">Element::son</a>[4][<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this array holds the keys of this element's 4 sons, it is only used temporarily in the refinement process before the father (this element) is deleted, there's was an old comment "garantee ccw" associated with this variable, I don't know what it means, keys are used to access elements or nodes through the appropriate hashtables, each key is a single number that fills 2 unsigned variables 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r28" doxytag="Element::state_vars"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r28">Element::state_vars</a>[<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
state_vars is an array that holds the current state variables: h, hVx, and hVy 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r43" doxytag="Element::stoppedflags"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r43">Element::stoppedflags</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
part of the new stopping criteria under development, has a 0 if flow is not stopped, has the value 1 if it should not be sliding but should be slumping, has the value 2 if it should neither be sliding or slumping (it should be completely stopped), I (Keith) am rather confident in the criteria used to set this the problem is determining what to do about it after you know the flow SHOULD be stopped 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r53" doxytag="Element::Swet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r53">Element::Swet</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
when an element edge is partially wet and partially dry... Swet is the fraction of a cell edge that is partially wet, because it can only be horizontal, vertical, or parallel to either diagonal, all of one element's partially wet sides are have the same fraction of wetness. The state variables (used to compute the physical fluxes) at the element/cell edge are adjusted to be the weighted by wetness average over an element/cell edge. As such physical fluxes through completely dry edges of partially wet elements/cells are zeroed, while physical fluxes through completely wet edges are left unchanged. Because of the definition as "wetness weighted average" physical fluxes through a partially wet edge shared with a neighbor of the same generation is also left left unchanged but, when a partially wet edge is shared with two more refined neighbors the total mass and momentum at the edge is split between the two neighbors in proportion to how much of their boundary shared with this element is wet. This "scaling" of the physical fluxes is the "adjustment of fluxes in partially wetted cells" facet of our multifaceted thin-layer problem mitigation approach. And it has been shown to significantly reduce the area covered by a thin layer of material. Keith wrote this May 2007. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r21" doxytag="Element::which_son"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classElement.html#r21">Element::which_son</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
which_son holds the value of which son this element is, which of the 4 squares that makes up the father elements square. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r38" doxytag="Element::zeta"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classElement.html#r38">Element::zeta</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
terrain slope in the global x and y directions 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="element2_8h-source.html">element2.h</a><li><a class="el" href="unrefine_8C.html">unrefine.C</a><li><a class="el" href="element2_8C.html">element2.C</a><li><a class="el" href="flux__srcs_8C.html">flux_srcs.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jul 3 12:45:53 2007 for Titan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
