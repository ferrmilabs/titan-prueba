<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Titan: Node Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Node Class Reference</h1><code>#include &lt;<a class="el" href="node_8h-source.html">node.h</a>&gt;</code>
<p>
<a href="classNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0">Node</a> (unsigned *keyi, double *coordi, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the constructor that creates a node when the initial grid is read in  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1">Node</a> (unsigned *keyi, double *coordi, int inf, int ord, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the constructor that creates bubble and edge nodes for son Elements when the father <a class="el" href="classElement.html">Element</a> is refined  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2">Node</a> (unsigned *keyi, double *coordi, int inf, int ord, double elev, int yada)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the node constructor that is called in <a class="el" href="update__element__info_8C.html#a2">construct_el()</a> in <a class="el" href="constant_8h.html#a21">update_element_info.C</a>  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3">Node</a> (FILE *fp, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the constructor that recreates/restores a node that was saved in a restart file.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4">Node</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor that creates a node without setting any of its values  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5">~Node</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6">save_node</a> (FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function writes all of one Node's data necessary for restart to a file in a single fwrite statement  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7">putdof</a> (int lower, int up)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi, it is extraneous for the finite difference/volume version of titan, however it appears once in <a class="el" href="constant_8h.html#a21">htflush.C</a>  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8">getdof</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi, it is extraneous for the finite difference/volume version of titan  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9">putglnum</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a10">putsol</a> (double *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a11">getglnum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function is legacy afeapi  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a12">getinfo</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the node type, the options are listed in <a class="el" href="constant_8h.html">constant.h</a> and include: NODEINIT, CORNER, BUBBLE, SIDE, CONSTRAINED, S_C_CON, S_S_CON, ASSIGNED,and UNASSIGNED.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a13">putinfo</a> (int in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the node type, the options are listed in <a class="el" href="constant_8h.html">constant.h</a> and include: NODEINIT, CORNER, BUBBLE, SIDE, CONSTRAINED, S_C_CON, S_S_CON, ASSIGNED,and UNASSIGNED.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a14">pass_key</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the node key, a key is a single number that is 2 unsigned variables long and is used to access the pointer to a Node or <a class="el" href="classElement.html">Element</a> through the <a class="el" href="classHashTable.html">HashTable</a>  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a15">get_coord</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the global x and y coordinates of the node, in the finite difference version of Titan this is not always reliable, use the coordinates of the element instead. It is reliable in the Discontinuous Galerkin version of Titan however.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a16">getsol</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a17">get_order</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a18">put_order</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a19">increase_order</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a20">set_parameters</a> (int inf, int ord)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the node information and order, node order is legacy afeapi but node information is currently used, this function is called in <a class="el" href="constant_8h.html#a21">update_element_info.C</a>, another distict function with a similar name <a class="el" href="structrefined__neighbor.html#a1">refined_neighbor::set_parameters</a> also existis and is used in <a class="el" href="constant_8h.html#a21">updatenei.C</a>, these should not be confused  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a21">get_reconstructed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a22">put_reconstructed</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a>  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a23">get_sol_deleted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a>  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a24">put_sol_deleted</a> (int flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a>  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a25">put_id</a> (int id_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the id of a node, it is used in repartitioning,  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a26">get_id</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the id of a node, it is used in repartitioning,  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a27">get_flux</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the vector of fluxes stored in an edge node between elements  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a28">zero_flux</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function zeros the flux used during refinement, this is only distinct from the regular flux if flux velocity is being zero'd because the experimental stopping criteria says it should be. This feature is disabled by default. Keith implemented it.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a29">get_elevation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the elevation of a node, in the finite difference version of Titan this is not always reliable, use the elevation of the element instead. It is reliable in the Discontinuous Galerkin version of Titan however.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a30">set_elevation</a> (<a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function sets the elevation of a node  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a31">put_num_assoc_elem</a> (int numin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function stores the number of elements associated with this node  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a32">get_num_assoc_elem</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function returns the number of elements associated with this node  <a href="#a32"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p0">id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">used in delete_unused_nodes_and_elements() function  <a href="#p0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p1">num_assoc_elem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the number of associated elements, it is used in extraneous node  <a href="#p1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p2">info</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">says what type of node this is see the comments of Node::get_info()  <a href="#p2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p3">order</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is legacy afeapi and is not important though it would involve quite a bit of work to remove because it occurs frequently in Titan  <a href="#p3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p4">coord</a> [<a class="el" href="constant_8h.html#a15">DIMENSION</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the global x and y coordinates of the node  <a href="#p4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p5">key</a> [<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is the node key, a key is a single number that is 2 unsigned variables long and is used to access the pointer to a Node or <a class="el" href="classElement.html">Element</a> through the <a class="el" href="classHashTable.html">HashTable</a>  <a href="#p5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p6">nextptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">points to the next node  <a href="#p6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p7">preptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">points to the previous node  <a href="#p7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p8">dof</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">nodal degrees of freedom are legacy afeapi but came with the comment "dof[1]-dof[0]+1 = dof of the node"  <a href="#p8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p9">glnum</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">glnum is legacy afeapit but came with the comment "the node occupies the position from glnum to glnum+dof"  <a href="#p9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p10">sol</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sol is legacy afeapi and pointed to the nodal solution array  <a href="#p10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p11">reconstructed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reconstructed is legacy afeapi  <a href="#p11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p12">sol_deleted</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sol_deleted is legacy afeapi, it appears in <a class="el" href="constant_8h.html#a21">node.C</a> and <a class="el" href="constant_8h.html#a21">htflush.C</a>  <a href="#p12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p13">elevation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this elevation should currently be the GIS elevation at the finest "scale"  <a href="#p13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p14">flux</a> [<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">these are the so called "regular fluxes" that is the ones that are used to update the elements, assume that element normal is parallel to either the x or y axis, Keith is the one who introduced a distinction between regular and refinement fluxes for use with the stopping criteria, this distinction is disabled by default  <a href="#p14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#p15">refinementflux</a> [<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the "refinement flux" is necessary when using the stopping criteria to reset the "regular" fluxes to what they would be if velocity was zero in the cell(s) involved. The refinement flux is what the flux would have been if it had not been reset, they are needed since refinement is based on fluxes (and also pileheight gradient but that's not relevant here) Keith is the one who introduced a distinction between regular and refinement fluxes for use with the stopping criteria, this distinction is disabled by default.  <a href="#p15"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n0">Element</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n1">correct</a> (<a class="el" href="classHashTable.html">HashTable</a> *NodeTable, <a class="el" href="classHashTable.html">HashTable</a> *El_Table, double dt, <a class="el" href="structMatProps.html">MatProps</a> *matprops_ptr, <a class="el" href="structFluxProps.html">FluxProps</a> *fluxprops, <a class="el" href="structTimeProps.html">TimeProps</a> *timeprops, void *EmTemp, double *forceint, double *forcebed, double *eroded, double *deposited)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">non member C++ function that wraps the fortran correct_() function  <a href="#n1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n2">AssertMeshErrorFree</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int numprocs, int myid, double loc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG.  <a href="#n2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n3">ElemBackgroundCheck</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, unsigned *debugkey, FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">investigate an <a class="el" href="classElement.html">Element</a>, question his "friends and family" about him.  <a href="#n3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n4">ElemBackgroundCheck2</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, void *EmDebug, FILE *fp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n5">NodeBackgroundCheck</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, unsigned *debugkey, FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">investigate a Node question his "friends and family" about him.  <a href="#n5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n6">delete_oldsons</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int myid, void *EmFather)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n7">refine_neigh_update</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int numprocs, int myid, void *RefinedList, <a class="el" href="structTimeProps.html">TimeProps</a> *timeprops_ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n8">unrefine_interp_neigh_update</a> (<a class="el" href="classHashTable.html">HashTable</a> *El_Table, <a class="el" href="classHashTable.html">HashTable</a> *NodeTable, int nump, int myid, void *OtherProcUpdate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n9">Pack_element</a> (void *sendel, <a class="el" href="structElemPack.html">ElemPack</a> *elem, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classNode.html#n9">Pack_element()</a> is a friend function of the <a class="el" href="classElement.html">Element</a> and Node classes that packs relevant information from an element "sendel" into a smaller data structure (<a class="el" href="structElemPack.html">ElemPack</a>) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning.  <a href="#n9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n10">destroy_element</a> (void *r_element, <a class="el" href="classHashTable.html">HashTable</a> *HT_Elem_Ptr, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#n11">create_element</a> (<a class="el" href="structElemPack.html">ElemPack</a> *elem2, <a class="el" href="classHashTable.html">HashTable</a> *HT_Elem_Ptr, <a class="el" href="classHashTable.html">HashTable</a> *HT_Node_Ptr, double *e_error)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="Node::Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::Node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>keyi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>coordi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the constructor that creates a node when the initial grid is read in 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="Node::Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::Node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>keyi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>coordi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>inf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the constructor that creates bubble and edge nodes for son Elements when the father <a class="el" href="classElement.html">Element</a> is refined 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="Node::Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::Node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>keyi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>coordi</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>inf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>elev</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>yada</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the node constructor that is called in <a class="el" href="update__element__info_8C.html#a2">construct_el()</a> in <a class="el" href="constant_8h.html#a21">update_element_info.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="Node::Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::Node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the constructor that recreates/restores a node that was saved in a restart file. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="Node::Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::Node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor that creates a node without setting any of its values 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="Node::~Node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Node::~<a class="el" href="classNode.html">Node</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a15" doxytag="Node::get_coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Node::get_coord           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the global x and y coordinates of the node, in the finite difference version of Titan this is not always reliable, use the coordinates of the element instead. It is reliable in the Discontinuous Galerkin version of Titan however. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="Node::get_elevation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double Node::get_elevation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the elevation of a node, in the finite difference version of Titan this is not always reliable, use the elevation of the element instead. It is reliable in the Discontinuous Galerkin version of Titan however. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="Node::get_flux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Node::get_flux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the vector of fluxes stored in an edge node between elements 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="Node::get_id"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::get_id           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the id of a node, it is used in repartitioning, 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="Node::get_num_assoc_elem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::get_num_assoc_elem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the number of elements associated with this node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="Node::get_order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::get_order           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="Node::get_reconstructed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::get_reconstructed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="Node::get_sol_deleted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::get_sol_deleted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="Node::getdof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int * Node::getdof           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi, it is extraneous for the finite difference/volume version of titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="Node::getglnum"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::getglnum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="Node::getinfo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Node::getinfo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the node type, the options are listed in <a class="el" href="constant_8h.html">constant.h</a> and include: NODEINIT, CORNER, BUBBLE, SIDE, CONSTRAINED, S_C_CON, S_S_CON, ASSIGNED,and UNASSIGNED. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="Node::getsol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double * Node::getsol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="Node::increase_order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::increase_order           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="Node::pass_key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned * Node::pass_key           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function returns the node key, a key is a single number that is 2 unsigned variables long and is used to access the pointer to a Node or <a class="el" href="classElement.html">Element</a> through the <a class="el" href="classHashTable.html">HashTable</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="Node::put_id"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::put_id           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id_in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the id of a node, it is used in repartitioning, 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="Node::put_num_assoc_elem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::put_num_assoc_elem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>numin</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function stores the number of elements associated with this node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="Node::put_order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::put_order           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="Node::put_reconstructed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::put_reconstructed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="Node::put_sol_deleted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::put_sol_deleted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not used at all except once in <a class="el" href="constant_8h.html#a21">htflush.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="Node::putdof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::putdof           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>lower</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>up</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi, it is extraneous for the finite difference/volume version of titan, however it appears once in <a class="el" href="constant_8h.html#a21">htflush.C</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="Node::putglnum"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::putglnum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="Node::putinfo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::putinfo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the node type, the options are listed in <a class="el" href="constant_8h.html">constant.h</a> and include: NODEINIT, CORNER, BUBBLE, SIDE, CONSTRAINED, S_C_CON, S_S_CON, ASSIGNED,and UNASSIGNED. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="Node::putsol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::putsol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function is legacy afeapi 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="Node::save_node"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::save_node           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function writes all of one Node's data necessary for restart to a file in a single fwrite statement 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="Node::set_elevation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::set_elevation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>matprops_ptr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the elevation of a node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="Node::set_parameters"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::set_parameters           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>inf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ord</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function sets the node information and order, node order is legacy afeapi but node information is currently used, this function is called in <a class="el" href="constant_8h.html#a21">update_element_info.C</a>, another distict function with a similar name <a class="el" href="structrefined__neighbor.html#a1">refined_neighbor::set_parameters</a> also existis and is used in <a class="el" href="constant_8h.html#a21">updatenei.C</a>, these should not be confused 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="Node::zero_flux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Node::zero_flux           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function zeros the flux used during refinement, this is only distinct from the regular flux if flux velocity is being zero'd because the experimental stopping criteria says it should be. This feature is disabled by default. Keith implemented it. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n2" doxytag="Node::AssertMeshErrorFree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void AssertMeshErrorFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>numprocs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>loc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this function checks for any and all possible mesh errors, i.e. it checks if the mesh is legal, it says nothing about the quality of a legal mesh, you must have ghost information present before performing this check, WARNING THIS CHECK TAKES A LOT OF TIME, ONLY USE IT TO DEBUG. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n1" doxytag="Node::correct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void correct           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structMatProps.html">MatProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>matprops_ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFluxProps.html">FluxProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fluxprops</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structTimeProps.html">TimeProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeprops</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmTemp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>forceint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>forcebed</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>eroded</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>deposited</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
non member C++ function that wraps the fortran correct_() function 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n11" doxytag="Node::create_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void create_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structElemPack.html">ElemPack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Elem_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>e_error</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n6" doxytag="Node::delete_oldsons"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void delete_oldsons           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmFather</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n10" doxytag="Node::destroy_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void destroy_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>r_element</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Elem_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n3" doxytag="Node::ElemBackgroundCheck"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ElemBackgroundCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>debugkey</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
investigate an <a class="el" href="classElement.html">Element</a>, question his "friends and family" about him. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n4" doxytag="Node::ElemBackgroundCheck2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ElemBackgroundCheck2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>EmDebug</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n0" doxytag="Node::Element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classElement.html">Element</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n5" doxytag="Node::NodeBackgroundCheck"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NodeBackgroundCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>debugkey</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
investigate a Node question his "friends and family" about him. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n9" doxytag="Node::Pack_element"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Pack_element           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>sendel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structElemPack.html">ElemPack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>HT_Node_Ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>destination_proc</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classNode.html#n9">Pack_element()</a> is a friend function of the <a class="el" href="classElement.html">Element</a> and Node classes that packs relevant information from an element "sendel" into a smaller data structure (<a class="el" href="structElemPack.html">ElemPack</a>) to be sent by an mpi call to another processor, this is used when exchanging ghost cell information or repartitioning. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n7" doxytag="Node::refine_neigh_update"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void refine_neigh_update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>numprocs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>RefinedList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structTimeProps.html">TimeProps</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeprops_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n8" doxytag="Node::unrefine_interp_neigh_update"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void unrefine_interp_neigh_update           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>El_Table</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classHashTable.html">HashTable</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NodeTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nump</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>myid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>OtherProcUpdate</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="p4" doxytag="Node::coord"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classNode.html#p4">Node::coord</a>[<a class="el" href="constant_8h.html#a15">DIMENSION</a>]<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the global x and y coordinates of the node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p8" doxytag="Node::dof"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p8">Node::dof</a>[2]<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
nodal degrees of freedom are legacy afeapi but came with the comment "dof[1]-dof[0]+1 = dof of the node" 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p13" doxytag="Node::elevation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classNode.html#p13">Node::elevation</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this elevation should currently be the GIS elevation at the finest "scale" 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p14" doxytag="Node::flux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classNode.html#p14">Node::flux</a>[<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
these are the so called "regular fluxes" that is the ones that are used to update the elements, assume that element normal is parallel to either the x or y axis, Keith is the one who introduced a distinction between regular and refinement fluxes for use with the stopping criteria, this distinction is disabled by default 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p9" doxytag="Node::glnum"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p9">Node::glnum</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
glnum is legacy afeapit but came with the comment "the node occupies the position from glnum to glnum+dof" 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p0" doxytag="Node::id"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p0">Node::id</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
used in delete_unused_nodes_and_elements() function 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p2" doxytag="Node::info"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p2">Node::info</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
says what type of node this is see the comments of Node::get_info() 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p5" doxytag="Node::key"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned <a class="el" href="classNode.html#p5">Node::key</a>[<a class="el" href="constant_8h.html#a10">KEYLENGTH</a>]<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is the node key, a key is a single number that is 2 unsigned variables long and is used to access the pointer to a Node or <a class="el" href="classElement.html">Element</a> through the <a class="el" href="classHashTable.html">HashTable</a> 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p6" doxytag="Node::nextptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="classNode.html#p6">Node::nextptr</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
points to the next node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p1" doxytag="Node::num_assoc_elem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p1">Node::num_assoc_elem</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the number of associated elements, it is used in extraneous node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p3" doxytag="Node::order"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p3">Node::order</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
this is legacy afeapi and is not important though it would involve quite a bit of work to remove because it occurs frequently in Titan 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p7" doxytag="Node::preptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="classNode.html#p7">Node::preptr</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
points to the previous node 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p11" doxytag="Node::reconstructed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p11">Node::reconstructed</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
reconstructed is legacy afeapi 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p15" doxytag="Node::refinementflux"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classNode.html#p15">Node::refinementflux</a>[<a class="el" href="constant_8h.html#a45">NUM_STATE_VARS</a>]<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
the "refinement flux" is necessary when using the stopping criteria to reset the "regular" fluxes to what they would be if velocity was zero in the cell(s) involved. The refinement flux is what the flux would have been if it had not been reset, they are needed since refinement is based on fluxes (and also pileheight gradient but that's not relevant here) Keith is the one who introduced a distinction between regular and refinement fluxes for use with the stopping criteria, this distinction is disabled by default. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p10" doxytag="Node::sol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double* <a class="el" href="classNode.html#p10">Node::sol</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
sol is legacy afeapi and pointed to the nodal solution array 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="p12" doxytag="Node::sol_deleted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classNode.html#p12">Node::sol_deleted</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
sol_deleted is legacy afeapi, it appears in <a class="el" href="constant_8h.html#a21">node.C</a> and <a class="el" href="constant_8h.html#a21">htflush.C</a> 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="node_8h-source.html">node.h</a><li><a class="el" href="node_8C.html">node.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jul 3 12:45:55 2007 for Titan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
