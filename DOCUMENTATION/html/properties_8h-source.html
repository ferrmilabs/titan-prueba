<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Titan: properties.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">header</a></div>
<h1>properties.h</h1><a href="properties_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*******************************************************************</span>
00002 <span class="comment"> * Copyright (C) 2003 University at Buffalo</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This software can be redistributed free of charge.  See COPYING</span>
00005 <span class="comment"> * file in the top distribution directory for more details.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * This software is distributed in the hope that it will be useful,</span>
00008 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00009 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Author: </span>
00012 <span class="comment"> * Description: </span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *******************************************************************</span>
00015 <span class="comment"> * $Id: properties.h 129 2007-06-07 19:54:28Z dkumar $ </span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#ifndef MAX_DEPTH_MAP</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define MAX_DEPTH_MAP</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#ifndef PROPS</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define PROPS</span>
00024 <span class="preprocessor"></span>
00025 
00026 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00027 <span class="preprocessor">#include&lt;stdio.h&gt;</span> <span class="comment">//useful_lib.h has a function that return pointer to FILE</span>
00028 <span class="preprocessor">#include "../useful/useful_lib.h"</span>
00029 <span class="preprocessor">#include&lt;time.h&gt;</span>  <span class="comment">//for TimeProps</span>
00030 <span class="preprocessor">#include&lt;math.h&gt;</span>
00031 <span class="preprocessor">#include "../gisapi/GisApi.h"</span>
00032 
<a name="l00034"></a><a class="code" href="structLHS__Props.html">00034</a> <span class="keyword">struct </span><a class="code" href="structLHS__Props.html">LHS_Props</a>{
00035   
<a name="l00037"></a><a class="code" href="structLHS__Props.html#o0">00037</a>   <span class="keywordtype">int</span> refnum;     
00038 
<a name="l00040"></a><a class="code" href="structLHS__Props.html#o1">00040</a>   <span class="keywordtype">int</span> runid;      
00041  
<a name="l00043"></a><a class="code" href="structLHS__Props.html#a0">00043</a>   <a class="code" href="structLHS__Props.html">LHS_Props</a>() {
00044     refnum=runid=-1;
00045   } 
00046 
00047 };
00048 
00049 
<a name="l00051"></a><a class="code" href="structStatProps.html">00051</a> <span class="keyword">struct </span><a class="code" href="structStatProps.html">StatProps</a>{
00052   <span class="comment">//note all means are mass/volume averages</span>
00053 
<a name="l00055"></a><a class="code" href="structStatProps.html#o0">00055</a>   <span class="keywordtype">int</span>    runid;
00056 
<a name="l00058"></a><a class="code" href="structStatProps.html#o1">00058</a>   <span class="keywordtype">double</span> xcen;
00059 
<a name="l00061"></a><a class="code" href="structStatProps.html#o2">00061</a>   <span class="keywordtype">double</span> ycen;
00062 
<a name="l00064"></a><a class="code" href="structStatProps.html#o3">00064</a>   <span class="keywordtype">double</span> xvar;
00065 
<a name="l00067"></a><a class="code" href="structStatProps.html#o4">00067</a>   <span class="keywordtype">double</span> yvar;
00068 
<a name="l00070"></a><a class="code" href="structStatProps.html#o5">00070</a>   <span class="keywordtype">double</span> rmean;
00071 
<a name="l00073"></a><a class="code" href="structStatProps.html#o6">00073</a>   <span class="keywordtype">double</span> area;
00074 
<a name="l00076"></a><a class="code" href="structStatProps.html#o7">00076</a>   <span class="keywordtype">double</span> vmean;
00077 
<a name="l00079"></a><a class="code" href="structStatProps.html#o8">00079</a>   <span class="keywordtype">double</span> vxmean;     
00080 
<a name="l00082"></a><a class="code" href="structStatProps.html#o9">00082</a>   <span class="keywordtype">double</span> vymean;     
00083 
<a name="l00085"></a><a class="code" href="structStatProps.html#o10">00085</a>   <span class="keywordtype">double</span> slopemean;  
00086 
<a name="l00088"></a><a class="code" href="structStatProps.html#o11">00088</a>   <span class="keywordtype">double</span> vstar;
00089   
<a name="l00091"></a><a class="code" href="structStatProps.html#o12">00091</a>   <span class="keywordtype">double</span> realvolume;
00092 
<a name="l00094"></a><a class="code" href="structStatProps.html#o13">00094</a>   <span class="keywordtype">double</span> statvolume;   
00095 
<a name="l00097"></a><a class="code" href="structStatProps.html#o14">00097</a>   <span class="keywordtype">double</span> outflowvol;
00098 
<a name="l00100"></a><a class="code" href="structStatProps.html#o15">00100</a>   <span class="keywordtype">double</span> erodedvol;
00101 
<a name="l00103"></a><a class="code" href="structStatProps.html#o16">00103</a>   <span class="keywordtype">double</span> depositedvol;
00104 
<a name="l00106"></a><a class="code" href="structStatProps.html#o17">00106</a>   <span class="keywordtype">double</span> cutoffheight;
00107 
<a name="l00109"></a><a class="code" href="structStatProps.html#o18">00109</a>   <span class="keywordtype">double</span> piler;
00110 
<a name="l00112"></a><a class="code" href="structStatProps.html#o19">00112</a>   <span class="keywordtype">double</span> hmax;
00113 
<a name="l00115"></a><a class="code" href="structStatProps.html#o20">00115</a>   <span class="keywordtype">double</span> vmax;
00116 
<a name="l00118"></a><a class="code" href="structStatProps.html#o21">00118</a>   <span class="keywordtype">double</span> forceint;
00119 
<a name="l00121"></a><a class="code" href="structStatProps.html#o22">00121</a>   <span class="keywordtype">double</span> forcebed;
00122 
<a name="l00124"></a><a class="code" href="structStatProps.html#o23">00124</a>   <span class="keywordtype">double</span> heightifreach; 
00125 
<a name="l00127"></a><a class="code" href="structStatProps.html#o24">00127</a>   <span class="keywordtype">double</span> xyifreach[2];
00128 
<a name="l00130"></a><a class="code" href="structStatProps.html#o25">00130</a>   <span class="keywordtype">double</span> timereached;
00131 
<a name="l00133"></a><a class="code" href="structStatProps.html#o26">00133</a>   <span class="keywordtype">double</span> xyminmax[4];
00134 
<a name="l00136"></a><a class="code" href="structStatProps.html#o27">00136</a>   <span class="keywordtype">double</span> hxyminmax;     
00137 
<a name="l00139"></a><a class="code" href="structStatProps.html#o28">00139</a>   <a class="code" href="structLHS__Props.html">LHS_Props</a> lhs; 
00140 
<a name="l00142"></a><a class="code" href="structStatProps.html#a0">00142</a>   <a class="code" href="structStatProps.html">StatProps</a>() {
00143     timereached=-1.0; 
00144     xcen=ycen=xvar=yvar=rmean=area=vmean=vxmean=vymean=slopemean=vstar=0.0;
00145     realvolume=statvolume=outflowvol=erodedvol=depositedvol=cutoffheight=0.0;
00146     piler=hmax=vmax=forceint=forcebed=0.0;
00147     heightifreach=xyifreach[0]=xyifreach[1]=timereached=0.0;
00148     xyminmax[0]=xyminmax[1]=xyminmax[2]=xyminmax[3]=hxyminmax=0.0;
00149     lhs.<a class="code" href="structLHS__Props.html#o0">refnum</a>=lhs.<a class="code" href="structLHS__Props.html#o1">runid</a>=-1;
00150   }
00151 
00152 
00153   
00154 
00155 };
00156 
<a name="l00158"></a><a class="code" href="structPileProps.html">00158</a> <span class="keyword">struct </span><a class="code" href="structPileProps.html">PileProps</a>{
<a name="l00160"></a><a class="code" href="structPileProps.html#o0">00160</a>   <span class="keywordtype">int</span> numpiles;
00161 
<a name="l00163"></a><a class="code" href="structPileProps.html#o1">00163</a>   <span class="keywordtype">double</span> *pileheight;
00164 
<a name="l00166"></a><a class="code" href="structPileProps.html#o2">00166</a>   <span class="keywordtype">double</span> *xCen;
00167 
<a name="l00169"></a><a class="code" href="structPileProps.html#o3">00169</a>   <span class="keywordtype">double</span> *yCen;
00170 
<a name="l00172"></a><a class="code" href="structPileProps.html#o4">00172</a>   <span class="keywordtype">double</span> *majorrad;
00173 
<a name="l00175"></a><a class="code" href="structPileProps.html#o5">00175</a>   <span class="keywordtype">double</span> *minorrad;
00176 
<a name="l00178"></a><a class="code" href="structPileProps.html#o6">00178</a>   <span class="keywordtype">double</span> *cosrot;
00179 
<a name="l00181"></a><a class="code" href="structPileProps.html#o7">00181</a>   <span class="keywordtype">double</span> *sinrot;
00182 
<a name="l00184"></a><a class="code" href="structPileProps.html#o8">00184</a>   <span class="keywordtype">double</span> *initialVx;
00185 
<a name="l00187"></a><a class="code" href="structPileProps.html#o9">00187</a>   <span class="keywordtype">double</span> *initialVy;   
00188 
<a name="l00190"></a><a class="code" href="structPileProps.html#a0">00190</a>   <a class="code" href="structPileProps.html">PileProps</a>() {
00191     numpiles=0;
00192   }
00193 
<a name="l00195"></a><a class="code" href="structPileProps.html#a1">00195</a>   <span class="keywordtype">void</span> allocpiles(<span class="keywordtype">int</span> numpiles_in) {
00196     numpiles=numpiles_in;
00197     pileheight=<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00198     xCen      =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00199     yCen      =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00200     majorrad  =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00201     minorrad  =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00202     cosrot    =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00203     sinrot    =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00204     initialVx =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00205     initialVy =<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(numpiles);
00206 
00207   }
00208 
<a name="l00210"></a><a class="code" href="structPileProps.html#a2">00210</a>   ~<a class="code" href="structPileProps.html">PileProps</a>() {
00211     <span class="keywordflow">if</span>(numpiles&gt;0) {
00212       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(pileheight);
00213       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(xCen);
00214       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(yCen);
00215       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(majorrad);
00216       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(minorrad);
00217       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(cosrot);
00218       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(sinrot);
00219       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(initialVx);
00220       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(initialVy); 
00221     }     
00222   }
00223 
00224 };
00225 
00226 
00227 
00228 <span class="comment">/*************************************************************************/</span>
00229 <span class="comment">/* the gis map properties                                                */</span>
00230 <span class="comment">/*************************************************************************/</span>
00231 
00232 
<a name="l00234"></a><a class="code" href="structMapNames.html">00234</a> <span class="keyword">struct </span><a class="code" href="structMapNames.html">MapNames</a>{
00235 
<a name="l00237"></a><a class="code" href="structMapNames.html#o0">00237</a>   <span class="keywordtype">char</span> *gis_main;    
00238 
<a name="l00240"></a><a class="code" href="structMapNames.html#o1">00240</a>   <span class="keywordtype">char</span> *gis_sub;     
00241 
<a name="l00243"></a><a class="code" href="structMapNames.html#o2">00243</a>   <span class="keywordtype">char</span> *gis_mapset;  
00244 
<a name="l00246"></a><a class="code" href="structMapNames.html#o3">00246</a>   <span class="keywordtype">char</span> *gis_map;
00247 
<a name="l00249"></a><a class="code" href="structMapNames.html#o4">00249</a>   <span class="keywordtype">int</span> extramaps;     
00250   
<a name="l00252"></a><a class="code" href="structMapNames.html#a0">00252</a>   ~<a class="code" href="structMapNames.html">MapNames</a>() { clear(); <span class="keywordflow">return</span>; }
00253 
<a name="l00255"></a><a class="code" href="structMapNames.html#a1">00255</a>   <span class="keywordtype">void</span> assign(<span class="keywordtype">char</span> *gis_main_in, <span class="keywordtype">char</span> *gis_sub_in, <span class="keywordtype">char</span> *gis_mapset_in, 
00256       <span class="keywordtype">char</span> *gis_map_in, <span class="keywordtype">int</span> extramaps_in) {
00257     gis_main=<a class="code" href="useful__lib_8h.html#a34">allocstrcpy</a>(gis_main_in);
00258     gis_sub=<a class="code" href="useful__lib_8h.html#a34">allocstrcpy</a>(gis_sub_in);
00259     gis_mapset=<a class="code" href="useful__lib_8h.html#a34">allocstrcpy</a>(gis_mapset_in);
00260     gis_map=<a class="code" href="useful__lib_8h.html#a34">allocstrcpy</a>(gis_map_in);
00261     extramaps=extramaps_in;
00262     <span class="keywordflow">return</span>;
00263   }
00264 
<a name="l00266"></a><a class="code" href="structMapNames.html#a2">00266</a>   <span class="keywordtype">void</span> clear() {
00267     free(gis_main);
00268     free(gis_sub);
00269     free(gis_mapset);
00270     free(gis_map);
00271     <span class="keywordflow">return</span>;
00272   }
00273 };
00274 
00275 <span class="comment">/**************************************************************************/</span>
00276 <span class="comment">/* the time properties                                                    */</span>
00277 <span class="comment">/**************************************************************************/</span>
00278 
<a name="l00280"></a><a class="code" href="structTimeProps.html">00280</a> <span class="keyword">struct </span><a class="code" href="structTimeProps.html">TimeProps</a>{
00281 
<a name="l00283"></a><a class="code" href="structTimeProps.html#o0">00283</a>   <span class="keywordtype">int</span>    maxiter;
00284 
00285 
<a name="l00287"></a><a class="code" href="structTimeProps.html#o1">00287</a>   <span class="keywordtype">int</span>    iter;       
00288 
<a name="l00290"></a><a class="code" href="structTimeProps.html#o2">00290</a>   <span class="keywordtype">double</span> maxtime;    
00291 
<a name="l00293"></a><a class="code" href="structTimeProps.html#o3">00293</a>   <span class="keywordtype">double</span> ndmaxtime;
00294 
<a name="l00296"></a><a class="code" href="structTimeProps.html#o4">00296</a>   <span class="keywordtype">double</span> timeoutput;
00297 
00298 
<a name="l00300"></a><a class="code" href="structTimeProps.html#o5">00300</a>   <span class="keywordtype">double</span> timesave;
00301 
<a name="l00303"></a><a class="code" href="structTimeProps.html#o6">00303</a>   <span class="keywordtype">int</span>    ioutput;
00304 
<a name="l00306"></a><a class="code" href="structTimeProps.html#o7">00306</a>   <span class="keywordtype">int</span>    isave;
00307 
<a name="l00309"></a><a class="code" href="structTimeProps.html#o8">00309</a>   <span class="keywordtype">double</span> ndnextoutput; 
00310 
<a name="l00312"></a><a class="code" href="structTimeProps.html#o9">00312</a>   <span class="keywordtype">double</span> ndnextsave; 
00313 
<a name="l00315"></a><a class="code" href="structTimeProps.html#o10">00315</a>   <span class="keywordtype">double</span> TIME_SCALE;
00316 
<a name="l00318"></a><a class="code" href="structTimeProps.html#o11">00318</a>   <span class="keywordtype">double</span> time;
00319 
<a name="l00321"></a><a class="code" href="structTimeProps.html#o12">00321</a>   <span class="keywordtype">double</span> dtime;
00322 
<a name="l00324"></a><a class="code" href="structTimeProps.html#o13">00324</a>   <span class="keywordtype">double</span> vstarmax;
00325 
<a name="l00327"></a><a class="code" href="structTimeProps.html#o14">00327</a>   time_t starttime;  
00328 
<a name="l00330"></a><a class="code" href="structTimeProps.html#a0">00330</a>   <span class="keywordtype">void</span> inittime(<span class="keywordtype">int</span> maxiterin, <span class="keywordtype">double</span> maxtimein, <span class="keywordtype">double</span> timeoutputin, 
00331                 <span class="keywordtype">double</span> timesavein, <span class="keywordtype">double</span> TIME_SCALEin) {
00332     maxiter=maxiterin;
00333     maxtime=maxtimein;
00334     timeoutput=timeoutputin;
00335     timesave=timesavein;
00336     TIME_SCALE=TIME_SCALEin;
00337     ndmaxtime=maxtime/TIME_SCALE;
00338     ndnextoutput=timeoutput/TIME_SCALE;
00339     ndnextsave=timesave/TIME_SCALE;
00340     iter=0;
00341     ioutput=0;
00342     isave=0;
00343     time=0.0;
00344     dtime=0.0;
00345     vstarmax=0.0;
00346    }
00347 
<a name="l00349"></a><a class="code" href="structTimeProps.html#a1">00349</a>   <span class="keywordtype">void</span> incrtime(<span class="keywordtype">double</span> *dt) {
00350     <span class="comment">// first reduce dt to hit output or end time "exactly"</span>
00351     <span class="keywordflow">if</span>(time+*dt&gt;ndnextoutput) *dt=ndnextoutput-time;
00352     <span class="keywordflow">if</span>(time+*dt&gt;ndnextsave)   *dt=ndnextsave  -time;
00353     <span class="keywordflow">if</span>(time+*dt&gt;ndmaxtime)    *dt=ndmaxtime   -time;
00354     dtime=*dt;
00355     <span class="comment">// then increment time</span>
00356     time+=*dt; 
00357     iter++;}
00358 
00359 
<a name="l00360"></a><a class="code" href="structTimeProps.html#a2">00360</a>   <span class="keywordtype">int</span>  ifstart() {<span class="keywordflow">return</span>(iter==0);} 
<a name="l00361"></a><a class="code" href="structTimeProps.html#a3">00361</a>   <span class="keywordtype">int</span>  iffirst() {<span class="keywordflow">return</span>(iter==1);} 
00362 
<a name="l00364"></a><a class="code" href="structTimeProps.html#a4">00364</a>   <span class="keywordtype">int</span>  ifend(<span class="keywordtype">double</span> vstar) {
00365     <span class="keywordflow">if</span>(vstar&gt;vstarmax) vstarmax=vstar;
00366     <span class="keywordflow">return</span>((time&gt;=ndmaxtime)||(iter&gt;maxiter)||((vstarmax&gt;2.0)&amp;&amp;!(vstar&gt;1.0)));}
00367 
<a name="l00369"></a><a class="code" href="structTimeProps.html#a5">00369</a>   <span class="keywordtype">int</span>  ifcheckstop() {<span class="keywordflow">return</span>(time&gt;ndmaxtime/10.0);}
00370 
<a name="l00372"></a><a class="code" href="structTimeProps.html#a6">00372</a>   <span class="keywordtype">int</span>  ifsave() {
00373     <span class="keywordflow">if</span>(time&gt;=ndnextsave) {
00374       isave++; <span class="comment">//using isave eliminates roundoff</span>
00375       ndnextsave=((isave+1)*timesave)/TIME_SCALE;
00376       <span class="keywordflow">return</span>(1);}
00377     <span class="keywordflow">else</span> <span class="keywordflow">return</span>(0);}
00378 
<a name="l00380"></a><a class="code" href="structTimeProps.html#a7">00380</a>   <span class="keywordtype">int</span>  ifoutput() {
00381     <span class="keywordflow">if</span>(time&gt;=ndnextoutput) {
00382       ioutput++; <span class="comment">//using ioutput eliminates roundoff</span>
00383       ndnextoutput=((ioutput+1)*timeoutput)/TIME_SCALE;
00384       <span class="keywordflow">return</span>(1);}
00385     <span class="keywordflow">else</span> <span class="keywordflow">return</span>(0);}
00386 
<a name="l00388"></a><a class="code" href="structTimeProps.html#a8">00388</a>   <span class="keywordtype">void</span> chunktime(<span class="keywordtype">int</span> *hours, <span class="keywordtype">int</span> *minutes, <span class="keywordtype">double</span> *seconds) {
00389     <span class="keywordtype">double</span> dimtime=time*TIME_SCALE;
00390     *hours   = ((int) dimtime)/3600;
00391     *minutes = (((int) dimtime)%3600)/60;
00392     *seconds = dimtime -(double)(*hours*3600+*minutes*60);}
00393 
<a name="l00395"></a><a class="code" href="structTimeProps.html#a9">00395</a>   <span class="keywordtype">double</span> timesec() {<span class="keywordflow">return</span>(time*TIME_SCALE);}
00396     
00397 };
00398 
00399 <span class="comment">/*****************************************************************************/</span>
00401 <span class="comment">/*****************************************************************************/</span>
<a name="l00402"></a><a class="code" href="structMatProps.html">00402</a> <span class="keyword">struct </span><a class="code" href="structMatProps.html">MatProps</a>{
<a name="l00404"></a><a class="code" href="structMatProps.html#o0">00404</a>   <span class="keywordtype">int</span> number_of_cells_across_axis;
00405 
<a name="l00407"></a><a class="code" href="structMatProps.html#o1">00407</a>   <span class="keywordtype">double</span> smallest_axis;
00408 
<a name="l00410"></a><a class="code" href="structMatProps.html#o2">00410</a>   <span class="keywordtype">int</span>     material_count; 
00411 
<a name="l00413"></a><a class="code" href="structMatProps.html#o3">00413</a>   <span class="keywordtype">char</span>  **matnames;
00414 
<a name="l00416"></a><a class="code" href="structMatProps.html#o4">00416</a>   <span class="keywordtype">double</span>  intfrict;
00417 
<a name="l00419"></a><a class="code" href="structMatProps.html#o5">00419</a>   <span class="keywordtype">double</span>  tanintfrict;
00420 
<a name="l00422"></a><a class="code" href="structMatProps.html#o6">00422</a>   <span class="keywordtype">double</span> *bedfrict;
00423 
<a name="l00425"></a><a class="code" href="structMatProps.html#o7">00425</a>   <span class="keywordtype">double</span> *tanbedfrict;
00426 
<a name="l00428"></a><a class="code" href="structMatProps.html#o8">00428</a>   <span class="keywordtype">double</span>  porosity;
00429 
<a name="l00431"></a><a class="code" href="structMatProps.html#o9">00431</a>   <span class="keywordtype">double</span>  mu;
00432 
<a name="l00434"></a><a class="code" href="structMatProps.html#o10">00434</a>   <span class="keywordtype">double</span>  rho;
00435 
<a name="l00437"></a><a class="code" href="structMatProps.html#o11">00437</a>   <span class="keywordtype">double</span>  epsilon;
00438 
<a name="l00440"></a><a class="code" href="structMatProps.html#o12">00440</a>   <span class="keywordtype">double</span>  gamma;
00441 
<a name="l00443"></a><a class="code" href="structMatProps.html#o13">00443</a>   <span class="keywordtype">double</span>  LENGTH_SCALE;
00444 
<a name="l00446"></a><a class="code" href="structMatProps.html#o14">00446</a>   <span class="keywordtype">double</span>  HEIGHT_SCALE;
00447 
<a name="l00449"></a><a class="code" href="structMatProps.html#o15">00449</a>   <span class="keywordtype">double</span>  GRAVITY_SCALE;
00450 
<a name="l00452"></a><a class="code" href="structMatProps.html#o16">00452</a>   <span class="keywordtype">double</span>  MAX_NEGLIGIBLE_HEIGHT; 
00453 
<a name="l00455"></a><a class="code" href="structMatProps.html#o17">00455</a>   <span class="keywordtype">double</span>  Vslump; 
00456 
<a name="l00458"></a><a class="code" href="structMatProps.html#o18">00458</a>   <span class="keywordtype">double</span>  frict_tiny;     
00459 
<a name="l00461"></a><a class="code" href="structMatProps.html#a0">00461</a>   <a class="code" href="structMatProps.html">MatProps</a>(<span class="keywordtype">int</span> material_countin, <span class="keywordtype">char</span> **matnamesin, 
00462            <span class="keywordtype">double</span> intfrictin, <span class="keywordtype">double</span> *bedfrictin,
00463            <span class="keywordtype">double</span> porosityin, <span class="keywordtype">double</span> muin, <span class="keywordtype">double</span> rhoin,
00464            <span class="keywordtype">double</span> epsilonin, <span class="keywordtype">double</span> gammain, <span class="keywordtype">double</span> frict_tinyin,
00465            <span class="keywordtype">double</span> lscale, <span class="keywordtype">double</span> hscale, <span class="keywordtype">double</span> gscale) {
00466 
00467     material_count=material_countin;
00468 
00469     <span class="keywordflow">if</span>(material_count&gt;0) {
00470       <span class="comment">//dynamic memory allocation... see useful_lib.C for CAlloc?#()</span>
00471       matnames=(<span class="keywordtype">char</span> **) malloc((material_count+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00472       bedfrict=<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(material_count+1);
00473       tanbedfrict=<a class="code" href="useful__lib_8h.html#a11">CAllocD1</a>(material_count+1);
00474 
00475       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imat=1; imat&lt;=material_count; imat++) {
00476         matnames[imat]=<a class="code" href="useful__lib_8h.html#a34">allocstrcpy</a>(matnamesin[imat]);  <span class="comment">//see useful_lib.C</span>
00477         bedfrict[imat] = bedfrictin[imat];
00478         tanbedfrict[imat] = tan(bedfrict[imat]);}}
00479 
00480     intfrict=intfrictin;
00481     tanintfrict=tan(intfrict);
00482     porosity = porosityin;
00483     mu = muin;
00484     rho = rhoin;
00485 
00486     epsilon = epsilonin;
00487     gamma = gammain;
00488     frict_tiny = frict_tinyin;
00489     LENGTH_SCALE = lscale;
00490     HEIGHT_SCALE = hscale;
00491     GRAVITY_SCALE = gscale;
00492   }
00493 
<a name="l00495"></a><a class="code" href="structMatProps.html#a1">00495</a>   ~<a class="code" href="structMatProps.html">MatProps</a>() {
00496     <span class="keywordflow">if</span>(material_count&gt;0) {
00497       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(bedfrict);
00498       <a class="code" href="useful__lib_8h.html#a27">CDeAllocD1</a>(tanbedfrict);
00499       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imat=1; imat&lt;=material_count; imat++) free(matnames[imat]);
00500       free(matnames);
00501     }
00502     <span class="keywordflow">return</span>;
00503   }
00504 };
00505 
00506 
<a name="l00508"></a><a class="code" href="structOutLine.html">00508</a> <span class="keyword">struct </span><a class="code" href="structOutLine.html">OutLine</a>{
00509   <span class="comment">// the least squares interpolated height didn't work for some reason</span>
00510   <span class="comment">// that is didn't produce a meaningful pileheight contour map so it has</span>
00511   <span class="comment">// been commented out.  that is everything to deal with pileheight2</span>
<a name="l00513"></a><a class="code" href="structOutLine.html#o0">00513</a> <span class="comment"></span>  <span class="keywordtype">int</span> Nx;
00514 
<a name="l00516"></a><a class="code" href="structOutLine.html#o1">00516</a>   <span class="keywordtype">int</span> Ny;
00517 
<a name="l00519"></a><a class="code" href="structOutLine.html#o2">00519</a>   <span class="keywordtype">double</span> dx;
00520 
<a name="l00522"></a><a class="code" href="structOutLine.html#o3">00522</a>   <span class="keywordtype">double</span> dy; 
00523 
<a name="l00525"></a><a class="code" href="structOutLine.html#o4">00525</a>   <span class="keywordtype">double</span> xminmax[2];
00526 
<a name="l00528"></a><a class="code" href="structOutLine.html#o5">00528</a>   <span class="keywordtype">double</span> yminmax[2];
00529 
<a name="l00531"></a><a class="code" href="structOutLine.html#o6">00531</a>   <span class="keywordtype">double</span> **pileheight;
00532   <span class="comment">//double **pileheight2;</span>
00533 
<a name="l00535"></a><a class="code" href="structOutLine.html#a0">00535</a>   <a class="code" href="structOutLine.html">OutLine</a>() { Nx=Ny=0; <span class="keywordflow">return</span>; }
00536 
<a name="l00538"></a><a class="code" href="structOutLine.html#a1">00538</a>   ~<a class="code" href="structOutLine.html">OutLine</a>() {
00539     <span class="keywordflow">if</span>((Nx&gt;0)&amp;&amp;(Ny&gt;0)) <a class="code" href="useful__lib_8h.html#a28">CDeAllocD2</a>(pileheight);
00540     <span class="keywordflow">return</span>;
00541   }
00542 
<a name="l00544"></a><a class="code" href="structOutLine.html#a2">00544</a>   <span class="keywordtype">void</span> init(<span class="keywordtype">double</span> *dxy, <span class="keywordtype">int</span> power, <span class="keywordtype">double</span> *XRange, <span class="keywordtype">double</span> *YRange) {
00545     <span class="keywordtype">int</span> ix,iy;
00546 
00547     <span class="keywordflow">if</span>(power&lt;0) power=0;
00548 
00549     dx=dxy[0]/pow(2.0,power);
00550     dy=dxy[1]/pow(2.0,power);
00551     <span class="comment">//printf("dx=%g dy=%g  XRange={%g,%g} YRange={%g,%g}\n",dx,dy,XRange[0],XRange[1],YRange[0],YRange[1]);</span>
00552 
00553     xminmax[0]=XRange[0]; xminmax[1]=XRange[1];
00554     yminmax[0]=YRange[0]; yminmax[1]=YRange[1];
00555 
00556     Nx=(int)( (XRange[1]-XRange[0])/dx +0.5); <span class="comment">//round to nearest integer</span>
00557     Ny=(int)( (YRange[1]-YRange[0])/dy +0.5); <span class="comment">//round to nearest integer</span>
00558 
00559     <span class="keywordflow">while</span>(Nx*Ny&gt;1024*1024){
00560       dx*=2.0;
00561       dy*=2.0;
00562 
00563       Nx=(int)( (XRange[1]-XRange[0])/dx +0.5); <span class="comment">//round to nearest integer</span>
00564       Ny=(int)( (YRange[1]-YRange[0])/dy +0.5); <span class="comment">//round to nearest integer</span>
00565     }
00566     printf(<span class="stringliteral">"Outline init: Nx=%d Ny=%d Nx*Ny=%d\n"</span>,Nx,Ny,Nx*Ny);
00567 
00568 
00569     pileheight =<a class="code" href="useful__lib_8h.html#a12">CAllocD2</a>(Ny,Nx);
00570     <span class="comment">//pileheight2=CAllocD2(Ny,Nx);</span>
00571     <span class="keywordflow">for</span>(iy=0;iy&lt;Ny;iy++)
00572       <span class="keywordflow">for</span>(ix=0;ix&lt;Nx;ix++) {
00573         pileheight[ iy][ix]=0.0;
00574         <span class="comment">//pileheight2[iy][ix]=0.0;</span>
00575       }      
00576     <span class="keywordflow">return</span>;
00577   }
00578 
<a name="l00580"></a><a class="code" href="structOutLine.html#a3">00580</a>   <span class="keywordtype">void</span> init2(<span class="keywordtype">double</span> *dxy, <span class="keywordtype">double</span> *XRange, <span class="keywordtype">double</span> *YRange) {
00581     <span class="keywordtype">int</span> ix,iy;
00582 
00583     dx=dxy[0];
00584     dy=dxy[1];
00585 
00586     xminmax[0]=XRange[0]; xminmax[1]=XRange[1];
00587     yminmax[0]=YRange[0]; yminmax[1]=YRange[1];
00588 
00589     Nx=(int)( (XRange[1]-XRange[0])/dx +0.5); <span class="comment">//round to nearest integer</span>
00590     Ny=(int)( (YRange[1]-YRange[0])/dy +0.5); <span class="comment">//round to nearest integer</span>
00591 
00592     pileheight =<a class="code" href="useful__lib_8h.html#a12">CAllocD2</a>(Ny,Nx);
00593     <span class="comment">//pileheight2=CAllocD2(Ny,Nx);</span>
00594     <span class="keywordflow">for</span>(iy=0;iy&lt;Ny;iy++)
00595       <span class="keywordflow">for</span>(ix=0;ix&lt;Nx;ix++) {
00596         pileheight[ iy][ix]=0.0;
00597         <span class="comment">//pileheight2[iy][ix]=0.0;</span>
00598       }      
00599 
00600     <span class="keywordflow">return</span>;
00601   }
00602 
00603 
<a name="l00605"></a><a class="code" href="structOutLine.html#a4">00605</a>   <span class="keywordtype">void</span> update(<span class="keywordtype">double</span> xstart, <span class="keywordtype">double</span> xstop, <span class="keywordtype">double</span> ystart, <span class="keywordtype">double</span> ystop, <span class="keywordtype">double</span> height, <span class="keywordtype">double</span> h2[6]) {
00606     <span class="keywordtype">int</span> ixstart=(int)((xstart-xminmax[0])/dx+0.5);
00607     <span class="keywordtype">int</span> ixstop=(int)((xstop-xminmax[0])/dx+0.5);
00608     <span class="keywordtype">int</span> iystart=(int)((ystart-yminmax[0])/dy+0.5);
00609     <span class="keywordtype">int</span> iystop=(int)((ystop-yminmax[0])/dy+0.5);
00610 
00611     <span class="comment">/*    double x,y,height2;</span>
00612 <span class="comment">    double xc=0.5*(xstart+xstop);</span>
00613 <span class="comment">    double yc=0.5*(ystart+ystop);</span>
00614 <span class="comment">    */</span>  
00615     <span class="keywordflow">if</span>(ixstart&lt;0) ixstart=0;
00616     <span class="keywordflow">if</span>(ixstop==ixstart) {
00617       ixstart=(int) ((xstart-xminmax[0])/dx);
00618       ixstop=ixstart+1;
00619     }
00620     <span class="keywordflow">if</span>(ixstop&gt;Nx) ixstop=Nx;
00621 
00622 
00623     <span class="keywordflow">if</span>(iystart&lt;0) iystart=0;
00624     <span class="keywordflow">if</span>(iystop==iystart) {
00625       iystart=(int) ((ystart-yminmax[0])/dy);
00626       iystop=iystart+1;
00627     }
00628     <span class="keywordflow">if</span>(iystop&gt;Ny) iystop=Ny;
00629 
00630     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=iystart;iy&lt;iystop;iy++)
00631       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=ixstart;ix&lt;ixstop;ix++) {
00632         <span class="comment">/*      x=(ix+0.5)*dx-xc;</span>
00633 <span class="comment">        y=(iy+0.5)*dy-yc;</span>
00634 <span class="comment">        height2=h2[0]+h2[1]*x+h2[2]*y+h2[3]*x*y+h2[4]*x*x+h2[5]*y*y;</span>
00635 <span class="comment">        if(height2&gt;pileheight2[iy][ix]) pileheight2[iy][ix]=height2; */</span>
00636         <span class="keywordflow">if</span>(height &gt;pileheight[ iy][ix]) pileheight[ iy][ix]=height;
00637       }
00638     <span class="keywordflow">return</span>;
00639   }
00640 
<a name="l00642"></a><a class="code" href="structOutLine.html#a5">00642</a>   <span class="keywordtype">void</span> output(<a class="code" href="structMatProps.html">MatProps</a>* matprops_ptr, <a class="code" href="structStatProps.html">StatProps</a>* statprops_ptr) {
00643     <span class="keywordtype">int</span> ix,iy;
00644     <span class="keywordtype">char</span> filename[256];
00645     sprintf(filename,<span class="stringliteral">"pileheightrecord.%06d"</span>,statprops_ptr-&gt;<a class="code" href="structStatProps.html#o0">runid</a>);
00646     FILE *fp=fopen(filename,<span class="stringliteral">"w"</span>);
00647 
00648     <span class="comment">//FILE *fp=fopen("outline.pileheight","w");</span>
00649     fprintf(fp,<span class="stringliteral">"Nx=%d: X={%20.14g,%20.14g}\nNy=%d: Y={%20.14g,%20.14g}\nPileheight=\n"</span>,Nx,xminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,xminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,Ny,yminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,yminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>);
00650     <span class="keywordflow">for</span>(iy=0; iy&lt;Ny; iy++) {
00651       <span class="keywordflow">for</span>(ix=0; ix&lt;Nx-1; ix++) fprintf(fp,<span class="stringliteral">"%g "</span>,pileheight[iy][ix]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o14">HEIGHT_SCALE</a>);
00652       fprintf(fp,<span class="stringliteral">"%g\n"</span>,pileheight[iy][ix]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o14">HEIGHT_SCALE</a>);
00653     }
00654     fclose(fp);
00655 
00656     sprintf(filename,<span class="stringliteral">"elevation.grid"</span>);
00657     fp=fopen(filename,<span class="stringliteral">"w"</span>);
00658     fprintf(fp,<span class="stringliteral">"Nx=%d: X={%20.14g,%20.14g}\nNy=%d: Y={%20.14g,%20.14g}\nPileheight=\n"</span>,Nx,xminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,xminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,Ny,yminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,yminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>);
00659     <span class="keywordtype">double</span> yy, xx, res=dx+dy, elevation;
00660     <span class="keywordtype">int</span> ierr;
00661     <span class="keywordflow">for</span>(iy=0; iy&lt;Ny; iy++) {
00662       yy=((iy+0.5)*dy+yminmax[0])*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>;
00663       <span class="keywordflow">for</span>(ix=0; ix&lt;Nx-1; ix++) {
00664         xx=((ix+0.5)*dx+xminmax[0])*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>;
00665         ierr = <a class="code" href="GisApi_8h.html#a43">Get_elevation</a>(res, xx, yy, &amp;elevation);
00666         fprintf(fp,<span class="stringliteral">"%g "</span>,elevation);
00667       }
00668       fprintf(fp,<span class="stringliteral">"%g\n"</span>,pileheight[iy][ix]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o14">HEIGHT_SCALE</a>);
00669     }
00670     fclose(fp);
00671 
00672 
00673     <span class="comment">/*    fp=fopen("outline.pileheight2","w");</span>
00674 <span class="comment">    fprintf(fp,"Nx=%d: X={%20.14g,%20.14g}\nNy=%d: Y={%20.14g,%20.14g}\nPileheight=\n",Nx,xminmax[0]*matprops_ptr-&gt;LENGTH_SCALE,xminmax[1]*matprops_ptr-&gt;LENGTH_SCALE,Ny,yminmax[0]*matprops_ptr-&gt;LENGTH_SCALE,yminmax[1]*matprops_ptr-&gt;LENGTH_SCALE);</span>
00675 <span class="comment">    for(iy=0; iy&lt;Ny; iy++) {</span>
00676 <span class="comment">      for(ix=0; ix&lt;Nx-1; ix++) fprintf(fp,"%g ",pileheight2[iy][ix]*matprops_ptr-&gt;HEIGHT_SCALE);</span>
00677 <span class="comment">      fprintf(fp,"%g\n",pileheight2[iy][ix]*matprops_ptr-&gt;HEIGHT_SCALE);</span>
00678 <span class="comment">    }</span>
00679 <span class="comment">    fclose(fp);</span>
00680 <span class="comment">    */</span>
00681     <span class="keywordflow">return</span>;
00682     
00683 
00684 
00685 
00686   }
00687   
<a name="l00689"></a><a class="code" href="structOutLine.html#a6">00689</a>   <span class="keywordtype">void</span> reload(<a class="code" href="structMatProps.html">MatProps</a>* matprops_ptr, <a class="code" href="structStatProps.html">StatProps</a>* statprops_ptr) {
00690     <span class="keywordtype">int</span> ix,iy;
00691     <span class="keywordtype">char</span> filename[256];
00692     sprintf(filename,<span class="stringliteral">"pileheightrecord.%06d"</span>,statprops_ptr-&gt;<a class="code" href="structStatProps.html#o0">runid</a>);
00693     FILE *fp=fopen(filename,<span class="stringliteral">"r"</span>);
00694 
00695     <span class="keywordflow">if</span>(fp==NULL)
00696       printf(<span class="stringliteral">"pileheightrecord.%06d can not be found.\nRestarting from zero instead\n"</span>,statprops_ptr-&gt;<a class="code" href="structStatProps.html#o0">runid</a>);
00697     <span class="keywordflow">else</span>{
00698       
00699       <span class="keywordtype">int</span> Nxtemp, Nytemp;
00700       <span class="keywordtype">double</span> xminmaxtemp[2], yminmaxtemp[2];
00701       fscanf(fp,<span class="stringliteral">"Nx=%d: X={%lf,%lf}\nNy=%d: Y={%lf,%lf}\nPileheight=\n"</span>,&amp;Nxtemp,(xminmaxtemp+0),(xminmaxtemp+1),&amp;Nytemp,(yminmaxtemp+0),(yminmaxtemp+1));
00702 
00703       <span class="keywordflow">if</span>((Nxtemp==Nx)&amp;&amp;
00704          (fabs(xminmaxtemp[0]/matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>-xminmax[0])&lt;=fabs(xminmax[0])/10000000000.0)&amp;&amp;
00705          (fabs(xminmaxtemp[1]/matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>-xminmax[1])&lt;=fabs(xminmax[1])/10000000000.0)&amp;&amp;
00706          (Nytemp==Ny)&amp;&amp;
00707          (fabs(yminmaxtemp[0]/matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>-yminmax[0])&lt;=fabs(yminmax[0])/10000000000.0)&amp;&amp;
00708          (fabs(yminmaxtemp[1]/matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>-yminmax[1])&lt;=fabs(yminmax[1])/10000000000.0)) {
00709 
00710         <span class="keywordflow">for</span>(iy=0; iy&lt;Ny; iy++) 
00711           <span class="keywordflow">for</span>(ix=0; ix&lt;Nx; ix++) {
00712             fscanf(fp,<span class="stringliteral">"%lf"</span>,pileheight[iy]+ix);
00713             pileheight[iy][ix]/=matprops_ptr-&gt;<a class="code" href="structMatProps.html#o14">HEIGHT_SCALE</a>;
00714           }
00715       }
00716       <span class="keywordflow">else</span> {
00717         printf(<span class="stringliteral">"the pileheightrecord.%06d that is present does not match the restart file.\nRestarting from zero instead\n"</span>,statprops_ptr-&gt;<a class="code" href="structStatProps.html#o0">runid</a>);
00718         printf(<span class="stringliteral">"Nx=%d Nxtemp=%d\n"</span>,Nx,Nxtemp);
00719         printf(<span class="stringliteral">"Ny=%d Nytemp=%d\n"</span>,Ny,Nytemp);
00720         printf(<span class="stringliteral">"xmin=%20.14g xmintemp=%20.14g  xmax=%20.14g, xmaxtemp=%20.14g\n"</span>,
00721                xminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,xminmaxtemp[0],
00722                xminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,xminmaxtemp[1]);
00723         printf(<span class="stringliteral">"ymin=%20.14g ymintemp=%20.14g  ymax=%20.14g, ymaxtemp=%20.14g\n"</span>,
00724                yminmax[0]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,yminmaxtemp[0],
00725                yminmax[1]*matprops_ptr-&gt;<a class="code" href="structMatProps.html#o13">LENGTH_SCALE</a>,yminmaxtemp[1]);
00726         exit(0);
00727       }
00728                
00729       fclose(fp);
00730     }
00731 
00732     <span class="keywordflow">return</span>;
00733   }
00734 
<a name="l00736"></a><a class="code" href="structOutLine.html#a7">00736</a>   <span class="keywordtype">void</span> dealloc() {
00737     <a class="code" href="useful__lib_8h.html#a28">CDeAllocD2</a>(pileheight);
00738     <span class="comment">//CDeAllocD2(pileheight2);</span>
00739     <span class="keywordflow">return</span>;
00740   }
00741 
00742 };
00743 
00744 
00745 <span class="comment">/**********************************************************************/</span>
<a name="l00747"></a><a class="code" href="structDISCHARGE.html">00747</a> <span class="keyword">struct </span><a class="code" href="structDISCHARGE.html">DISCHARGE</a> {
00748 
<a name="l00750"></a><a class="code" href="structDISCHARGE.html#o0">00750</a>   <span class="keywordtype">int</span> num_planes;   
00751 
<a name="l00753"></a><a class="code" href="structDISCHARGE.html#o1">00753</a>   <span class="keywordtype">double</span> **planes;  
00754 
<a name="l00756"></a><a class="code" href="structDISCHARGE.html#a0">00756</a>   <a class="code" href="structDISCHARGE.html">DISCHARGE</a>() {
00757     num_planes=0;
00758     <span class="keywordflow">return</span>;
00759   }
00760 
<a name="l00762"></a><a class="code" href="structDISCHARGE.html#a1">00762</a>   ~<a class="code" href="structDISCHARGE.html">DISCHARGE</a>() {
00763     <span class="keywordflow">if</span>(num_planes&gt;0) <a class="code" href="useful__lib_8h.html#a28">CDeAllocD2</a>(planes);
00764     <span class="keywordflow">return</span>;
00765   }
00766 
00767   <span class="comment">//reinitialized in load_run()</span>
<a name="l00769"></a><a class="code" href="structDISCHARGE.html#a2">00769</a> <span class="comment"></span>  <span class="keywordtype">void</span> init(<span class="keywordtype">int</span> num_planes_in, <span class="keywordtype">double</span> **planes_in) {
00770     <span class="keywordtype">double</span> planestemp[4];
00771     
00772     <span class="comment">//printf("num_planes_in=%d   num_planes=%d\n",num_planes_in,num_planes);</span>
00773     num_planes=num_planes_in;
00774     <span class="comment">//printf("num_planes_in=%d   num_planes=%d\n",num_planes_in,num_planes);</span>
00775     <span class="keywordflow">if</span>(num_planes&gt;0) {
00776       planes=<a class="code" href="useful__lib_8h.html#a12">CAllocD2</a>(num_planes,10);    
00777 
00778       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iplane=0; iplane&lt;num_planes; iplane++) {
00779         <span class="comment">/*      if((planes_in[iplane][1]&lt;planes_in[iplane][0])||</span>
00780 <span class="comment">         ((planes_in[iplane][1]==planes_in[iplane][0])&amp;&amp;</span>
00781 <span class="comment">         (planes_in[iplane][3]&lt;planes_in[iplane][2]))) {</span>
00782 <span class="comment">         planestemp[0]=planes_in[iplane][1];</span>
00783 <span class="comment">         planestemp[1]=planes_in[iplane][0];</span>
00784 <span class="comment">         planestemp[2]=planes_in[iplane][3];</span>
00785 <span class="comment">         planestemp[3]=planes_in[iplane][2];}</span>
00786 <span class="comment">         else{ */</span>
00787         planestemp[0]=planes_in[iplane][0];
00788         planestemp[1]=planes_in[iplane][1];
00789         planestemp[2]=planes_in[iplane][2];
00790         planestemp[3]=planes_in[iplane][3];
00791         <span class="comment">//}</span>
00792 
00793         planes[iplane][0]=planestemp[0]; <span class="comment">//xa</span>
00794         planes[iplane][1]=planestemp[1]; <span class="comment">//xb</span>
00795         planes[iplane][2]=planestemp[2]; <span class="comment">//ya</span>
00796         planes[iplane][3]=planestemp[3]; <span class="comment">//yb</span>
00797         planes[iplane][4]=planes[iplane][1]-planes[iplane][0]; <span class="comment">//xb-xa</span>
00798         planes[iplane][5]=planes[iplane][3]-planes[iplane][2]; <span class="comment">//yb-ya</span>
00799         planes[iplane][6]= <span class="comment">//(xb-xa)^2+(yb-ya)^2</span>
00800           planes[iplane][4]*planes[iplane][4]+
00801           planes[iplane][5]*planes[iplane][5];
00802         planes[iplane][7]= <span class="comment">//ya*(xb-xa)-xa*(yb-ya)</span>
00803           planes[iplane][3]*planes[iplane][4]-
00804           planes[iplane][1]*planes[iplane][5];
00805         planes[iplane][8]=
00806           ((fabs(planes[iplane][4])+fabs(planes[iplane][5]))*
00807            (fabs(planes[iplane][4])+fabs(planes[iplane][5])))/
00808           planes[iplane][6];
00809         
00810         planes[iplane][9]=0.0; <span class="comment">//discharge through the plane</span>
00811         
00812         <span class="comment">//printf("plane %d: (%16.10g,%16.10g) (%16.10g,%16.10g)\n",iplane,planes[iplane][0],planes[iplane][2],planes[iplane][1],planes[iplane][3]);</span>
00813         
00814         
00815       }
00816     }
00817     <span class="keywordflow">return</span>;
00818   }
00819  
<a name="l00821"></a><a class="code" href="structDISCHARGE.html#a3">00821</a>   <span class="keywordtype">void</span> update(<span class="keywordtype">double</span> nodes[9][2], <span class="keywordtype">double</span> *statevars, <span class="keywordtype">double</span> dt) {
00822     <span class="comment">//FILE* fp=fopen("dischargedebug","a");</span>
00823 
00824     <span class="keywordtype">double</span> doubleswap1, doubleswap2, doubleswap3;
00825     <span class="keywordtype">double</span> nearestpoint[2], intersectpoint[2][2];
00826     <span class="keywordtype">int</span> iplane, iintersect, icorner1, icorner2;
00827     <span class="keywordtype">double</span> dxnode[4], dynode[4];
00828     <span class="keywordtype">double</span> dist2nearest2;
00829     <span class="keywordtype">double</span> halfsidelength=<span class="comment">//assumes grid is not slanted</span>
00830       (fabs(nodes[6][0]-nodes[4][0])+fabs(nodes[6][1]-nodes[4][1])+
00831        fabs(nodes[7][0]-nodes[5][0])+fabs(nodes[7][1]-nodes[5][1]))*0.25;
00832     <span class="keywordtype">double</span> halfsidelength2=halfsidelength*halfsidelength;
00833     <span class="keywordtype">double</span> err=halfsidelength/pow(2.0,19.0);
00834 
00835     <span class="keywordflow">for</span>(icorner1=0;icorner1&lt;4;icorner1++) {
00836       icorner2=(icorner1+1)%4;
00837       dxnode[icorner1]=nodes[icorner2][0]-nodes[icorner1][0];
00838       dynode[icorner1]=nodes[icorner2][1]-nodes[icorner1][1];
00839     }
00840     
00841 
00842 
00843     <span class="keywordflow">for</span>(iplane=0;iplane&lt;num_planes;iplane++) {
00844       <span class="comment">/* nearest x &amp; y along line (not necessaryly on line segment) a and b</span>
00845 <span class="comment">         and the elements center node</span>
00846 <span class="comment">        x=(-(yb-ya)*(ya*(xb-xa)-xa*(yb-ya))+(xb-xa)*(y8*(yb-ya)+x8*(xb-xa)))/</span>
00847 <span class="comment">          ((xb-xa)^2+(yb-ya)^2);</span>
00848 <span class="comment">        y=( (xb-xa)*(ya*(xb-xa)-xa*(yb-ya))+(yb-ya)*(y8*(yb-ya)+x8*(xb-xa)))/</span>
00849 <span class="comment">          ((xb-xa)^2+(yb-ya)^2);</span>
00850 <span class="comment">      */</span>        
00851       doubleswap1=nodes[8][1]*planes[iplane][5]+nodes[8][0]*planes[iplane][4];
00852       <span class="comment">//         =y8         *(yb-ya)          +x8         *(xb-xa)</span>
00853       nearestpoint[0]=
00854         (-planes[iplane][5]*planes[iplane][7]
00855          +planes[iplane][4]*doubleswap1)/planes[iplane][6];
00856       nearestpoint[1]=
00857         (+planes[iplane][4]*planes[iplane][7]
00858          +planes[iplane][5]*doubleswap1)/planes[iplane][6];
00859       
00860       dist2nearest2=
00861         (nodes[8][0]-nearestpoint[0])*(nodes[8][0]-nearestpoint[0])+
00862         (nodes[8][1]-nearestpoint[1])*(nodes[8][1]-nearestpoint[1]);
00863 
00864       <span class="comment">//check if line interesects with cell (not counting a single corner)</span>
00865       <span class="keywordflow">if</span>(dist2nearest2&lt;halfsidelength2*planes[iplane][8]) {
00866         <span class="comment">/* fprintf(fp,"nodecoord=(%8f,%8f) nearestpoint=(%8f,%8f)",</span>
00867 <span class="comment">                nodes[8][0],nodes[8][1],nearestpoint[0],nearestpoint[1]);</span>
00868 <span class="comment">        */</span>
00869 
00870         <span class="comment">//it does intersect... if not terminated by endpoints</span>
00871         
00872         iintersect=0; <span class="comment">//stop when you have 2 unique "intersections" </span>
00873         <span class="comment">//(the end of a discharge plane line segment is considered to </span>
00874         <span class="comment">//be an "intersection")</span>
00875         <span class="keywordflow">for</span>(icorner1=0;icorner1&lt;4;icorner1++) {
00876           doubleswap1=
00877             nodes[icorner1][1]*dxnode[icorner1]-
00878             nodes[icorner1][0]*dynode[icorner1];
00879           doubleswap2=        
00880             dxnode[icorner1]*planes[iplane][5]-
00881             dynode[icorner1]*planes[iplane][4];
00882 
00883           <span class="keywordflow">if</span>((doubleswap2&lt;0)||(doubleswap2&gt;0)) {
00884 
00885             intersectpoint[iintersect][0]=
00886               (planes[iplane][4]*doubleswap1-
00887                dxnode[icorner1]*planes[iplane][7])/
00888               doubleswap2;
00889             intersectpoint[iintersect][1]=
00890               (planes[iplane][5]*doubleswap1-
00891                dynode[icorner1]*planes[iplane][7])/
00892               doubleswap2;
00893             
00894             <span class="keywordtype">int</span> ifprint=0;
00895             <span class="keywordflow">if</span>(((intersectpoint[iintersect][0]&lt;planes[iplane][0]-err)&amp;&amp;
00896                 (planes[iplane][0]&lt;planes[iplane][1])) ||
00897                ((intersectpoint[iintersect][0]&gt;planes[iplane][0]+err)&amp;&amp;
00898                 (planes[iplane][0]&gt;planes[iplane][1])) ||
00899                ((intersectpoint[iintersect][1]&lt;planes[iplane][2]-err)&amp;&amp;
00900                 (planes[iplane][2]&lt;planes[iplane][3])) ||
00901                ((intersectpoint[iintersect][1]&gt;planes[iplane][2]+err)&amp;&amp;
00902                 (planes[iplane][2]&gt;planes[iplane][3]))) {
00903               intersectpoint[iintersect][0]=planes[iplane][0];
00904               intersectpoint[iintersect][1]=planes[iplane][2];
00905             }
00906             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(((intersectpoint[iintersect][0]&lt;planes[iplane][1]-err)&amp;&amp;
00907                      (planes[iplane][1]&lt;planes[iplane][0])) ||
00908                     ((intersectpoint[iintersect][0]&gt;planes[iplane][1]+err)&amp;&amp;
00909                      (planes[iplane][1]&gt;planes[iplane][0])) ||
00910                     ((intersectpoint[iintersect][1]&lt;planes[iplane][3]-err)&amp;&amp;
00911                      (planes[iplane][3]&lt;planes[iplane][2])) ||
00912                     ((intersectpoint[iintersect][1]&gt;planes[iplane][3]+err)&amp;&amp;
00913                      (planes[iplane][3]&gt;planes[iplane][2]))) {
00914               intersectpoint[iintersect][0]=planes[iplane][1];
00915               intersectpoint[iintersect][1]=planes[iplane][3];
00916             }
00917 
00918             <span class="keywordflow">if</span>(((((intersectpoint[iintersect][0]-intersectpoint[0][0])*
00919                   (intersectpoint[iintersect][0]-intersectpoint[0][0])+
00920                   (intersectpoint[iintersect][1]-intersectpoint[0][1])*
00921                   (intersectpoint[iintersect][1]-intersectpoint[0][1]))&gt;
00922                  (halfsidelength/512.0))||
00923                 (iintersect==0))&amp;&amp;(doubleswap2!=0.0)) iintersect++;
00924             
00925             <span class="keywordflow">if</span>(iintersect==2) {
00926 
00927               <span class="keywordflow">if</span>((intersectpoint[1][0]-intersectpoint[0][0])*
00928                  (planes[iplane][1]-planes[iplane][0])+
00929                  (intersectpoint[1][1]-intersectpoint[0][1])*
00930                  (planes[iplane][3]-planes[iplane][2]) &lt; 0.0) {
00931                 doubleswap3=intersectpoint[0][0];
00932                 intersectpoint[0][0]=intersectpoint[1][0];
00933                 intersectpoint[1][0]=doubleswap3;
00934                 doubleswap3=intersectpoint[0][1];
00935                 intersectpoint[0][1]=intersectpoint[1][1];
00936                 intersectpoint[1][1]=doubleswap3;
00937               }
00938 
00939               <span class="keywordflow">break</span>; <span class="comment">//we've got both intersection points</span>
00940             }
00941           }
00942         } <span class="comment">// for(icorner1=0;icorner1&lt;4;icorner1++)       </span>
00943         
00944         <span class="keywordflow">if</span>(iintersect==1) {
00945           <span class="comment">//a plane end point is in this cell</span>
00946           
00947           doubleswap1= <span class="comment">//dist from center node to 1st plane endpoint</span>
00948             (nodes[8][0]-planes[iplane][0])*(nodes[8][0]-planes[iplane][0])+
00949             (nodes[8][1]-planes[iplane][2])*(nodes[8][1]-planes[iplane][2]);
00950           
00951           doubleswap2= <span class="comment">//dist from center node to 2nd plane endpoint</span>
00952             (nodes[8][0]-planes[iplane][1])*(nodes[8][0]-planes[iplane][1])+
00953             (nodes[8][1]-planes[iplane][3])*(nodes[8][1]-planes[iplane][3]);
00954 
00955           <span class="keywordflow">if</span>(doubleswap1&lt;=doubleswap2) { <span class="comment">//it's the 1st end point</span>
00956             intersectpoint[1][0]=planes[iplane][0];
00957             intersectpoint[1][1]=planes[iplane][2];}
00958           <span class="keywordflow">else</span> { <span class="comment">//it's the 2nd end point</span>
00959             intersectpoint[1][0]=planes[iplane][1];
00960             intersectpoint[1][1]=planes[iplane][3];}
00961           
00962           iintersect=2; <span class="comment">//we consider plane end point to be an "intersection"</span>
00963         }
00964 
00965         <span class="keywordflow">if</span>(iintersect==2) {
00966 
00967           <span class="comment">/*</span>
00968 <span class="comment">          if((intersectpoint[0][0]&gt;intersectpoint[1][0])||</span>
00969 <span class="comment">             ((intersectpoint[0][0]==intersectpoint[1][0])&amp;&amp;</span>
00970 <span class="comment">              (intersectpoint[0][1]&gt;intersectpoint[1][1]))) {</span>
00971 <span class="comment">            //need to reorder the intersection points to have correct sign </span>
00972 <span class="comment">            //of discharge</span>
00973 <span class="comment">            </span>
00974 <span class="comment">            //swap x</span>
00975 <span class="comment">            doubleswap1=intersectpoint[0][0];</span>
00976 <span class="comment">            intersectpoint[0][0]=intersectpoint[1][0];</span>
00977 <span class="comment">            intersectpoint[1][0]=doubleswap1;</span>
00978 <span class="comment">            </span>
00979 <span class="comment">            //swap y</span>
00980 <span class="comment">            doubleswap1=intersectpoint[0][1];</span>
00981 <span class="comment">            intersectpoint[0][1]=intersectpoint[1][1];</span>
00982 <span class="comment">            intersectpoint[1][1]=doubleswap1;</span>
00983 <span class="comment">          }</span>
00984 <span class="comment">          */</span>
00985 
00986           <span class="comment">//discharge += dt*(hVx*dy-hVy*dx)</span>
00987           planes[iplane][9]+=dt*
00988             (statevars[1]*(intersectpoint[1][1]-intersectpoint[0][1])-
00989              statevars[2]*(intersectpoint[1][0]-intersectpoint[0][0]));
00990         } <span class="comment">// if(iintersect==2)</span>
00991 
00992       } <span class="comment">//if(halfsidelength*(absdy+absdx)&gt;=absdx*absdx+absdy*absdy)</span>
00993 
00994     } <span class="comment">//for(iplane=0;iplane&lt;num_planes;iplane++)</span>
00995 
00996     <span class="keywordflow">return</span>;
00997   }
00998 
<a name="l01000"></a><a class="code" href="structDISCHARGE.html#a4">01000</a>   <span class="keywordtype">void</span> dealloc() {
01001     num_planes=0;
01002     <a class="code" href="useful__lib_8h.html#a28">CDeAllocD2</a>(planes);
01003     <span class="keywordflow">return</span>;
01004   }
01005 };
01006 
<a name="l01008"></a><a class="code" href="structFluxProps.html">01008</a> <span class="keyword">struct </span><a class="code" href="structFluxProps.html">FluxProps</a>
01009 {
<a name="l01011"></a><a class="code" href="structFluxProps.html#o0">01011</a>   <span class="keywordtype">int</span> no_of_sources;
01012 
<a name="l01014"></a><a class="code" href="structFluxProps.html#o1">01014</a>   <span class="keywordtype">double</span> *influx;
01015 
01016 
<a name="l01018"></a><a class="code" href="structFluxProps.html#o2">01018</a>   <span class="keywordtype">double</span> *start_time;
01019 
<a name="l01021"></a><a class="code" href="structFluxProps.html#o3">01021</a>   <span class="keywordtype">double</span> *end_time;
01022 
<a name="l01024"></a><a class="code" href="structFluxProps.html#o4">01024</a>   <span class="keywordtype">double</span> *xCen;
01025 
<a name="l01027"></a><a class="code" href="structFluxProps.html#o5">01027</a>   <span class="keywordtype">double</span> *yCen;
01028 
<a name="l01030"></a><a class="code" href="structFluxProps.html#o6">01030</a>   <span class="keywordtype">double</span> *majorrad;
01031 
<a name="l01033"></a><a class="code" href="structFluxProps.html#o7">01033</a>   <span class="keywordtype">double</span> *minorrad;
01034 
<a name="l01036"></a><a class="code" href="structFluxProps.html#o8">01036</a>   <span class="keywordtype">double</span> *cosrot;
01037 
<a name="l01039"></a><a class="code" href="structFluxProps.html#o9">01039</a>   <span class="keywordtype">double</span> *sinrot;
01040 
<a name="l01042"></a><a class="code" href="structFluxProps.html#o10">01042</a>   <span class="keywordtype">double</span> *xVel;
01043 
<a name="l01045"></a><a class="code" href="structFluxProps.html#o11">01045</a>   <span class="keywordtype">double</span> *yVel;
01046 
<a name="l01047"></a><a class="code" href="structFluxProps.html#a0">01047</a>   <a class="code" href="structFluxProps.html">FluxProps</a>(){
01048     no_of_sources=0;
01049   }
<a name="l01051"></a><a class="code" href="structFluxProps.html#a1">01051</a>   <span class="keywordtype">void</span> allocsrcs (<span class="keywordtype">int</span> nsrcs)
01052   {
01053     no_of_sources=nsrcs;
01054     influx  =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01055     xCen    =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01056     yCen    =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01057     majorrad=<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01058     minorrad=<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01059     cosrot  =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01060     sinrot  =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01061     start_time  =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01062     end_time    =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01063     xVel    =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01064     yVel    =<span class="keyword">new</span> <span class="keywordtype">double</span>[nsrcs];
01065   }
01066 
<a name="l01068"></a><a class="code" href="structFluxProps.html#a2">01068</a>   <span class="keywordtype">int</span> IfAnyStart(<a class="code" href="structTimeProps.html">TimeProps</a> *timeprops_ptr) {
01069 
01070     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> isrc=0; isrc&lt;no_of_sources; isrc++)
01071       <span class="keywordflow">if</span>(((timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o11">time</a>-timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o12">dtime</a>&lt;=start_time[isrc])&amp;&amp;
01072           (start_time[isrc]&lt;timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o11">time</a>))||
01073          ((timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o1">iter</a>==0)&amp;&amp;
01074           (start_time[isrc]==0.0))
01075          )
01076         <span class="keywordflow">return</span>(1);
01077  
01078     <span class="keywordflow">return</span>(0);
01079   }
01080 
<a name="l01082"></a><a class="code" href="structFluxProps.html#a3">01082</a>   <span class="keywordtype">double</span> MaxInfluxNow(<a class="code" href="structMatProps.html">MatProps</a> *matprops_ptr, <a class="code" href="structTimeProps.html">TimeProps</a> *timeprops_ptr) {
01083     <span class="keywordtype">double</span> tempinflux, maxinflux=0.0;
01084     
01085 
01086     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> isrc=0; isrc&lt;no_of_sources; isrc++)
01087       <span class="keywordflow">if</span>(((start_time[isrc]&lt;=timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o11">time</a>)&amp;&amp;
01088           (timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o11">time</a>&lt;=end_time[isrc]))||
01089          ((timeprops_ptr-&gt;<a class="code" href="structTimeProps.html#o1">iter</a>==0)&amp;&amp;
01090           (start_time[isrc]==0))
01091          ){
01092         tempinflux=sqrt(influx[isrc]*influx[isrc]+
01093                         (xVel[isrc]*xVel[isrc]+
01094                          yVel[isrc]*yVel[isrc])/
01095                         ((matprops_ptr-&gt;<a class="code" href="structMatProps.html#o11">epsilon</a>)*(matprops_ptr-&gt;<a class="code" href="structMatProps.html#o11">epsilon</a>)));
01096         <span class="keywordflow">if</span>(tempinflux&gt;maxinflux)
01097           maxinflux=tempinflux;
01098       }
01099        
01100     <span class="keywordflow">return</span>(maxinflux);
01101   }
01102 
01103 };
01104 
01105 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jul 3 12:45:53 2007 for Titan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
